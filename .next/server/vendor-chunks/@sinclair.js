"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@sinclair";
exports.ids = ["vendor-chunks/@sinclair"];
exports.modules = {

/***/ "(rsc)/./node_modules/@sinclair/typebox/typebox.js":
/*!***************************************************!*\
  !*** ./node_modules/@sinclair/typebox/typebox.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*--------------------------------------------------------------------------\n\n@sinclair/typebox\n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n---------------------------------------------------------------------------*/ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Type = exports.StandardType = exports.ExtendedTypeBuilder = exports.StandardTypeBuilder = exports.TypeBuilder = exports.TemplateLiteralDslParser = exports.TemplateLiteralGenerator = exports.TemplateLiteralFinite = exports.TemplateLiteralParser = exports.TemplateLiteralParserError = exports.TemplateLiteralResolver = exports.TemplateLiteralPattern = exports.UnionResolver = exports.KeyArrayResolver = exports.KeyResolver = exports.ObjectMap = exports.IndexedAccessor = exports.TypeClone = exports.TypeExtends = exports.TypeExtendsResult = exports.ExtendsUndefined = exports.TypeGuard = exports.TypeGuardUnknownTypeError = exports.FormatRegistry = exports.TypeRegistry = exports.PatternStringExact = exports.PatternNumberExact = exports.PatternBooleanExact = exports.PatternString = exports.PatternNumber = exports.PatternBoolean = exports.Kind = exports.Hint = exports.Modifier = void 0;\n// --------------------------------------------------------------------------\n// Symbols\n// --------------------------------------------------------------------------\nexports.Modifier = Symbol.for(\"TypeBox.Modifier\");\nexports.Hint = Symbol.for(\"TypeBox.Hint\");\nexports.Kind = Symbol.for(\"TypeBox.Kind\");\n// --------------------------------------------------------------------------\n// Patterns\n// --------------------------------------------------------------------------\nexports.PatternBoolean = \"(true|false)\";\nexports.PatternNumber = \"(0|[1-9][0-9]*)\";\nexports.PatternString = \"(.*)\";\nexports.PatternBooleanExact = `^${exports.PatternBoolean}$`;\nexports.PatternNumberExact = `^${exports.PatternNumber}$`;\nexports.PatternStringExact = `^${exports.PatternString}$`;\n/** A registry for user defined types */ var TypeRegistry;\n(function(TypeRegistry) {\n    const map = new Map();\n    /** Returns the entries in this registry */ function Entries() {\n        return new Map(map);\n    }\n    TypeRegistry.Entries = Entries;\n    /** Clears all user defined types */ function Clear() {\n        return map.clear();\n    }\n    TypeRegistry.Clear = Clear;\n    /** Returns true if this registry contains this kind */ function Has(kind) {\n        return map.has(kind);\n    }\n    TypeRegistry.Has = Has;\n    /** Sets a validation function for a user defined type */ function Set1(kind, func) {\n        map.set(kind, func);\n    }\n    TypeRegistry.Set = Set1;\n    /** Gets a custom validation function for a user defined type */ function Get(kind) {\n        return map.get(kind);\n    }\n    TypeRegistry.Get = Get;\n})(TypeRegistry || (exports.TypeRegistry = TypeRegistry = {}));\n/** A registry for user defined string formats */ var FormatRegistry;\n(function(FormatRegistry) {\n    const map = new Map();\n    /** Returns the entries in this registry */ function Entries() {\n        return new Map(map);\n    }\n    FormatRegistry.Entries = Entries;\n    /** Clears all user defined string formats */ function Clear() {\n        return map.clear();\n    }\n    FormatRegistry.Clear = Clear;\n    /** Returns true if the user defined string format exists */ function Has(format) {\n        return map.has(format);\n    }\n    FormatRegistry.Has = Has;\n    /** Sets a validation function for a user defined string format */ function Set1(format, func) {\n        map.set(format, func);\n    }\n    FormatRegistry.Set = Set1;\n    /** Gets a validation function for a user defined string format */ function Get(format) {\n        return map.get(format);\n    }\n    FormatRegistry.Get = Get;\n})(FormatRegistry || (exports.FormatRegistry = FormatRegistry = {}));\n// --------------------------------------------------------------------------\n// TypeGuard\n// --------------------------------------------------------------------------\nclass TypeGuardUnknownTypeError extends Error {\n    constructor(schema){\n        super(\"TypeGuard: Unknown type\");\n        this.schema = schema;\n    }\n}\nexports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;\n/** Provides functions to test if JavaScript values are TypeBox types */ var TypeGuard;\n(function(TypeGuard) {\n    function IsObject(value) {\n        return typeof value === \"object\" && value !== null && !Array.isArray(value);\n    }\n    function IsArray(value) {\n        return typeof value === \"object\" && value !== null && Array.isArray(value);\n    }\n    function IsPattern(value) {\n        try {\n            new RegExp(value);\n            return true;\n        } catch  {\n            return false;\n        }\n    }\n    function IsControlCharacterFree(value) {\n        if (typeof value !== \"string\") return false;\n        for(let i = 0; i < value.length; i++){\n            const code = value.charCodeAt(i);\n            if (code >= 7 && code <= 13 || code === 27 || code === 127) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function IsAdditionalProperties(value) {\n        return IsOptionalBoolean(value) || TSchema(value);\n    }\n    function IsBigInt(value) {\n        return typeof value === \"bigint\";\n    }\n    function IsString(value) {\n        return typeof value === \"string\";\n    }\n    function IsNumber(value) {\n        return typeof value === \"number\" && globalThis.Number.isFinite(value);\n    }\n    function IsBoolean(value) {\n        return typeof value === \"boolean\";\n    }\n    function IsOptionalBigInt(value) {\n        return value === undefined || value !== undefined && IsBigInt(value);\n    }\n    function IsOptionalNumber(value) {\n        return value === undefined || value !== undefined && IsNumber(value);\n    }\n    function IsOptionalBoolean(value) {\n        return value === undefined || value !== undefined && IsBoolean(value);\n    }\n    function IsOptionalString(value) {\n        return value === undefined || value !== undefined && IsString(value);\n    }\n    function IsOptionalPattern(value) {\n        return value === undefined || value !== undefined && IsString(value) && IsControlCharacterFree(value) && IsPattern(value);\n    }\n    function IsOptionalFormat(value) {\n        return value === undefined || value !== undefined && IsString(value) && IsControlCharacterFree(value);\n    }\n    function IsOptionalSchema(value) {\n        return value === undefined || TSchema(value);\n    }\n    /** Returns true if the given schema is TAny */ function TAny(schema) {\n        return TKind(schema) && schema[exports.Kind] === \"Any\" && IsOptionalString(schema.$id);\n    }\n    TypeGuard.TAny = TAny;\n    /** Returns true if the given schema is TArray */ function TArray(schema) {\n        return TKind(schema) && schema[exports.Kind] === \"Array\" && schema.type === \"array\" && IsOptionalString(schema.$id) && TSchema(schema.items) && IsOptionalNumber(schema.minItems) && IsOptionalNumber(schema.maxItems) && IsOptionalBoolean(schema.uniqueItems);\n    }\n    TypeGuard.TArray = TArray;\n    /** Returns true if the given schema is TBigInt */ function TBigInt(schema) {\n        // prettier-ignore\n        return TKind(schema) && schema[exports.Kind] === \"BigInt\" && schema.type === \"null\" && schema.typeOf === \"BigInt\" && IsOptionalString(schema.$id) && IsOptionalBigInt(schema.multipleOf) && IsOptionalBigInt(schema.minimum) && IsOptionalBigInt(schema.maximum) && IsOptionalBigInt(schema.exclusiveMinimum) && IsOptionalBigInt(schema.exclusiveMaximum);\n    }\n    TypeGuard.TBigInt = TBigInt;\n    /** Returns true if the given schema is TBoolean */ function TBoolean(schema) {\n        // prettier-ignore\n        return TKind(schema) && schema[exports.Kind] === \"Boolean\" && schema.type === \"boolean\" && IsOptionalString(schema.$id);\n    }\n    TypeGuard.TBoolean = TBoolean;\n    /** Returns true if the given schema is TConstructor */ function TConstructor(schema) {\n        // prettier-ignore\n        if (!(TKind(schema) && schema[exports.Kind] === \"Constructor\" && schema.type === \"object\" && schema.instanceOf === \"Constructor\" && IsOptionalString(schema.$id) && IsArray(schema.parameters) && TSchema(schema.returns))) {\n            return false;\n        }\n        for (const parameter of schema.parameters){\n            if (!TSchema(parameter)) return false;\n        }\n        return true;\n    }\n    TypeGuard.TConstructor = TConstructor;\n    /** Returns true if the given schema is TDate */ function TDate(schema) {\n        return TKind(schema) && schema[exports.Kind] === \"Date\" && schema.type === \"object\" && schema.instanceOf === \"Date\" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minimumTimestamp) && IsOptionalNumber(schema.maximumTimestamp) && IsOptionalNumber(schema.exclusiveMinimumTimestamp) && IsOptionalNumber(schema.exclusiveMaximumTimestamp);\n    }\n    TypeGuard.TDate = TDate;\n    /** Returns true if the given schema is TFunction */ function TFunction(schema) {\n        // prettier-ignore\n        if (!(TKind(schema) && schema[exports.Kind] === \"Function\" && schema.type === \"object\" && schema.instanceOf === \"Function\" && IsOptionalString(schema.$id) && IsArray(schema.parameters) && TSchema(schema.returns))) {\n            return false;\n        }\n        for (const parameter of schema.parameters){\n            if (!TSchema(parameter)) return false;\n        }\n        return true;\n    }\n    TypeGuard.TFunction = TFunction;\n    /** Returns true if the given schema is TInteger */ function TInteger(schema) {\n        return TKind(schema) && schema[exports.Kind] === \"Integer\" && schema.type === \"integer\" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.multipleOf) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.exclusiveMaximum);\n    }\n    TypeGuard.TInteger = TInteger;\n    /** Returns true if the given schema is TIntersect */ function TIntersect(schema) {\n        // prettier-ignore\n        if (!(TKind(schema) && schema[exports.Kind] === \"Intersect\" && IsArray(schema.allOf) && IsOptionalString(schema.type) && (IsOptionalBoolean(schema.unevaluatedProperties) || IsOptionalSchema(schema.unevaluatedProperties)) && IsOptionalString(schema.$id))) {\n            return false;\n        }\n        if (\"type\" in schema && schema.type !== \"object\") {\n            return false;\n        }\n        for (const inner of schema.allOf){\n            if (!TSchema(inner)) return false;\n        }\n        return true;\n    }\n    TypeGuard.TIntersect = TIntersect;\n    /** Returns true if the given schema is TKind */ function TKind(schema) {\n        return IsObject(schema) && exports.Kind in schema && typeof schema[exports.Kind] === \"string\"; // TS 4.1.5: any required for symbol indexer\n    }\n    TypeGuard.TKind = TKind;\n    /** Returns true if the given schema is TLiteral<string> */ function TLiteralString(schema) {\n        return TKind(schema) && schema[exports.Kind] === \"Literal\" && IsOptionalString(schema.$id) && typeof schema.const === \"string\";\n    }\n    TypeGuard.TLiteralString = TLiteralString;\n    /** Returns true if the given schema is TLiteral<number> */ function TLiteralNumber(schema) {\n        return TKind(schema) && schema[exports.Kind] === \"Literal\" && IsOptionalString(schema.$id) && typeof schema.const === \"number\";\n    }\n    TypeGuard.TLiteralNumber = TLiteralNumber;\n    /** Returns true if the given schema is TLiteral<boolean> */ function TLiteralBoolean(schema) {\n        return TKind(schema) && schema[exports.Kind] === \"Literal\" && IsOptionalString(schema.$id) && typeof schema.const === \"boolean\";\n    }\n    TypeGuard.TLiteralBoolean = TLiteralBoolean;\n    /** Returns true if the given schema is TLiteral */ function TLiteral(schema) {\n        return TLiteralString(schema) || TLiteralNumber(schema) || TLiteralBoolean(schema);\n    }\n    TypeGuard.TLiteral = TLiteral;\n    /** Returns true if the given schema is TNever */ function TNever(schema) {\n        return TKind(schema) && schema[exports.Kind] === \"Never\" && IsObject(schema.not) && globalThis.Object.getOwnPropertyNames(schema.not).length === 0;\n    }\n    TypeGuard.TNever = TNever;\n    /** Returns true if the given schema is TNot */ function TNot(schema) {\n        // prettier-ignore\n        return TKind(schema) && schema[exports.Kind] === \"Not\" && TSchema(schema.not);\n    }\n    TypeGuard.TNot = TNot;\n    /** Returns true if the given schema is TNull */ function TNull(schema) {\n        // prettier-ignore\n        return TKind(schema) && schema[exports.Kind] === \"Null\" && schema.type === \"null\" && IsOptionalString(schema.$id);\n    }\n    TypeGuard.TNull = TNull;\n    /** Returns true if the given schema is TNumber */ function TNumber(schema) {\n        return TKind(schema) && schema[exports.Kind] === \"Number\" && schema.type === \"number\" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.multipleOf) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.exclusiveMaximum);\n    }\n    TypeGuard.TNumber = TNumber;\n    /** Returns true if the given schema is TObject */ function TObject(schema) {\n        if (!(TKind(schema) && schema[exports.Kind] === \"Object\" && schema.type === \"object\" && IsOptionalString(schema.$id) && IsObject(schema.properties) && IsAdditionalProperties(schema.additionalProperties) && IsOptionalNumber(schema.minProperties) && IsOptionalNumber(schema.maxProperties))) {\n            return false;\n        }\n        for (const [key, value] of Object.entries(schema.properties)){\n            if (!IsControlCharacterFree(key)) return false;\n            if (!TSchema(value)) return false;\n        }\n        return true;\n    }\n    TypeGuard.TObject = TObject;\n    /** Returns true if the given schema is TPromise */ function TPromise(schema) {\n        // prettier-ignore\n        return TKind(schema) && schema[exports.Kind] === \"Promise\" && schema.type === \"object\" && schema.instanceOf === \"Promise\" && IsOptionalString(schema.$id) && TSchema(schema.item);\n    }\n    TypeGuard.TPromise = TPromise;\n    /** Returns true if the given schema is TRecord */ function TRecord(schema) {\n        // prettier-ignore\n        if (!(TKind(schema) && schema[exports.Kind] === \"Record\" && schema.type === \"object\" && IsOptionalString(schema.$id) && IsAdditionalProperties(schema.additionalProperties) && IsObject(schema.patternProperties))) {\n            return false;\n        }\n        const keys = Object.keys(schema.patternProperties);\n        if (keys.length !== 1) {\n            return false;\n        }\n        if (!IsPattern(keys[0])) {\n            return false;\n        }\n        if (!TSchema(schema.patternProperties[keys[0]])) {\n            return false;\n        }\n        return true;\n    }\n    TypeGuard.TRecord = TRecord;\n    /** Returns true if the given schema is TRef */ function TRef(schema) {\n        // prettier-ignore\n        return TKind(schema) && schema[exports.Kind] === \"Ref\" && IsOptionalString(schema.$id) && IsString(schema.$ref);\n    }\n    TypeGuard.TRef = TRef;\n    /** Returns true if the given schema is TString */ function TString(schema) {\n        return TKind(schema) && schema[exports.Kind] === \"String\" && schema.type === \"string\" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minLength) && IsOptionalNumber(schema.maxLength) && IsOptionalPattern(schema.pattern) && IsOptionalFormat(schema.format);\n    }\n    TypeGuard.TString = TString;\n    /** Returns true if the given schema is TSymbol */ function TSymbol(schema) {\n        // prettier-ignore\n        return TKind(schema) && schema[exports.Kind] === \"Symbol\" && schema.type === \"null\" && schema.typeOf === \"Symbol\" && IsOptionalString(schema.$id);\n    }\n    TypeGuard.TSymbol = TSymbol;\n    /** Returns true if the given schema is TTemplateLiteral */ function TTemplateLiteral(schema) {\n        // prettier-ignore\n        return TKind(schema) && schema[exports.Kind] === \"TemplateLiteral\" && schema.type === \"string\" && IsString(schema.pattern) && schema.pattern[0] === \"^\" && schema.pattern[schema.pattern.length - 1] === \"$\";\n    }\n    TypeGuard.TTemplateLiteral = TTemplateLiteral;\n    /** Returns true if the given schema is TThis */ function TThis(schema) {\n        // prettier-ignore\n        return TKind(schema) && schema[exports.Kind] === \"This\" && IsOptionalString(schema.$id) && IsString(schema.$ref);\n    }\n    TypeGuard.TThis = TThis;\n    /** Returns true if the given schema is TTuple */ function TTuple(schema) {\n        // prettier-ignore\n        if (!(TKind(schema) && schema[exports.Kind] === \"Tuple\" && schema.type === \"array\" && IsOptionalString(schema.$id) && IsNumber(schema.minItems) && IsNumber(schema.maxItems) && schema.minItems === schema.maxItems)) {\n            return false;\n        }\n        if (schema.items === undefined && schema.additionalItems === undefined && schema.minItems === 0) {\n            return true;\n        }\n        if (!IsArray(schema.items)) {\n            return false;\n        }\n        for (const inner of schema.items){\n            if (!TSchema(inner)) return false;\n        }\n        return true;\n    }\n    TypeGuard.TTuple = TTuple;\n    /** Returns true if the given schema is TUndefined */ function TUndefined(schema) {\n        // prettier-ignore\n        return TKind(schema) && schema[exports.Kind] === \"Undefined\" && schema.type === \"null\" && schema.typeOf === \"Undefined\" && IsOptionalString(schema.$id);\n    }\n    TypeGuard.TUndefined = TUndefined;\n    /** Returns true if the given schema is TUnion<Literal<string | number>[]> */ function TUnionLiteral(schema) {\n        return TUnion(schema) && schema.anyOf.every((schema)=>TLiteralString(schema) || TLiteralNumber(schema));\n    }\n    TypeGuard.TUnionLiteral = TUnionLiteral;\n    /** Returns true if the given schema is TUnion */ function TUnion(schema) {\n        // prettier-ignore\n        if (!(TKind(schema) && schema[exports.Kind] === \"Union\" && IsArray(schema.anyOf) && IsOptionalString(schema.$id))) {\n            return false;\n        }\n        for (const inner of schema.anyOf){\n            if (!TSchema(inner)) return false;\n        }\n        return true;\n    }\n    TypeGuard.TUnion = TUnion;\n    /** Returns true if the given schema is TUint8Array */ function TUint8Array(schema) {\n        return TKind(schema) && schema[exports.Kind] === \"Uint8Array\" && schema.type === \"object\" && IsOptionalString(schema.$id) && schema.instanceOf === \"Uint8Array\" && IsOptionalNumber(schema.minByteLength) && IsOptionalNumber(schema.maxByteLength);\n    }\n    TypeGuard.TUint8Array = TUint8Array;\n    /** Returns true if the given schema is TUnknown */ function TUnknown(schema) {\n        // prettier-ignore\n        return TKind(schema) && schema[exports.Kind] === \"Unknown\" && IsOptionalString(schema.$id);\n    }\n    TypeGuard.TUnknown = TUnknown;\n    /** Returns true if the given schema is a raw TUnsafe */ function TUnsafe(schema) {\n        // prettier-ignore\n        return TKind(schema) && schema[exports.Kind] === \"Unsafe\";\n    }\n    TypeGuard.TUnsafe = TUnsafe;\n    /** Returns true if the given schema is TVoid */ function TVoid(schema) {\n        // prettier-ignore\n        return TKind(schema) && schema[exports.Kind] === \"Void\" && schema.type === \"null\" && schema.typeOf === \"Void\" && IsOptionalString(schema.$id);\n    }\n    TypeGuard.TVoid = TVoid;\n    /** Returns true if this schema has the ReadonlyOptional modifier */ function TReadonlyOptional(schema) {\n        return IsObject(schema) && schema[exports.Modifier] === \"ReadonlyOptional\";\n    }\n    TypeGuard.TReadonlyOptional = TReadonlyOptional;\n    /** Returns true if this schema has the Readonly modifier */ function TReadonly(schema) {\n        return IsObject(schema) && schema[exports.Modifier] === \"Readonly\";\n    }\n    TypeGuard.TReadonly = TReadonly;\n    /** Returns true if this schema has the Optional modifier */ function TOptional(schema) {\n        return IsObject(schema) && schema[exports.Modifier] === \"Optional\";\n    }\n    TypeGuard.TOptional = TOptional;\n    /** Returns true if the given schema is TSchema */ function TSchema(schema) {\n        return typeof schema === \"object\" && (TAny(schema) || TArray(schema) || TBoolean(schema) || TBigInt(schema) || TConstructor(schema) || TDate(schema) || TFunction(schema) || TInteger(schema) || TIntersect(schema) || TLiteral(schema) || TNever(schema) || TNot(schema) || TNull(schema) || TNumber(schema) || TObject(schema) || TPromise(schema) || TRecord(schema) || TRef(schema) || TString(schema) || TSymbol(schema) || TTemplateLiteral(schema) || TThis(schema) || TTuple(schema) || TUndefined(schema) || TUnion(schema) || TUint8Array(schema) || TUnknown(schema) || TUnsafe(schema) || TVoid(schema) || TKind(schema) && TypeRegistry.Has(schema[exports.Kind]));\n    }\n    TypeGuard.TSchema = TSchema;\n})(TypeGuard || (exports.TypeGuard = TypeGuard = {}));\n// --------------------------------------------------------------------------\n// ExtendsUndefined\n// --------------------------------------------------------------------------\n/** Fast undefined check used for properties of type undefined */ var ExtendsUndefined;\n(function(ExtendsUndefined) {\n    function Check(schema) {\n        if (schema[exports.Kind] === \"Undefined\") return true;\n        if (schema[exports.Kind] === \"Not\") {\n            return !Check(schema.not);\n        }\n        if (schema[exports.Kind] === \"Intersect\") {\n            const intersect = schema;\n            return intersect.allOf.every((schema)=>Check(schema));\n        }\n        if (schema[exports.Kind] === \"Union\") {\n            const union = schema;\n            return union.anyOf.some((schema)=>Check(schema));\n        }\n        return false;\n    }\n    ExtendsUndefined.Check = Check;\n})(ExtendsUndefined || (exports.ExtendsUndefined = ExtendsUndefined = {}));\n// --------------------------------------------------------------------------\n// TypeExtends\n// --------------------------------------------------------------------------\nvar TypeExtendsResult;\n(function(TypeExtendsResult) {\n    TypeExtendsResult[TypeExtendsResult[\"Union\"] = 0] = \"Union\";\n    TypeExtendsResult[TypeExtendsResult[\"True\"] = 1] = \"True\";\n    TypeExtendsResult[TypeExtendsResult[\"False\"] = 2] = \"False\";\n})(TypeExtendsResult || (exports.TypeExtendsResult = TypeExtendsResult = {}));\nvar TypeExtends;\n(function(TypeExtends) {\n    // --------------------------------------------------------------------------\n    // IntoBooleanResult\n    // --------------------------------------------------------------------------\n    function IntoBooleanResult(result) {\n        return result === TypeExtendsResult.False ? TypeExtendsResult.False : TypeExtendsResult.True;\n    }\n    // --------------------------------------------------------------------------\n    // Any\n    // --------------------------------------------------------------------------\n    function AnyRight(left, right) {\n        return TypeExtendsResult.True;\n    }\n    function Any(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right) && right.anyOf.some((schema)=>TypeGuard.TAny(schema) || TypeGuard.TUnknown(schema))) return TypeExtendsResult.True;\n        if (TypeGuard.TUnion(right)) return TypeExtendsResult.Union;\n        if (TypeGuard.TUnknown(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TAny(right)) return TypeExtendsResult.True;\n        return TypeExtendsResult.Union;\n    }\n    // --------------------------------------------------------------------------\n    // Array\n    // --------------------------------------------------------------------------\n    function ArrayRight(left, right) {\n        if (TypeGuard.TUnknown(left)) return TypeExtendsResult.False;\n        if (TypeGuard.TAny(left)) return TypeExtendsResult.Union;\n        if (TypeGuard.TNever(left)) return TypeExtendsResult.True;\n        return TypeExtendsResult.False;\n    }\n    function Array1(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right) && IsObjectArrayLike(right)) return TypeExtendsResult.True;\n        if (!TypeGuard.TArray(right)) return TypeExtendsResult.False;\n        return IntoBooleanResult(Visit(left.items, right.items));\n    }\n    // --------------------------------------------------------------------------\n    // BigInt\n    // --------------------------------------------------------------------------\n    function BigInt(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TNever(right)) return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n        return TypeGuard.TBigInt(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Boolean\n    // --------------------------------------------------------------------------\n    function BooleanRight(left, right) {\n        if (TypeGuard.TLiteral(left) && typeof left.const === \"boolean\") return TypeExtendsResult.True;\n        return TypeGuard.TBoolean(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Boolean(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TNever(right)) return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n        return TypeGuard.TBoolean(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Constructor\n    // --------------------------------------------------------------------------\n    function Constructor(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        if (!TypeGuard.TConstructor(right)) return TypeExtendsResult.False;\n        if (left.parameters.length > right.parameters.length) return TypeExtendsResult.False;\n        if (!left.parameters.every((schema, index)=>IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) {\n            return TypeExtendsResult.False;\n        }\n        return IntoBooleanResult(Visit(left.returns, right.returns));\n    }\n    // --------------------------------------------------------------------------\n    // Date\n    // --------------------------------------------------------------------------\n    function Date(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n        return TypeGuard.TDate(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Function\n    // --------------------------------------------------------------------------\n    function Function(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        if (!TypeGuard.TFunction(right)) return TypeExtendsResult.False;\n        if (left.parameters.length > right.parameters.length) return TypeExtendsResult.False;\n        if (!left.parameters.every((schema, index)=>IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True)) {\n            return TypeExtendsResult.False;\n        }\n        return IntoBooleanResult(Visit(left.returns, right.returns));\n    }\n    // --------------------------------------------------------------------------\n    // Integer\n    // --------------------------------------------------------------------------\n    function IntegerRight(left, right) {\n        if (TypeGuard.TLiteral(left) && typeof left.const === \"number\") return TypeExtendsResult.True;\n        return TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Integer(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TNever(right)) return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n        return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Intersect\n    // --------------------------------------------------------------------------\n    function IntersectRight(left, right) {\n        return right.allOf.every((schema)=>Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Intersect(left, right) {\n        return left.allOf.some((schema)=>Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Literal\n    // --------------------------------------------------------------------------\n    function IsLiteralString(schema) {\n        return typeof schema.const === \"string\";\n    }\n    function IsLiteralNumber(schema) {\n        return typeof schema.const === \"number\";\n    }\n    function IsLiteralBoolean(schema) {\n        return typeof schema.const === \"boolean\";\n    }\n    function Literal(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TNever(right)) return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n        if (TypeGuard.TString(right)) return StringRight(left, right);\n        if (TypeGuard.TNumber(right)) return NumberRight(left, right);\n        if (TypeGuard.TInteger(right)) return IntegerRight(left, right);\n        if (TypeGuard.TBoolean(right)) return BooleanRight(left, right);\n        return TypeGuard.TLiteral(right) && right.const === left.const ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Never\n    // --------------------------------------------------------------------------\n    function NeverRight(left, right) {\n        return TypeExtendsResult.False;\n    }\n    function Never(left, right) {\n        return TypeExtendsResult.True;\n    }\n    // --------------------------------------------------------------------------\n    // Not\n    // --------------------------------------------------------------------------\n    function UnwrapNot(schema) {\n        let [current, depth] = [\n            schema,\n            0\n        ];\n        while(true){\n            if (!TypeGuard.TNot(current)) break;\n            current = current.not;\n            depth += 1;\n        }\n        return depth % 2 === 0 ? current : exports.Type.Unknown();\n    }\n    function Not(left, right) {\n        // TypeScript has no concept of negated types, and attempts to correctly check the negated\n        // type at runtime would put TypeBox at odds with TypeScripts ability to statically infer\n        // the type. Instead we unwrap to either unknown or T and continue evaluating.\n        if (TypeGuard.TNot(left)) return Visit(UnwrapNot(left), right);\n        if (TypeGuard.TNot(right)) return Visit(left, UnwrapNot(right));\n        throw new Error(`TypeExtends: Invalid fallthrough for Not`);\n    }\n    // --------------------------------------------------------------------------\n    // Null\n    // --------------------------------------------------------------------------\n    function Null(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TNever(right)) return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n        return TypeGuard.TNull(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Number\n    // --------------------------------------------------------------------------\n    function NumberRight(left, right) {\n        if (TypeGuard.TLiteral(left) && IsLiteralNumber(left)) return TypeExtendsResult.True;\n        return TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Number(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TNever(right)) return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n        return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Object\n    // --------------------------------------------------------------------------\n    function IsObjectPropertyCount(schema, count) {\n        return globalThis.Object.keys(schema.properties).length === count;\n    }\n    function IsObjectStringLike(schema) {\n        return IsObjectArrayLike(schema);\n    }\n    function IsObjectSymbolLike(schema) {\n        // prettier-ignore\n        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && \"description\" in schema.properties && TypeGuard.TUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (TypeGuard.TString(schema.properties.description.anyOf[0]) && TypeGuard.TUndefined(schema.properties.description.anyOf[1]) || TypeGuard.TString(schema.properties.description.anyOf[1]) && TypeGuard.TUndefined(schema.properties.description.anyOf[0]));\n    }\n    function IsObjectNumberLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectBooleanLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectBigIntLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectDateLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectUint8ArrayLike(schema) {\n        return IsObjectArrayLike(schema);\n    }\n    function IsObjectFunctionLike(schema) {\n        const length = exports.Type.Number();\n        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && \"length\" in schema.properties && IntoBooleanResult(Visit(schema.properties[\"length\"], length)) === TypeExtendsResult.True;\n    }\n    function IsObjectConstructorLike(schema) {\n        return IsObjectPropertyCount(schema, 0);\n    }\n    function IsObjectArrayLike(schema) {\n        const length = exports.Type.Number();\n        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && \"length\" in schema.properties && IntoBooleanResult(Visit(schema.properties[\"length\"], length)) === TypeExtendsResult.True;\n    }\n    function IsObjectPromiseLike(schema) {\n        const then = exports.Type.Function([\n            exports.Type.Any()\n        ], exports.Type.Any());\n        return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && \"then\" in schema.properties && IntoBooleanResult(Visit(schema.properties[\"then\"], then)) === TypeExtendsResult.True;\n    }\n    // --------------------------------------------------------------------------\n    // Property\n    // --------------------------------------------------------------------------\n    function Property(left, right) {\n        if (Visit(left, right) === TypeExtendsResult.False) return TypeExtendsResult.False;\n        if (TypeGuard.TOptional(left) && !TypeGuard.TOptional(right)) return TypeExtendsResult.False;\n        return TypeExtendsResult.True;\n    }\n    function ObjectRight(left, right) {\n        if (TypeGuard.TUnknown(left)) return TypeExtendsResult.False;\n        if (TypeGuard.TAny(left)) return TypeExtendsResult.Union;\n        if (TypeGuard.TNever(left)) return TypeExtendsResult.True;\n        if (TypeGuard.TLiteral(left) && IsLiteralString(left) && IsObjectStringLike(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TLiteral(left) && IsLiteralNumber(left) && IsObjectNumberLike(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TLiteral(left) && IsLiteralBoolean(left) && IsObjectBooleanLike(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TSymbol(left) && IsObjectSymbolLike(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TBigInt(left) && IsObjectBigIntLike(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TString(left) && IsObjectStringLike(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TSymbol(left) && IsObjectSymbolLike(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TNumber(left) && IsObjectNumberLike(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TInteger(left) && IsObjectNumberLike(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TBoolean(left) && IsObjectBooleanLike(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TUint8Array(left) && IsObjectUint8ArrayLike(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TDate(left) && IsObjectDateLike(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TConstructor(left) && IsObjectConstructorLike(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TFunction(left) && IsObjectFunctionLike(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TRecord(left) && TypeGuard.TString(RecordKey(left))) {\n            // When expressing a Record with literal key values, the Record is converted into a Object with\n            // the Hint assigned as `Record`. This is used to invert the extends logic.\n            return right[exports.Hint] === \"Record\" ? TypeExtendsResult.True : TypeExtendsResult.False;\n        }\n        if (TypeGuard.TRecord(left) && TypeGuard.TNumber(RecordKey(left))) {\n            return IsObjectPropertyCount(right, 0) ? TypeExtendsResult.True : TypeExtendsResult.False;\n        }\n        return TypeExtendsResult.False;\n    }\n    function Object1(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n        if (!TypeGuard.TObject(right)) return TypeExtendsResult.False;\n        for (const key of globalThis.Object.keys(right.properties)){\n            if (!(key in left.properties)) return TypeExtendsResult.False;\n            if (Property(left.properties[key], right.properties[key]) === TypeExtendsResult.False) {\n                return TypeExtendsResult.False;\n            }\n        }\n        return TypeExtendsResult.True;\n    }\n    // --------------------------------------------------------------------------\n    // Promise\n    // --------------------------------------------------------------------------\n    function Promise(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right) && IsObjectPromiseLike(right)) return TypeExtendsResult.True;\n        if (!TypeGuard.TPromise(right)) return TypeExtendsResult.False;\n        return IntoBooleanResult(Visit(left.item, right.item));\n    }\n    // --------------------------------------------------------------------------\n    // Record\n    // --------------------------------------------------------------------------\n    function RecordKey(schema) {\n        if (exports.PatternNumberExact in schema.patternProperties) return exports.Type.Number();\n        if (exports.PatternStringExact in schema.patternProperties) return exports.Type.String();\n        throw Error(\"TypeExtends: Cannot get record key\");\n    }\n    function RecordValue(schema) {\n        if (exports.PatternNumberExact in schema.patternProperties) return schema.patternProperties[exports.PatternNumberExact];\n        if (exports.PatternStringExact in schema.patternProperties) return schema.patternProperties[exports.PatternStringExact];\n        throw Error(\"TypeExtends: Cannot get record value\");\n    }\n    function RecordRight(left, right) {\n        const Key = RecordKey(right);\n        const Value = RecordValue(right);\n        if (TypeGuard.TLiteral(left) && IsLiteralString(left) && TypeGuard.TNumber(Key) && IntoBooleanResult(Visit(left, Value)) === TypeExtendsResult.True) return TypeExtendsResult.True;\n        if (TypeGuard.TUint8Array(left) && TypeGuard.TNumber(Key)) return Visit(left, Value);\n        if (TypeGuard.TString(left) && TypeGuard.TNumber(Key)) return Visit(left, Value);\n        if (TypeGuard.TArray(left) && TypeGuard.TNumber(Key)) return Visit(left, Value);\n        if (TypeGuard.TObject(left)) {\n            for (const key of globalThis.Object.keys(left.properties)){\n                if (Property(Value, left.properties[key]) === TypeExtendsResult.False) {\n                    return TypeExtendsResult.False;\n                }\n            }\n            return TypeExtendsResult.True;\n        }\n        return TypeExtendsResult.False;\n    }\n    function Record(left, right) {\n        const Value = RecordValue(left);\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        if (!TypeGuard.TRecord(right)) return TypeExtendsResult.False;\n        return Visit(Value, RecordValue(right));\n    }\n    // --------------------------------------------------------------------------\n    // String\n    // --------------------------------------------------------------------------\n    function StringRight(left, right) {\n        if (TypeGuard.TLiteral(left) && typeof left.const === \"string\") return TypeExtendsResult.True;\n        return TypeGuard.TString(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function String(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TNever(right)) return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n        return TypeGuard.TString(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Symbol\n    // --------------------------------------------------------------------------\n    function Symbol1(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TNever(right)) return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n        return TypeGuard.TSymbol(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // TemplateLiteral\n    // --------------------------------------------------------------------------\n    function TemplateLiteral(left, right) {\n        // TemplateLiteral types are resolved to either unions for finite expressions or string\n        // for infinite expressions. Here we call to TemplateLiteralResolver to resolve for\n        // either type and continue evaluating.\n        if (TypeGuard.TTemplateLiteral(left)) return Visit(TemplateLiteralResolver.Resolve(left), right);\n        if (TypeGuard.TTemplateLiteral(right)) return Visit(left, TemplateLiteralResolver.Resolve(right));\n        throw new Error(`TypeExtends: Invalid fallthrough for TemplateLiteral`);\n    }\n    // --------------------------------------------------------------------------\n    // Tuple\n    // --------------------------------------------------------------------------\n    function TupleRight(left, right) {\n        if (TypeGuard.TUnknown(left)) return TypeExtendsResult.False;\n        if (TypeGuard.TAny(left)) return TypeExtendsResult.Union;\n        if (TypeGuard.TNever(left)) return TypeExtendsResult.True;\n        return TypeExtendsResult.False;\n    }\n    function IsArrayOfTuple(left, right) {\n        return TypeGuard.TArray(right) && left.items !== undefined && left.items.every((schema)=>Visit(schema, right.items) === TypeExtendsResult.True);\n    }\n    function Tuple(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right) && IsObjectArrayLike(right)) return TypeExtendsResult.True;\n        if (TypeGuard.TArray(right) && IsArrayOfTuple(left, right)) return TypeExtendsResult.True;\n        if (!TypeGuard.TTuple(right)) return TypeExtendsResult.False;\n        if (left.items === undefined && right.items !== undefined || left.items !== undefined && right.items === undefined) return TypeExtendsResult.False;\n        if (left.items === undefined && right.items === undefined) return TypeExtendsResult.True;\n        return left.items.every((schema, index)=>Visit(schema, right.items[index]) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Uint8Array\n    // --------------------------------------------------------------------------\n    function Uint8Array(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n        return TypeGuard.TUint8Array(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Undefined\n    // --------------------------------------------------------------------------\n    function Undefined(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TNever(right)) return NeverRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        if (TypeGuard.TRecord(right)) return RecordRight(left, right);\n        if (TypeGuard.TVoid(right)) return VoidRight(left, right);\n        return TypeGuard.TUndefined(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Union\n    // --------------------------------------------------------------------------\n    function UnionRight(left, right) {\n        return right.anyOf.some((schema)=>Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Union(left, right) {\n        return left.anyOf.every((schema)=>Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Unknown\n    // --------------------------------------------------------------------------\n    function UnknownRight(left, right) {\n        return TypeExtendsResult.True;\n    }\n    function Unknown(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TString(right)) return StringRight(left, right);\n        if (TypeGuard.TNumber(right)) return NumberRight(left, right);\n        if (TypeGuard.TInteger(right)) return IntegerRight(left, right);\n        if (TypeGuard.TBoolean(right)) return BooleanRight(left, right);\n        if (TypeGuard.TArray(right)) return ArrayRight(left, right);\n        if (TypeGuard.TTuple(right)) return TupleRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        return TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    // --------------------------------------------------------------------------\n    // Void\n    // --------------------------------------------------------------------------\n    function VoidRight(left, right) {\n        if (TypeGuard.TUndefined(left)) return TypeExtendsResult.True;\n        return TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Void(left, right) {\n        if (TypeGuard.TIntersect(right)) return IntersectRight(left, right);\n        if (TypeGuard.TUnion(right)) return UnionRight(left, right);\n        if (TypeGuard.TUnknown(right)) return UnknownRight(left, right);\n        if (TypeGuard.TAny(right)) return AnyRight(left, right);\n        if (TypeGuard.TObject(right)) return ObjectRight(left, right);\n        return TypeGuard.TVoid(right) ? TypeExtendsResult.True : TypeExtendsResult.False;\n    }\n    function Visit(left, right) {\n        // Resolvable Types\n        if (TypeGuard.TTemplateLiteral(left) || TypeGuard.TTemplateLiteral(right)) return TemplateLiteral(left, right);\n        if (TypeGuard.TNot(left) || TypeGuard.TNot(right)) return Not(left, right);\n        // Standard Types\n        if (TypeGuard.TAny(left)) return Any(left, right);\n        if (TypeGuard.TArray(left)) return Array1(left, right);\n        if (TypeGuard.TBigInt(left)) return BigInt(left, right);\n        if (TypeGuard.TBoolean(left)) return Boolean(left, right);\n        if (TypeGuard.TConstructor(left)) return Constructor(left, right);\n        if (TypeGuard.TDate(left)) return Date(left, right);\n        if (TypeGuard.TFunction(left)) return Function(left, right);\n        if (TypeGuard.TInteger(left)) return Integer(left, right);\n        if (TypeGuard.TIntersect(left)) return Intersect(left, right);\n        if (TypeGuard.TLiteral(left)) return Literal(left, right);\n        if (TypeGuard.TNever(left)) return Never(left, right);\n        if (TypeGuard.TNull(left)) return Null(left, right);\n        if (TypeGuard.TNumber(left)) return Number(left, right);\n        if (TypeGuard.TObject(left)) return Object1(left, right);\n        if (TypeGuard.TRecord(left)) return Record(left, right);\n        if (TypeGuard.TString(left)) return String(left, right);\n        if (TypeGuard.TSymbol(left)) return Symbol1(left, right);\n        if (TypeGuard.TTuple(left)) return Tuple(left, right);\n        if (TypeGuard.TPromise(left)) return Promise(left, right);\n        if (TypeGuard.TUint8Array(left)) return Uint8Array(left, right);\n        if (TypeGuard.TUndefined(left)) return Undefined(left, right);\n        if (TypeGuard.TUnion(left)) return Union(left, right);\n        if (TypeGuard.TUnknown(left)) return Unknown(left, right);\n        if (TypeGuard.TVoid(left)) return Void(left, right);\n        throw Error(`TypeExtends: Unknown left type operand '${left[exports.Kind]}'`);\n    }\n    function Extends(left, right) {\n        return Visit(left, right);\n    }\n    TypeExtends.Extends = Extends;\n})(TypeExtends || (exports.TypeExtends = TypeExtends = {}));\n// --------------------------------------------------------------------------\n// TypeClone\n// --------------------------------------------------------------------------\n/** Specialized Clone for Types */ var TypeClone;\n(function(TypeClone) {\n    function IsObject(value) {\n        return typeof value === \"object\" && value !== null;\n    }\n    function IsArray(value) {\n        return globalThis.Array.isArray(value);\n    }\n    function Array1(value) {\n        return value.map((value)=>Visit(value));\n    }\n    function Object1(value) {\n        const clonedProperties = globalThis.Object.getOwnPropertyNames(value).reduce((acc, key)=>{\n            return {\n                ...acc,\n                [key]: Visit(value[key])\n            };\n        }, {});\n        const clonedSymbols = globalThis.Object.getOwnPropertySymbols(value).reduce((acc, key)=>{\n            return {\n                ...acc,\n                [key]: Visit(value[key])\n            };\n        }, {});\n        return {\n            ...clonedProperties,\n            ...clonedSymbols\n        };\n    }\n    function Visit(value) {\n        if (IsArray(value)) return Array1(value);\n        if (IsObject(value)) return Object1(value);\n        return value;\n    }\n    /** Clones a type. */ function Clone(schema, options) {\n        return {\n            ...Visit(schema),\n            ...options\n        };\n    }\n    TypeClone.Clone = Clone;\n})(TypeClone || (exports.TypeClone = TypeClone = {}));\n// --------------------------------------------------------------------------\n// IndexedAccessor\n// --------------------------------------------------------------------------\nvar IndexedAccessor;\n(function(IndexedAccessor) {\n    function OptionalUnwrap(schema) {\n        return schema.map((schema)=>{\n            const { [exports.Modifier]: _, ...clone } = TypeClone.Clone(schema, {});\n            return clone;\n        });\n    }\n    function IsIntersectOptional(schema) {\n        return schema.every((schema)=>TypeGuard.TOptional(schema));\n    }\n    function IsUnionOptional(schema) {\n        return schema.some((schema)=>TypeGuard.TOptional(schema));\n    }\n    function ResolveIntersect(schema) {\n        const optional = IsIntersectOptional(schema.allOf);\n        return optional ? exports.Type.Optional(exports.Type.Intersect(OptionalUnwrap(schema.allOf))) : schema;\n    }\n    function ResolveUnion(schema) {\n        const optional = IsUnionOptional(schema.anyOf);\n        return optional ? exports.Type.Optional(exports.Type.Union(OptionalUnwrap(schema.anyOf))) : schema;\n    }\n    function ResolveOptional(schema) {\n        if (schema[exports.Kind] === \"Intersect\") return ResolveIntersect(schema);\n        if (schema[exports.Kind] === \"Union\") return ResolveUnion(schema);\n        return schema;\n    }\n    function Intersect(schema, key) {\n        const resolved = schema.allOf.reduce((acc, schema)=>{\n            const indexed = Visit(schema, key);\n            return indexed[exports.Kind] === \"Never\" ? acc : [\n                ...acc,\n                indexed\n            ];\n        }, []);\n        return ResolveOptional(exports.Type.Intersect(resolved));\n    }\n    function Union(schema, key) {\n        const resolved = schema.anyOf.map((schema)=>Visit(schema, key));\n        return ResolveOptional(exports.Type.Union(resolved));\n    }\n    function Object1(schema, key) {\n        const property = schema.properties[key];\n        return property === undefined ? exports.Type.Never() : exports.Type.Union([\n            property\n        ]);\n    }\n    function Tuple(schema, key) {\n        const items = schema.items;\n        if (items === undefined) return exports.Type.Never();\n        const element = items[key]; //\n        if (element === undefined) return exports.Type.Never();\n        return element;\n    }\n    function Visit(schema, key) {\n        if (schema[exports.Kind] === \"Intersect\") return Intersect(schema, key);\n        if (schema[exports.Kind] === \"Union\") return Union(schema, key);\n        if (schema[exports.Kind] === \"Object\") return Object1(schema, key);\n        if (schema[exports.Kind] === \"Tuple\") return Tuple(schema, key);\n        return exports.Type.Never();\n    }\n    function Resolve(schema, keys, options = {}) {\n        const resolved = keys.map((key)=>Visit(schema, key.toString()));\n        return ResolveOptional(exports.Type.Union(resolved, options));\n    }\n    IndexedAccessor.Resolve = Resolve;\n})(IndexedAccessor || (exports.IndexedAccessor = IndexedAccessor = {}));\n// --------------------------------------------------------------------------\n// ObjectMap\n// --------------------------------------------------------------------------\nvar ObjectMap;\n(function(ObjectMap) {\n    function Intersect(schema, callback) {\n        // prettier-ignore\n        return exports.Type.Intersect(schema.allOf.map((inner)=>Visit(inner, callback)), {\n            ...schema\n        });\n    }\n    function Union(schema, callback) {\n        // prettier-ignore\n        return exports.Type.Union(schema.anyOf.map((inner)=>Visit(inner, callback)), {\n            ...schema\n        });\n    }\n    function Object1(schema, callback) {\n        return callback(schema);\n    }\n    function Visit(schema, callback) {\n        // There are cases where users need to map objects with unregistered kinds. Using a TypeGuard here would\n        // prevent sub schema mapping as unregistered kinds will not pass TSchema checks. This is notable in the\n        // case of TObject where unregistered property kinds cause the TObject check to fail. As mapping is only\n        // used for composition, we use explicit checks instead.\n        if (schema[exports.Kind] === \"Intersect\") return Intersect(schema, callback);\n        if (schema[exports.Kind] === \"Union\") return Union(schema, callback);\n        if (schema[exports.Kind] === \"Object\") return Object1(schema, callback);\n        return schema;\n    }\n    function Map1(schema, callback, options) {\n        return {\n            ...Visit(TypeClone.Clone(schema, {}), callback),\n            ...options\n        };\n    }\n    ObjectMap.Map = Map1;\n})(ObjectMap || (exports.ObjectMap = ObjectMap = {}));\nvar KeyResolver;\n(function(KeyResolver) {\n    function UnwrapPattern(key) {\n        return key[0] === \"^\" && key[key.length - 1] === \"$\" ? key.slice(1, key.length - 1) : key;\n    }\n    function Intersect(schema, options) {\n        return schema.allOf.reduce((acc, schema)=>[\n                ...acc,\n                ...Visit(schema, options)\n            ], []);\n    }\n    function Union(schema, options) {\n        const sets = schema.anyOf.map((inner)=>Visit(inner, options));\n        return [\n            ...sets.reduce((set, outer)=>outer.map((key)=>sets.every((inner)=>inner.includes(key)) ? set.add(key) : set)[0], new Set())\n        ];\n    }\n    function Object1(schema, options) {\n        return globalThis.Object.keys(schema.properties);\n    }\n    function Record(schema, options) {\n        return options.includePatterns ? globalThis.Object.keys(schema.patternProperties) : [];\n    }\n    function Visit(schema, options) {\n        if (TypeGuard.TIntersect(schema)) return Intersect(schema, options);\n        if (TypeGuard.TUnion(schema)) return Union(schema, options);\n        if (TypeGuard.TObject(schema)) return Object1(schema, options);\n        if (TypeGuard.TRecord(schema)) return Record(schema, options);\n        return [];\n    }\n    /** Resolves an array of keys in this schema */ function ResolveKeys(schema, options) {\n        return [\n            ...new Set(Visit(schema, options))\n        ];\n    }\n    KeyResolver.ResolveKeys = ResolveKeys;\n    /** Resolves a regular expression pattern matching all keys in this schema */ function ResolvePattern(schema) {\n        const keys = ResolveKeys(schema, {\n            includePatterns: true\n        });\n        const pattern = keys.map((key)=>`(${UnwrapPattern(key)})`);\n        return `^(${pattern.join(\"|\")})$`;\n    }\n    KeyResolver.ResolvePattern = ResolvePattern;\n})(KeyResolver || (exports.KeyResolver = KeyResolver = {}));\n// --------------------------------------------------------------------------\n// KeyArrayResolver\n// --------------------------------------------------------------------------\nvar KeyArrayResolver;\n(function(KeyArrayResolver) {\n    /** Resolves an array of string[] keys from the given schema or array type. */ function Resolve(schema) {\n        if (globalThis.Array.isArray(schema)) return schema;\n        if (TypeGuard.TUnionLiteral(schema)) return schema.anyOf.map((schema)=>schema.const.toString());\n        if (TypeGuard.TLiteral(schema)) return [\n            schema.const\n        ];\n        if (TypeGuard.TTemplateLiteral(schema)) {\n            const expression = TemplateLiteralParser.ParseExact(schema.pattern);\n            if (!TemplateLiteralFinite.Check(expression)) throw Error(\"KeyArrayResolver: Cannot resolve keys from infinite template expression\");\n            return [\n                ...TemplateLiteralGenerator.Generate(expression)\n            ];\n        }\n        return [];\n    }\n    KeyArrayResolver.Resolve = Resolve;\n})(KeyArrayResolver || (exports.KeyArrayResolver = KeyArrayResolver = {}));\n// --------------------------------------------------------------------------\n// UnionResolver\n// --------------------------------------------------------------------------\nvar UnionResolver;\n(function(UnionResolver) {\n    function* Union(union) {\n        for (const schema of union.anyOf){\n            if (schema[exports.Kind] === \"Union\") {\n                yield* Union(schema);\n            } else {\n                yield schema;\n            }\n        }\n    }\n    /** Returns a resolved union with interior unions flattened */ function Resolve(union) {\n        return exports.Type.Union([\n            ...Union(union)\n        ], {\n            ...union\n        });\n    }\n    UnionResolver.Resolve = Resolve;\n})(UnionResolver || (exports.UnionResolver = UnionResolver = {}));\n// --------------------------------------------------------------------------\n// TemplateLiteralPattern\n// --------------------------------------------------------------------------\nvar TemplateLiteralPattern;\n(function(TemplateLiteralPattern) {\n    function Escape(value) {\n        return value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n    }\n    function Visit(schema, acc) {\n        if (TypeGuard.TTemplateLiteral(schema)) {\n            const pattern = schema.pattern.slice(1, schema.pattern.length - 1);\n            return pattern;\n        } else if (TypeGuard.TUnion(schema)) {\n            const tokens = schema.anyOf.map((schema)=>Visit(schema, acc)).join(\"|\");\n            return `(${tokens})`;\n        } else if (TypeGuard.TNumber(schema)) {\n            return `${acc}${exports.PatternNumber}`;\n        } else if (TypeGuard.TInteger(schema)) {\n            return `${acc}${exports.PatternNumber}`;\n        } else if (TypeGuard.TBigInt(schema)) {\n            return `${acc}${exports.PatternNumber}`;\n        } else if (TypeGuard.TString(schema)) {\n            return `${acc}${exports.PatternString}`;\n        } else if (TypeGuard.TLiteral(schema)) {\n            return `${acc}${Escape(schema.const.toString())}`;\n        } else if (TypeGuard.TBoolean(schema)) {\n            return `${acc}${exports.PatternBoolean}`;\n        } else if (TypeGuard.TNever(schema)) {\n            throw Error(\"TemplateLiteralPattern: TemplateLiteral cannot operate on types of TNever\");\n        } else {\n            throw Error(`TemplateLiteralPattern: Unexpected Kind '${schema[exports.Kind]}'`);\n        }\n    }\n    function Create(kinds) {\n        return `^${kinds.map((schema)=>Visit(schema, \"\")).join(\"\")}\\$`;\n    }\n    TemplateLiteralPattern.Create = Create;\n})(TemplateLiteralPattern || (exports.TemplateLiteralPattern = TemplateLiteralPattern = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralResolver\n// --------------------------------------------------------------------------------------\nvar TemplateLiteralResolver;\n(function(TemplateLiteralResolver) {\n    /** Resolves a template literal as a TUnion */ function Resolve(template) {\n        const expression = TemplateLiteralParser.ParseExact(template.pattern);\n        if (!TemplateLiteralFinite.Check(expression)) return exports.Type.String();\n        const literals = [\n            ...TemplateLiteralGenerator.Generate(expression)\n        ].map((value)=>exports.Type.Literal(value));\n        return exports.Type.Union(literals);\n    }\n    TemplateLiteralResolver.Resolve = Resolve;\n})(TemplateLiteralResolver || (exports.TemplateLiteralResolver = TemplateLiteralResolver = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralParser\n// --------------------------------------------------------------------------------------\nclass TemplateLiteralParserError extends Error {\n    constructor(message){\n        super(message);\n    }\n}\nexports.TemplateLiteralParserError = TemplateLiteralParserError;\nvar TemplateLiteralParser;\n(function(TemplateLiteralParser) {\n    function IsNonEscaped(pattern, index, char) {\n        return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;\n    }\n    function IsOpenParen(pattern, index) {\n        return IsNonEscaped(pattern, index, \"(\");\n    }\n    function IsCloseParen(pattern, index) {\n        return IsNonEscaped(pattern, index, \")\");\n    }\n    function IsSeparator(pattern, index) {\n        return IsNonEscaped(pattern, index, \"|\");\n    }\n    function IsGroup(pattern) {\n        if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1))) return false;\n        let count = 0;\n        for(let index = 0; index < pattern.length; index++){\n            if (IsOpenParen(pattern, index)) count += 1;\n            if (IsCloseParen(pattern, index)) count -= 1;\n            if (count === 0 && index !== pattern.length - 1) return false;\n        }\n        return true;\n    }\n    function InGroup(pattern) {\n        return pattern.slice(1, pattern.length - 1);\n    }\n    function IsPrecedenceOr(pattern) {\n        let count = 0;\n        for(let index = 0; index < pattern.length; index++){\n            if (IsOpenParen(pattern, index)) count += 1;\n            if (IsCloseParen(pattern, index)) count -= 1;\n            if (IsSeparator(pattern, index) && count === 0) return true;\n        }\n        return false;\n    }\n    function IsPrecedenceAnd(pattern) {\n        for(let index = 0; index < pattern.length; index++){\n            if (IsOpenParen(pattern, index)) return true;\n        }\n        return false;\n    }\n    function Or(pattern) {\n        let [count, start] = [\n            0,\n            0\n        ];\n        const expressions = [];\n        for(let index = 0; index < pattern.length; index++){\n            if (IsOpenParen(pattern, index)) count += 1;\n            if (IsCloseParen(pattern, index)) count -= 1;\n            if (IsSeparator(pattern, index) && count === 0) {\n                const range = pattern.slice(start, index);\n                if (range.length > 0) expressions.push(Parse(range));\n                start = index + 1;\n            }\n        }\n        const range = pattern.slice(start);\n        if (range.length > 0) expressions.push(Parse(range));\n        if (expressions.length === 0) return {\n            type: \"const\",\n            const: \"\"\n        };\n        if (expressions.length === 1) return expressions[0];\n        return {\n            type: \"or\",\n            expr: expressions\n        };\n    }\n    function And(pattern) {\n        function Group(value, index) {\n            if (!IsOpenParen(value, index)) throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);\n            let count = 0;\n            for(let scan = index; scan < value.length; scan++){\n                if (IsOpenParen(value, scan)) count += 1;\n                if (IsCloseParen(value, scan)) count -= 1;\n                if (count === 0) return [\n                    index,\n                    scan\n                ];\n            }\n            throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);\n        }\n        function Range(pattern, index) {\n            for(let scan = index; scan < pattern.length; scan++){\n                if (IsOpenParen(pattern, scan)) return [\n                    index,\n                    scan\n                ];\n            }\n            return [\n                index,\n                pattern.length\n            ];\n        }\n        const expressions = [];\n        for(let index = 0; index < pattern.length; index++){\n            if (IsOpenParen(pattern, index)) {\n                const [start, end] = Group(pattern, index);\n                const range = pattern.slice(start, end + 1);\n                expressions.push(Parse(range));\n                index = end;\n            } else {\n                const [start, end] = Range(pattern, index);\n                const range = pattern.slice(start, end);\n                if (range.length > 0) expressions.push(Parse(range));\n                index = end - 1;\n            }\n        }\n        if (expressions.length === 0) return {\n            type: \"const\",\n            const: \"\"\n        };\n        if (expressions.length === 1) return expressions[0];\n        return {\n            type: \"and\",\n            expr: expressions\n        };\n    }\n    /** Parses a pattern and returns an expression tree */ function Parse(pattern) {\n        if (IsGroup(pattern)) return Parse(InGroup(pattern));\n        if (IsPrecedenceOr(pattern)) return Or(pattern);\n        if (IsPrecedenceAnd(pattern)) return And(pattern);\n        return {\n            type: \"const\",\n            const: pattern\n        };\n    }\n    TemplateLiteralParser.Parse = Parse;\n    /** Parses a pattern and strips forward and trailing ^ and $ */ function ParseExact(pattern) {\n        return Parse(pattern.slice(1, pattern.length - 1));\n    }\n    TemplateLiteralParser.ParseExact = ParseExact;\n})(TemplateLiteralParser || (exports.TemplateLiteralParser = TemplateLiteralParser = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralFinite\n// --------------------------------------------------------------------------------------\nvar TemplateLiteralFinite;\n(function(TemplateLiteralFinite) {\n    function IsNumber(expression) {\n        // prettier-ignore\n        return expression.type === \"or\" && expression.expr.length === 2 && expression.expr[0].type === \"const\" && expression.expr[0].const === \"0\" && expression.expr[1].type === \"const\" && expression.expr[1].const === \"[1-9][0-9]*\";\n    }\n    function IsBoolean(expression) {\n        // prettier-ignore\n        return expression.type === \"or\" && expression.expr.length === 2 && expression.expr[0].type === \"const\" && expression.expr[0].const === \"true\" && expression.expr[1].type === \"const\" && expression.expr[1].const === \"false\";\n    }\n    function IsString(expression) {\n        return expression.type === \"const\" && expression.const === \".*\";\n    }\n    function Check(expression) {\n        if (IsBoolean(expression)) return true;\n        if (IsNumber(expression) || IsString(expression)) return false;\n        if (expression.type === \"and\") return expression.expr.every((expr)=>Check(expr));\n        if (expression.type === \"or\") return expression.expr.every((expr)=>Check(expr));\n        if (expression.type === \"const\") return true;\n        throw Error(`TemplateLiteralFinite: Unknown expression type`);\n    }\n    TemplateLiteralFinite.Check = Check;\n})(TemplateLiteralFinite || (exports.TemplateLiteralFinite = TemplateLiteralFinite = {}));\n// --------------------------------------------------------------------------------------\n// TemplateLiteralGenerator\n// --------------------------------------------------------------------------------------\nvar TemplateLiteralGenerator;\n(function(TemplateLiteralGenerator) {\n    function* Reduce(buffer) {\n        if (buffer.length === 1) return yield* buffer[0];\n        for (const left of buffer[0]){\n            for (const right of Reduce(buffer.slice(1))){\n                yield `${left}${right}`;\n            }\n        }\n    }\n    function* And(expression) {\n        return yield* Reduce(expression.expr.map((expr)=>[\n                ...Generate(expr)\n            ]));\n    }\n    function* Or(expression) {\n        for (const expr of expression.expr)yield* Generate(expr);\n    }\n    function* Const(expression) {\n        return yield expression.const;\n    }\n    function* Generate(expression) {\n        if (expression.type === \"and\") return yield* And(expression);\n        if (expression.type === \"or\") return yield* Or(expression);\n        if (expression.type === \"const\") return yield* Const(expression);\n        throw Error(\"TemplateLiteralGenerator: Unknown expression\");\n    }\n    TemplateLiteralGenerator.Generate = Generate;\n})(TemplateLiteralGenerator || (exports.TemplateLiteralGenerator = TemplateLiteralGenerator = {}));\n// ---------------------------------------------------------------------\n// TemplateLiteralDslParser\n// ---------------------------------------------------------------------\nvar TemplateLiteralDslParser;\n(function(TemplateLiteralDslParser) {\n    function* ParseUnion(template) {\n        const trim = template.trim().replace(/\"|'/g, \"\");\n        if (trim === \"boolean\") return yield exports.Type.Boolean();\n        if (trim === \"number\") return yield exports.Type.Number();\n        if (trim === \"bigint\") return yield exports.Type.BigInt();\n        if (trim === \"string\") return yield exports.Type.String();\n        const literals = trim.split(\"|\").map((literal)=>exports.Type.Literal(literal.trim()));\n        return yield literals.length === 0 ? exports.Type.Never() : literals.length === 1 ? literals[0] : exports.Type.Union(literals);\n    }\n    function* ParseTerminal(template) {\n        if (template[1] !== \"{\") {\n            const L = exports.Type.Literal(\"$\");\n            const R = ParseLiteral(template.slice(1));\n            return yield* [\n                L,\n                ...R\n            ];\n        }\n        for(let i = 2; i < template.length; i++){\n            if (template[i] === \"}\") {\n                const L = ParseUnion(template.slice(2, i));\n                const R = ParseLiteral(template.slice(i + 1));\n                return yield* [\n                    ...L,\n                    ...R\n                ];\n            }\n        }\n        yield exports.Type.Literal(template);\n    }\n    function* ParseLiteral(template) {\n        for(let i = 0; i < template.length; i++){\n            if (template[i] === \"$\") {\n                const L = exports.Type.Literal(template.slice(0, i));\n                const R = ParseTerminal(template.slice(i));\n                return yield* [\n                    L,\n                    ...R\n                ];\n            }\n        }\n        yield exports.Type.Literal(template);\n    }\n    function Parse(template_dsl) {\n        return [\n            ...ParseLiteral(template_dsl)\n        ];\n    }\n    TemplateLiteralDslParser.Parse = Parse;\n})(TemplateLiteralDslParser || (exports.TemplateLiteralDslParser = TemplateLiteralDslParser = {}));\n// --------------------------------------------------------------------------\n// TypeOrdinal: Used for auto $id generation\n// --------------------------------------------------------------------------\nlet TypeOrdinal = 0;\n// --------------------------------------------------------------------------\n// TypeBuilder\n// --------------------------------------------------------------------------\nclass TypeBuilder {\n    /** `[Utility]` Creates a schema without `static` and `params` types */ Create(schema) {\n        return schema;\n    }\n    /** `[Standard]` Omits compositing symbols from this schema */ Strict(schema) {\n        return JSON.parse(JSON.stringify(schema));\n    }\n}\nexports.TypeBuilder = TypeBuilder;\n// --------------------------------------------------------------------------\n// StandardTypeBuilder\n// --------------------------------------------------------------------------\nclass StandardTypeBuilder extends TypeBuilder {\n    // ------------------------------------------------------------------------\n    // Modifiers\n    // ------------------------------------------------------------------------\n    /** `[Modifier]` Creates a Optional property */ Optional(schema) {\n        return {\n            [exports.Modifier]: \"Optional\",\n            ...TypeClone.Clone(schema, {})\n        };\n    }\n    /** `[Modifier]` Creates a ReadonlyOptional property */ ReadonlyOptional(schema) {\n        return {\n            [exports.Modifier]: \"ReadonlyOptional\",\n            ...TypeClone.Clone(schema, {})\n        };\n    }\n    /** `[Modifier]` Creates a Readonly object or property */ Readonly(schema) {\n        return {\n            [exports.Modifier]: \"Readonly\",\n            ...schema\n        };\n    }\n    // ------------------------------------------------------------------------\n    // Types\n    // ------------------------------------------------------------------------\n    /** `[Standard]` Creates an Any type */ Any(options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Any\"\n        });\n    }\n    /** `[Standard]` Creates an Array type */ Array(items, options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Array\",\n            type: \"array\",\n            items: TypeClone.Clone(items, {})\n        });\n    }\n    /** `[Standard]` Creates a Boolean type */ Boolean(options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Boolean\",\n            type: \"boolean\"\n        });\n    }\n    /** `[Standard]` Creates a Composite object type. */ Composite(objects, options) {\n        const intersect = exports.Type.Intersect(objects, {});\n        const keys = KeyResolver.ResolveKeys(intersect, {\n            includePatterns: false\n        });\n        const properties = keys.reduce((acc, key)=>({\n                ...acc,\n                [key]: exports.Type.Index(intersect, [\n                    key\n                ])\n            }), {});\n        return exports.Type.Object(properties, options);\n    }\n    /** `[Standard]` Creates a Enum type */ Enum(item, options = {}) {\n        // prettier-ignore\n        const values = globalThis.Object.keys(item).filter((key)=>isNaN(key)).map((key)=>item[key]);\n        const anyOf = values.map((value)=>typeof value === \"string\" ? {\n                [exports.Kind]: \"Literal\",\n                type: \"string\",\n                const: value\n            } : {\n                [exports.Kind]: \"Literal\",\n                type: \"number\",\n                const: value\n            });\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Union\",\n            anyOf\n        });\n    }\n    /** `[Standard]` A conditional type expression that will return the true type if the left type extends the right */ Extends(left, right, trueType, falseType, options = {}) {\n        switch(TypeExtends.Extends(left, right)){\n            case TypeExtendsResult.Union:\n                return this.Union([\n                    TypeClone.Clone(trueType, options),\n                    TypeClone.Clone(falseType, options)\n                ]);\n            case TypeExtendsResult.True:\n                return TypeClone.Clone(trueType, options);\n            case TypeExtendsResult.False:\n                return TypeClone.Clone(falseType, options);\n        }\n    }\n    /** `[Standard]` Excludes from the left type any type that is not assignable to the right */ Exclude(left, right, options = {}) {\n        if (TypeGuard.TTemplateLiteral(left)) return this.Exclude(TemplateLiteralResolver.Resolve(left), right, options);\n        if (TypeGuard.TTemplateLiteral(right)) return this.Exclude(left, TemplateLiteralResolver.Resolve(right), options);\n        if (TypeGuard.TUnion(left)) {\n            const narrowed = left.anyOf.filter((inner)=>TypeExtends.Extends(inner, right) === TypeExtendsResult.False);\n            return narrowed.length === 1 ? TypeClone.Clone(narrowed[0], options) : this.Union(narrowed, options);\n        } else {\n            return TypeExtends.Extends(left, right) !== TypeExtendsResult.False ? this.Never(options) : TypeClone.Clone(left, options);\n        }\n    }\n    /** `[Standard]` Extracts from the left type any type that is assignable to the right */ Extract(left, right, options = {}) {\n        if (TypeGuard.TTemplateLiteral(left)) return this.Extract(TemplateLiteralResolver.Resolve(left), right, options);\n        if (TypeGuard.TTemplateLiteral(right)) return this.Extract(left, TemplateLiteralResolver.Resolve(right), options);\n        if (TypeGuard.TUnion(left)) {\n            const narrowed = left.anyOf.filter((inner)=>TypeExtends.Extends(inner, right) !== TypeExtendsResult.False);\n            return narrowed.length === 1 ? TypeClone.Clone(narrowed[0], options) : this.Union(narrowed, options);\n        } else {\n            return TypeExtends.Extends(left, right) !== TypeExtendsResult.False ? TypeClone.Clone(left, options) : this.Never(options);\n        }\n    }\n    /** `[Standard]` Returns indexed property types for the given keys */ Index(schema, unresolved, options = {}) {\n        if (TypeGuard.TArray(schema) && TypeGuard.TNumber(unresolved)) {\n            return TypeClone.Clone(schema.items, options);\n        } else if (TypeGuard.TTuple(schema) && TypeGuard.TNumber(unresolved)) {\n            const items = schema.items === undefined ? [] : schema.items;\n            const cloned = items.map((schema)=>TypeClone.Clone(schema, {}));\n            return this.Union(cloned, options);\n        } else {\n            const keys = KeyArrayResolver.Resolve(unresolved);\n            const clone = TypeClone.Clone(schema, {});\n            return IndexedAccessor.Resolve(clone, keys, options);\n        }\n    }\n    /** `[Standard]` Creates an Integer type */ Integer(options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Integer\",\n            type: \"integer\"\n        });\n    }\n    Intersect(allOf, options = {}) {\n        if (allOf.length === 0) return exports.Type.Never();\n        if (allOf.length === 1) return TypeClone.Clone(allOf[0], options);\n        const objects = allOf.every((schema)=>TypeGuard.TObject(schema));\n        const cloned = allOf.map((schema)=>TypeClone.Clone(schema, {}));\n        const clonedUnevaluatedProperties = TypeGuard.TSchema(options.unevaluatedProperties) ? {\n            unevaluatedProperties: TypeClone.Clone(options.unevaluatedProperties, {})\n        } : {};\n        if (options.unevaluatedProperties === false || TypeGuard.TSchema(options.unevaluatedProperties) || objects) {\n            return this.Create({\n                ...options,\n                ...clonedUnevaluatedProperties,\n                [exports.Kind]: \"Intersect\",\n                type: \"object\",\n                allOf: cloned\n            });\n        } else {\n            return this.Create({\n                ...options,\n                ...clonedUnevaluatedProperties,\n                [exports.Kind]: \"Intersect\",\n                allOf: cloned\n            });\n        }\n    }\n    /** `[Standard]` Creates a KeyOf type */ KeyOf(schema, options = {}) {\n        if (TypeGuard.TRecord(schema)) {\n            const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];\n            if (pattern === exports.PatternNumberExact) return this.Number(options);\n            if (pattern === exports.PatternStringExact) return this.String(options);\n            throw Error(\"StandardTypeBuilder: Unable to resolve key type from Record key pattern\");\n        } else if (TypeGuard.TTuple(schema)) {\n            const items = schema.items === undefined ? [] : schema.items;\n            const literals = items.map((_, index)=>exports.Type.Literal(index));\n            return this.Union(literals, options);\n        } else if (TypeGuard.TArray(schema)) {\n            return this.Number(options);\n        } else {\n            const keys = KeyResolver.ResolveKeys(schema, {\n                includePatterns: false\n            });\n            if (keys.length === 0) return this.Never(options);\n            const literals = keys.map((key)=>this.Literal(key));\n            return this.Union(literals, options);\n        }\n    }\n    /** `[Standard]` Creates a Literal type */ Literal(value, options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Literal\",\n            const: value,\n            type: typeof value\n        });\n    }\n    /** `[Standard]` Creates a Never type */ Never(options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Never\",\n            not: {}\n        });\n    }\n    /** `[Standard]` Creates a Not type */ Not(not, options) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Not\",\n            not\n        });\n    }\n    /** `[Standard]` Creates a Null type */ Null(options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Null\",\n            type: \"null\"\n        });\n    }\n    /** `[Standard]` Creates a Number type */ Number(options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Number\",\n            type: \"number\"\n        });\n    }\n    /** `[Standard]` Creates an Object type */ Object(properties, options = {}) {\n        const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);\n        const optionalKeys = propertyKeys.filter((key)=>TypeGuard.TOptional(properties[key]) || TypeGuard.TReadonlyOptional(properties[key]));\n        const requiredKeys = propertyKeys.filter((name)=>!optionalKeys.includes(name));\n        const clonedAdditionalProperties = TypeGuard.TSchema(options.additionalProperties) ? {\n            additionalProperties: TypeClone.Clone(options.additionalProperties, {})\n        } : {};\n        const clonedProperties = propertyKeys.reduce((acc, key)=>({\n                ...acc,\n                [key]: TypeClone.Clone(properties[key], {})\n            }), {});\n        if (requiredKeys.length > 0) {\n            return this.Create({\n                ...options,\n                ...clonedAdditionalProperties,\n                [exports.Kind]: \"Object\",\n                type: \"object\",\n                properties: clonedProperties,\n                required: requiredKeys\n            });\n        } else {\n            return this.Create({\n                ...options,\n                ...clonedAdditionalProperties,\n                [exports.Kind]: \"Object\",\n                type: \"object\",\n                properties: clonedProperties\n            });\n        }\n    }\n    Omit(schema, unresolved, options = {}) {\n        const keys = KeyArrayResolver.Resolve(unresolved);\n        // prettier-ignore\n        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema)=>{\n            if (schema.required) {\n                schema.required = schema.required.filter((key)=>!keys.includes(key));\n                if (schema.required.length === 0) delete schema.required;\n            }\n            for (const key of globalThis.Object.keys(schema.properties)){\n                if (keys.includes(key)) delete schema.properties[key];\n            }\n            return this.Create(schema);\n        }, options);\n    }\n    /** `[Standard]` Creates a mapped type where all properties are Optional */ Partial(schema, options = {}) {\n        function Apply(schema) {\n            // prettier-ignore\n            switch(schema[exports.Modifier]){\n                case \"ReadonlyOptional\":\n                    schema[exports.Modifier] = \"ReadonlyOptional\";\n                    break;\n                case \"Readonly\":\n                    schema[exports.Modifier] = \"ReadonlyOptional\";\n                    break;\n                case \"Optional\":\n                    schema[exports.Modifier] = \"Optional\";\n                    break;\n                default:\n                    schema[exports.Modifier] = \"Optional\";\n                    break;\n            }\n        }\n        // prettier-ignore\n        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema)=>{\n            delete schema.required;\n            globalThis.Object.keys(schema.properties).forEach((key)=>Apply(schema.properties[key]));\n            return schema;\n        }, options);\n    }\n    Pick(schema, unresolved, options = {}) {\n        const keys = KeyArrayResolver.Resolve(unresolved);\n        // prettier-ignore\n        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema)=>{\n            if (schema.required) {\n                schema.required = schema.required.filter((key)=>keys.includes(key));\n                if (schema.required.length === 0) delete schema.required;\n            }\n            for (const key of globalThis.Object.keys(schema.properties)){\n                if (!keys.includes(key)) delete schema.properties[key];\n            }\n            return this.Create(schema);\n        }, options);\n    }\n    /** `[Standard]` Creates a Record type */ Record(key, schema, options = {}) {\n        if (TypeGuard.TTemplateLiteral(key)) {\n            const expression = TemplateLiteralParser.ParseExact(key.pattern);\n            // prettier-ignore\n            return TemplateLiteralFinite.Check(expression) ? this.Object([\n                ...TemplateLiteralGenerator.Generate(expression)\n            ].reduce((acc, key)=>({\n                    ...acc,\n                    [key]: TypeClone.Clone(schema, {})\n                }), {}), options) : this.Create({\n                ...options,\n                [exports.Kind]: \"Record\",\n                type: \"object\",\n                patternProperties: {\n                    [key.pattern]: TypeClone.Clone(schema, {})\n                }\n            });\n        } else if (TypeGuard.TUnion(key)) {\n            const union = UnionResolver.Resolve(key);\n            if (TypeGuard.TUnionLiteral(union)) {\n                const properties = union.anyOf.reduce((acc, literal)=>({\n                        ...acc,\n                        [literal.const]: TypeClone.Clone(schema, {})\n                    }), {});\n                return this.Object(properties, {\n                    ...options,\n                    [exports.Hint]: \"Record\"\n                });\n            } else throw Error(\"TypeBuilder: Record key of type union contains non-literal types\");\n        } else if (TypeGuard.TLiteral(key)) {\n            if (typeof key.const === \"string\" || typeof key.const === \"number\") {\n                return this.Object({\n                    [key.const]: TypeClone.Clone(schema, {})\n                }, options);\n            } else throw Error(\"TypeBuilder: Record key of type literal is not of type string or number\");\n        } else if (TypeGuard.TInteger(key) || TypeGuard.TNumber(key)) {\n            const pattern = exports.PatternNumberExact;\n            return this.Create({\n                ...options,\n                [exports.Kind]: \"Record\",\n                type: \"object\",\n                patternProperties: {\n                    [pattern]: TypeClone.Clone(schema, {})\n                }\n            });\n        } else if (TypeGuard.TString(key)) {\n            const pattern = key.pattern === undefined ? exports.PatternStringExact : key.pattern;\n            return this.Create({\n                ...options,\n                [exports.Kind]: \"Record\",\n                type: \"object\",\n                patternProperties: {\n                    [pattern]: TypeClone.Clone(schema, {})\n                }\n            });\n        } else {\n            throw Error(`StandardTypeBuilder: Record key is an invalid type`);\n        }\n    }\n    /** `[Standard]` Creates a Recursive type */ Recursive(callback, options = {}) {\n        if (options.$id === undefined) options.$id = `T${TypeOrdinal++}`;\n        const thisType = callback({\n            [exports.Kind]: \"This\",\n            $ref: `${options.$id}`\n        });\n        thisType.$id = options.$id;\n        return this.Create({\n            ...options,\n            [exports.Hint]: \"Recursive\",\n            ...thisType\n        });\n    }\n    /** `[Standard]` Creates a Ref type. The referenced type must contain a $id */ Ref(schema, options = {}) {\n        if (schema.$id === undefined) throw Error(\"StandardTypeBuilder.Ref: Target type must specify an $id\");\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Ref\",\n            $ref: schema.$id\n        });\n    }\n    /** `[Standard]` Creates a mapped type where all properties are Required */ Required(schema, options = {}) {\n        function Apply(schema) {\n            // prettier-ignore\n            switch(schema[exports.Modifier]){\n                case \"ReadonlyOptional\":\n                    schema[exports.Modifier] = \"Readonly\";\n                    break;\n                case \"Readonly\":\n                    schema[exports.Modifier] = \"Readonly\";\n                    break;\n                case \"Optional\":\n                    delete schema[exports.Modifier];\n                    break;\n                default:\n                    delete schema[exports.Modifier];\n                    break;\n            }\n        }\n        // prettier-ignore\n        return ObjectMap.Map(TypeClone.Clone(schema, {}), (schema)=>{\n            schema.required = globalThis.Object.keys(schema.properties);\n            globalThis.Object.keys(schema.properties).forEach((key)=>Apply(schema.properties[key]));\n            return schema;\n        }, options);\n    }\n    /** `[Standard]` Returns a schema array which allows types to compose with the JavaScript spread operator */ Rest(schema) {\n        if (TypeGuard.TTuple(schema)) {\n            if (schema.items === undefined) return [];\n            return schema.items.map((schema)=>TypeClone.Clone(schema, {}));\n        } else {\n            return [\n                TypeClone.Clone(schema, {})\n            ];\n        }\n    }\n    /** `[Standard]` Creates a String type */ String(options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"String\",\n            type: \"string\"\n        });\n    }\n    /** `[Standard]` Creates a template literal type */ TemplateLiteral(unresolved, options = {}) {\n        // prettier-ignore\n        const pattern = typeof unresolved === \"string\" ? TemplateLiteralPattern.Create(TemplateLiteralDslParser.Parse(unresolved)) : TemplateLiteralPattern.Create(unresolved);\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"TemplateLiteral\",\n            type: \"string\",\n            pattern\n        });\n    }\n    /** `[Standard]` Creates a Tuple type */ Tuple(items, options = {}) {\n        const [additionalItems, minItems, maxItems] = [\n            false,\n            items.length,\n            items.length\n        ];\n        const clonedItems = items.map((item)=>TypeClone.Clone(item, {}));\n        // prettier-ignore\n        const schema = items.length > 0 ? {\n            ...options,\n            [exports.Kind]: \"Tuple\",\n            type: \"array\",\n            items: clonedItems,\n            additionalItems,\n            minItems,\n            maxItems\n        } : {\n            ...options,\n            [exports.Kind]: \"Tuple\",\n            type: \"array\",\n            minItems,\n            maxItems\n        };\n        return this.Create(schema);\n    }\n    Union(union, options = {}) {\n        if (TypeGuard.TTemplateLiteral(union)) {\n            return TemplateLiteralResolver.Resolve(union);\n        } else {\n            const anyOf = union;\n            if (anyOf.length === 0) return this.Never(options);\n            if (anyOf.length === 1) return this.Create(TypeClone.Clone(anyOf[0], options));\n            const clonedAnyOf = anyOf.map((schema)=>TypeClone.Clone(schema, {}));\n            return this.Create({\n                ...options,\n                [exports.Kind]: \"Union\",\n                anyOf: clonedAnyOf\n            });\n        }\n    }\n    /** `[Standard]` Creates an Unknown type */ Unknown(options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Unknown\"\n        });\n    }\n    /** `[Standard]` Creates a Unsafe type that infers for the generic argument */ Unsafe(options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: options[exports.Kind] || \"Unsafe\"\n        });\n    }\n}\nexports.StandardTypeBuilder = StandardTypeBuilder;\n// --------------------------------------------------------------------------\n// ExtendedTypeBuilder\n// --------------------------------------------------------------------------\nclass ExtendedTypeBuilder extends StandardTypeBuilder {\n    /** `[Extended]` Creates a BigInt type */ BigInt(options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"BigInt\",\n            type: \"null\",\n            typeOf: \"BigInt\"\n        });\n    }\n    /** `[Extended]` Extracts the ConstructorParameters from the given Constructor type */ ConstructorParameters(schema, options = {}) {\n        return this.Tuple([\n            ...schema.parameters\n        ], {\n            ...options\n        });\n    }\n    /** `[Extended]` Creates a Constructor type */ Constructor(parameters, returns, options) {\n        const clonedReturns = TypeClone.Clone(returns, {});\n        const clonedParameters = parameters.map((parameter)=>TypeClone.Clone(parameter, {}));\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Constructor\",\n            type: \"object\",\n            instanceOf: \"Constructor\",\n            parameters: clonedParameters,\n            returns: clonedReturns\n        });\n    }\n    /** `[Extended]` Creates a Date type */ Date(options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Date\",\n            type: \"object\",\n            instanceOf: \"Date\"\n        });\n    }\n    /** `[Extended]` Creates a Function type */ Function(parameters, returns, options) {\n        const clonedReturns = TypeClone.Clone(returns, {});\n        const clonedParameters = parameters.map((parameter)=>TypeClone.Clone(parameter, {}));\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Function\",\n            type: \"object\",\n            instanceOf: \"Function\",\n            parameters: clonedParameters,\n            returns: clonedReturns\n        });\n    }\n    /** `[Extended]` Extracts the InstanceType from the given Constructor */ InstanceType(schema, options = {}) {\n        return TypeClone.Clone(schema.returns, options);\n    }\n    /** `[Extended]` Extracts the Parameters from the given Function type */ Parameters(schema, options = {}) {\n        return this.Tuple(schema.parameters, {\n            ...options\n        });\n    }\n    /** `[Extended]` Creates a Promise type */ Promise(item, options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Promise\",\n            type: \"object\",\n            instanceOf: \"Promise\",\n            item: TypeClone.Clone(item, {})\n        });\n    }\n    /** `[Extended]` Creates a regular expression type */ RegEx(regex, options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"String\",\n            type: \"string\",\n            pattern: regex.source\n        });\n    }\n    /** `[Extended]` Extracts the ReturnType from the given Function */ ReturnType(schema, options = {}) {\n        return TypeClone.Clone(schema.returns, options);\n    }\n    /** `[Extended]` Creates a Symbol type */ Symbol(options) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Symbol\",\n            type: \"null\",\n            typeOf: \"Symbol\"\n        });\n    }\n    /** `[Extended]` Creates a Undefined type */ Undefined(options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Undefined\",\n            type: \"null\",\n            typeOf: \"Undefined\"\n        });\n    }\n    /** `[Extended]` Creates a Uint8Array type */ Uint8Array(options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Uint8Array\",\n            type: \"object\",\n            instanceOf: \"Uint8Array\"\n        });\n    }\n    /** `[Extended]` Creates a Void type */ Void(options = {}) {\n        return this.Create({\n            ...options,\n            [exports.Kind]: \"Void\",\n            type: \"null\",\n            typeOf: \"Void\"\n        });\n    }\n}\nexports.ExtendedTypeBuilder = ExtendedTypeBuilder;\n/** JSON Schema TypeBuilder with Static Resolution for TypeScript */ exports.StandardType = new StandardTypeBuilder();\n/** JSON Schema TypeBuilder with Static Resolution for TypeScript */ exports.Type = new ExtendedTypeBuilder();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNpbmNsYWlyL3R5cGVib3gvdHlwZWJveC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyRUEwQjJFLEdBQzNFQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsWUFBWSxHQUFHQSxvQkFBb0IsR0FBR0EsMkJBQTJCLEdBQUdBLDJCQUEyQixHQUFHQSxtQkFBbUIsR0FBR0EsZ0NBQWdDLEdBQUdBLGdDQUFnQyxHQUFHQSw2QkFBNkIsR0FBR0EsNkJBQTZCLEdBQUdBLGtDQUFrQyxHQUFHQSwrQkFBK0IsR0FBR0EsOEJBQThCLEdBQUdBLHFCQUFxQixHQUFHQSx3QkFBd0IsR0FBR0EsbUJBQW1CLEdBQUdBLGlCQUFpQixHQUFHQSx1QkFBdUIsR0FBR0EsaUJBQWlCLEdBQUdBLG1CQUFtQixHQUFHQSx5QkFBeUIsR0FBR0Esd0JBQXdCLEdBQUdBLGlCQUFpQixHQUFHQSxpQ0FBaUMsR0FBR0Esc0JBQXNCLEdBQUdBLG9CQUFvQixHQUFHQSwwQkFBMEIsR0FBR0EsMEJBQTBCLEdBQUdBLDJCQUEyQixHQUFHQSxxQkFBcUIsR0FBR0EscUJBQXFCLEdBQUdBLHNCQUFzQixHQUFHQSxZQUFZLEdBQUdBLFlBQVksR0FBR0EsZ0JBQWdCLEdBQUcsS0FBSztBQUM3M0IsNkVBQTZFO0FBQzdFLFVBQVU7QUFDViw2RUFBNkU7QUFDN0VBLGdCQUFnQixHQUFHb0MsT0FBT0MsR0FBRyxDQUFDO0FBQzlCckMsWUFBWSxHQUFHb0MsT0FBT0MsR0FBRyxDQUFDO0FBQzFCckMsWUFBWSxHQUFHb0MsT0FBT0MsR0FBRyxDQUFDO0FBQzFCLDZFQUE2RTtBQUM3RSxXQUFXO0FBQ1gsNkVBQTZFO0FBQzdFckMsc0JBQXNCLEdBQUc7QUFDekJBLHFCQUFxQixHQUFHO0FBQ3hCQSxxQkFBcUIsR0FBRztBQUN4QkEsMkJBQTJCLEdBQUcsQ0FBQyxDQUFDLEVBQUVBLFFBQVFnQyxjQUFj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akMsT0FBTztZQUFFLENBQUN2UCxRQUFRaUMsSUFBSSxDQUFDLEVBQUU7WUFBVXNELE1BQU07WUFBUU0sUUFBUTtRQUFTO0lBQzlGO0lBQ0EsMENBQTBDLEdBQzFDZ0osVUFBVVUsVUFBVSxDQUFDLENBQUMsRUFBRTtRQUNwQixPQUFPLElBQUksQ0FBQ2lDLE1BQU0sQ0FBQztZQUFFLEdBQUdqQyxPQUFPO1lBQUUsQ0FBQ3ZQLFFBQVFpQyxJQUFJLENBQUMsRUFBRTtZQUFhc0QsTUFBTTtZQUFRTSxRQUFRO1FBQVk7SUFDcEc7SUFDQSwyQ0FBMkMsR0FDM0MrSSxXQUFXVyxVQUFVLENBQUMsQ0FBQyxFQUFFO1FBQ3JCLE9BQU8sSUFBSSxDQUFDaUMsTUFBTSxDQUFDO1lBQUUsR0FBR2pDLE9BQU87WUFBRSxDQUFDdlAsUUFBUWlDLElBQUksQ0FBQyxFQUFFO1lBQWNzRCxNQUFNO1lBQVVjLFlBQVk7UUFBYTtJQUM1RztJQUNBLHFDQUFxQyxHQUNyQzBJLEtBQUtRLFVBQVUsQ0FBQyxDQUFDLEVBQUU7UUFDZixPQUFPLElBQUksQ0FBQ2lDLE1BQU0sQ0FBQztZQUFFLEdBQUdqQyxPQUFPO1lBQUUsQ0FBQ3ZQLFFBQVFpQyxJQUFJLENBQUMsRUFBRTtZQUFRc0QsTUFBTTtZQUFRTSxRQUFRO1FBQU87SUFDMUY7QUFDSjtBQUNBN0YsMkJBQTJCLEdBQUdJO0FBQzlCLGtFQUFrRSxHQUNsRUosb0JBQW9CLEdBQUcsSUFBSUs7QUFDM0Isa0VBQWtFLEdBQ2xFTCxZQUFZLEdBQUcsSUFBSUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYXJkd2FyZS1kb2MtY2hhdGJvdC8uL25vZGVfbW9kdWxlcy9Ac2luY2xhaXIvdHlwZWJveC90eXBlYm94LmpzP2M0ZTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbkBzaW5jbGFpci90eXBlYm94XG5cblRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG5Db3B5cmlnaHQgKGMpIDIwMTctMjAyMyBIYXlkbiBQYXRlcnNvbiAoc2luY2xhaXIpIDxoYXlkbi5kZXZlbG9wZXJAZ21haWwuY29tPlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuXG5cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlR5cGUgPSBleHBvcnRzLlN0YW5kYXJkVHlwZSA9IGV4cG9ydHMuRXh0ZW5kZWRUeXBlQnVpbGRlciA9IGV4cG9ydHMuU3RhbmRhcmRUeXBlQnVpbGRlciA9IGV4cG9ydHMuVHlwZUJ1aWxkZXIgPSBleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbERzbFBhcnNlciA9IGV4cG9ydHMuVGVtcGxhdGVMaXRlcmFsR2VuZXJhdG9yID0gZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWxGaW5pdGUgPSBleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbFBhcnNlciA9IGV4cG9ydHMuVGVtcGxhdGVMaXRlcmFsUGFyc2VyRXJyb3IgPSBleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyID0gZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWxQYXR0ZXJuID0gZXhwb3J0cy5VbmlvblJlc29sdmVyID0gZXhwb3J0cy5LZXlBcnJheVJlc29sdmVyID0gZXhwb3J0cy5LZXlSZXNvbHZlciA9IGV4cG9ydHMuT2JqZWN0TWFwID0gZXhwb3J0cy5JbmRleGVkQWNjZXNzb3IgPSBleHBvcnRzLlR5cGVDbG9uZSA9IGV4cG9ydHMuVHlwZUV4dGVuZHMgPSBleHBvcnRzLlR5cGVFeHRlbmRzUmVzdWx0ID0gZXhwb3J0cy5FeHRlbmRzVW5kZWZpbmVkID0gZXhwb3J0cy5UeXBlR3VhcmQgPSBleHBvcnRzLlR5cGVHdWFyZFVua25vd25UeXBlRXJyb3IgPSBleHBvcnRzLkZvcm1hdFJlZ2lzdHJ5ID0gZXhwb3J0cy5UeXBlUmVnaXN0cnkgPSBleHBvcnRzLlBhdHRlcm5TdHJpbmdFeGFjdCA9IGV4cG9ydHMuUGF0dGVybk51bWJlckV4YWN0ID0gZXhwb3J0cy5QYXR0ZXJuQm9vbGVhbkV4YWN0ID0gZXhwb3J0cy5QYXR0ZXJuU3RyaW5nID0gZXhwb3J0cy5QYXR0ZXJuTnVtYmVyID0gZXhwb3J0cy5QYXR0ZXJuQm9vbGVhbiA9IGV4cG9ydHMuS2luZCA9IGV4cG9ydHMuSGludCA9IGV4cG9ydHMuTW9kaWZpZXIgPSB2b2lkIDA7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU3ltYm9sc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydHMuTW9kaWZpZXIgPSBTeW1ib2wuZm9yKCdUeXBlQm94Lk1vZGlmaWVyJyk7XG5leHBvcnRzLkhpbnQgPSBTeW1ib2wuZm9yKCdUeXBlQm94LkhpbnQnKTtcbmV4cG9ydHMuS2luZCA9IFN5bWJvbC5mb3IoJ1R5cGVCb3guS2luZCcpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFBhdHRlcm5zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZXhwb3J0cy5QYXR0ZXJuQm9vbGVhbiA9ICcodHJ1ZXxmYWxzZSknO1xuZXhwb3J0cy5QYXR0ZXJuTnVtYmVyID0gJygwfFsxLTldWzAtOV0qKSc7XG5leHBvcnRzLlBhdHRlcm5TdHJpbmcgPSAnKC4qKSc7XG5leHBvcnRzLlBhdHRlcm5Cb29sZWFuRXhhY3QgPSBgXiR7ZXhwb3J0cy5QYXR0ZXJuQm9vbGVhbn0kYDtcbmV4cG9ydHMuUGF0dGVybk51bWJlckV4YWN0ID0gYF4ke2V4cG9ydHMuUGF0dGVybk51bWJlcn0kYDtcbmV4cG9ydHMuUGF0dGVyblN0cmluZ0V4YWN0ID0gYF4ke2V4cG9ydHMuUGF0dGVyblN0cmluZ30kYDtcbi8qKiBBIHJlZ2lzdHJ5IGZvciB1c2VyIGRlZmluZWQgdHlwZXMgKi9cbnZhciBUeXBlUmVnaXN0cnk7XG4oZnVuY3Rpb24gKFR5cGVSZWdpc3RyeSkge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICAvKiogUmV0dXJucyB0aGUgZW50cmllcyBpbiB0aGlzIHJlZ2lzdHJ5ICovXG4gICAgZnVuY3Rpb24gRW50cmllcygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAobWFwKTtcbiAgICB9XG4gICAgVHlwZVJlZ2lzdHJ5LkVudHJpZXMgPSBFbnRyaWVzO1xuICAgIC8qKiBDbGVhcnMgYWxsIHVzZXIgZGVmaW5lZCB0eXBlcyAqL1xuICAgIGZ1bmN0aW9uIENsZWFyKCkge1xuICAgICAgICByZXR1cm4gbWFwLmNsZWFyKCk7XG4gICAgfVxuICAgIFR5cGVSZWdpc3RyeS5DbGVhciA9IENsZWFyO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhpcyByZWdpc3RyeSBjb250YWlucyB0aGlzIGtpbmQgKi9cbiAgICBmdW5jdGlvbiBIYXMoa2luZCkge1xuICAgICAgICByZXR1cm4gbWFwLmhhcyhraW5kKTtcbiAgICB9XG4gICAgVHlwZVJlZ2lzdHJ5LkhhcyA9IEhhcztcbiAgICAvKiogU2V0cyBhIHZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGEgdXNlciBkZWZpbmVkIHR5cGUgKi9cbiAgICBmdW5jdGlvbiBTZXQoa2luZCwgZnVuYykge1xuICAgICAgICBtYXAuc2V0KGtpbmQsIGZ1bmMpO1xuICAgIH1cbiAgICBUeXBlUmVnaXN0cnkuU2V0ID0gU2V0O1xuICAgIC8qKiBHZXRzIGEgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGEgdXNlciBkZWZpbmVkIHR5cGUgKi9cbiAgICBmdW5jdGlvbiBHZXQoa2luZCkge1xuICAgICAgICByZXR1cm4gbWFwLmdldChraW5kKTtcbiAgICB9XG4gICAgVHlwZVJlZ2lzdHJ5LkdldCA9IEdldDtcbn0pKFR5cGVSZWdpc3RyeSB8fCAoZXhwb3J0cy5UeXBlUmVnaXN0cnkgPSBUeXBlUmVnaXN0cnkgPSB7fSkpO1xuLyoqIEEgcmVnaXN0cnkgZm9yIHVzZXIgZGVmaW5lZCBzdHJpbmcgZm9ybWF0cyAqL1xudmFyIEZvcm1hdFJlZ2lzdHJ5O1xuKGZ1bmN0aW9uIChGb3JtYXRSZWdpc3RyeSkge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICAvKiogUmV0dXJucyB0aGUgZW50cmllcyBpbiB0aGlzIHJlZ2lzdHJ5ICovXG4gICAgZnVuY3Rpb24gRW50cmllcygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAobWFwKTtcbiAgICB9XG4gICAgRm9ybWF0UmVnaXN0cnkuRW50cmllcyA9IEVudHJpZXM7XG4gICAgLyoqIENsZWFycyBhbGwgdXNlciBkZWZpbmVkIHN0cmluZyBmb3JtYXRzICovXG4gICAgZnVuY3Rpb24gQ2xlYXIoKSB7XG4gICAgICAgIHJldHVybiBtYXAuY2xlYXIoKTtcbiAgICB9XG4gICAgRm9ybWF0UmVnaXN0cnkuQ2xlYXIgPSBDbGVhcjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSB1c2VyIGRlZmluZWQgc3RyaW5nIGZvcm1hdCBleGlzdHMgKi9cbiAgICBmdW5jdGlvbiBIYXMoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBtYXAuaGFzKGZvcm1hdCk7XG4gICAgfVxuICAgIEZvcm1hdFJlZ2lzdHJ5LkhhcyA9IEhhcztcbiAgICAvKiogU2V0cyBhIHZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGEgdXNlciBkZWZpbmVkIHN0cmluZyBmb3JtYXQgKi9cbiAgICBmdW5jdGlvbiBTZXQoZm9ybWF0LCBmdW5jKSB7XG4gICAgICAgIG1hcC5zZXQoZm9ybWF0LCBmdW5jKTtcbiAgICB9XG4gICAgRm9ybWF0UmVnaXN0cnkuU2V0ID0gU2V0O1xuICAgIC8qKiBHZXRzIGEgdmFsaWRhdGlvbiBmdW5jdGlvbiBmb3IgYSB1c2VyIGRlZmluZWQgc3RyaW5nIGZvcm1hdCAqL1xuICAgIGZ1bmN0aW9uIEdldChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIG1hcC5nZXQoZm9ybWF0KTtcbiAgICB9XG4gICAgRm9ybWF0UmVnaXN0cnkuR2V0ID0gR2V0O1xufSkoRm9ybWF0UmVnaXN0cnkgfHwgKGV4cG9ydHMuRm9ybWF0UmVnaXN0cnkgPSBGb3JtYXRSZWdpc3RyeSA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVHlwZUd1YXJkXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY2xhc3MgVHlwZUd1YXJkVW5rbm93blR5cGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEpIHtcbiAgICAgICAgc3VwZXIoJ1R5cGVHdWFyZDogVW5rbm93biB0eXBlJyk7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgIH1cbn1cbmV4cG9ydHMuVHlwZUd1YXJkVW5rbm93blR5cGVFcnJvciA9IFR5cGVHdWFyZFVua25vd25UeXBlRXJyb3I7XG4vKiogUHJvdmlkZXMgZnVuY3Rpb25zIHRvIHRlc3QgaWYgSmF2YVNjcmlwdCB2YWx1ZXMgYXJlIFR5cGVCb3ggdHlwZXMgKi9cbnZhciBUeXBlR3VhcmQ7XG4oZnVuY3Rpb24gKFR5cGVHdWFyZCkge1xuICAgIGZ1bmN0aW9uIElzT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNBcnJheSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNQYXR0ZXJuKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXcgUmVnRXhwKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBJc0NvbnRyb2xDaGFyYWN0ZXJGcmVlKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmICgoY29kZSA+PSA3ICYmIGNvZGUgPD0gMTMpIHx8IGNvZGUgPT09IDI3IHx8IGNvZGUgPT09IDEyNykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNBZGRpdGlvbmFsUHJvcGVydGllcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gSXNPcHRpb25hbEJvb2xlYW4odmFsdWUpIHx8IFRTY2hlbWEodmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0JpZ0ludCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JztcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGdsb2JhbFRoaXMuTnVtYmVyLmlzRmluaXRlKHZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPcHRpb25hbEJpZ0ludCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBJc0JpZ0ludCh2YWx1ZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09wdGlvbmFsTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIElzTnVtYmVyKHZhbHVlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT3B0aW9uYWxCb29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIElzQm9vbGVhbih2YWx1ZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09wdGlvbmFsU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIElzU3RyaW5nKHZhbHVlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT3B0aW9uYWxQYXR0ZXJuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIElzU3RyaW5nKHZhbHVlKSAmJiBJc0NvbnRyb2xDaGFyYWN0ZXJGcmVlKHZhbHVlKSAmJiBJc1BhdHRlcm4odmFsdWUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPcHRpb25hbEZvcm1hdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBJc1N0cmluZyh2YWx1ZSkgJiYgSXNDb250cm9sQ2hhcmFjdGVyRnJlZSh2YWx1ZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09wdGlvbmFsU2NoZW1hKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IFRTY2hlbWEodmFsdWUpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVEFueSAqL1xuICAgIGZ1bmN0aW9uIFRBbnkoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBUS2luZChzY2hlbWEpICYmIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnQW55JyAmJiBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVEFueSA9IFRBbnk7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRBcnJheSAqL1xuICAgIGZ1bmN0aW9uIFRBcnJheShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0FycmF5JyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGUgPT09ICdhcnJheScgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIFRTY2hlbWEoc2NoZW1hLml0ZW1zKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubWluSXRlbXMpICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5tYXhJdGVtcykgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxCb29sZWFuKHNjaGVtYS51bmlxdWVJdGVtcykpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVEFycmF5ID0gVEFycmF5O1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUQmlnSW50ICovXG4gICAgZnVuY3Rpb24gVEJpZ0ludChzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdCaWdJbnQnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ251bGwnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZU9mID09PSAnQmlnSW50JyAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbEJpZ0ludChzY2hlbWEubXVsdGlwbGVPZikgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxCaWdJbnQoc2NoZW1hLm1pbmltdW0pICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsQmlnSW50KHNjaGVtYS5tYXhpbXVtKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbEJpZ0ludChzY2hlbWEuZXhjbHVzaXZlTWluaW11bSkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxCaWdJbnQoc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0pKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRCaWdJbnQgPSBUQmlnSW50O1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUQm9vbGVhbiAqL1xuICAgIGZ1bmN0aW9uIFRCb29sZWFuKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0Jvb2xlYW4nICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ2Jvb2xlYW4nICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRCb29sZWFuID0gVEJvb2xlYW47XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRDb25zdHJ1Y3RvciAqL1xuICAgIGZ1bmN0aW9uIFRDb25zdHJ1Y3RvcihzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGlmICghKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnQ29uc3RydWN0b3InICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS5pbnN0YW5jZU9mID09PSAnQ29uc3RydWN0b3InICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc0FycmF5KHNjaGVtYS5wYXJhbWV0ZXJzKSAmJlxuICAgICAgICAgICAgVFNjaGVtYShzY2hlbWEucmV0dXJucykpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBwYXJhbWV0ZXIgb2Ygc2NoZW1hLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGlmICghVFNjaGVtYShwYXJhbWV0ZXIpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRDb25zdHJ1Y3RvciA9IFRDb25zdHJ1Y3RvcjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVERhdGUgKi9cbiAgICBmdW5jdGlvbiBURGF0ZShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0RhdGUnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS5pbnN0YW5jZU9mID09PSAnRGF0ZScgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm1pbmltdW1UaW1lc3RhbXApICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5tYXhpbXVtVGltZXN0YW1wKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEuZXhjbHVzaXZlTWluaW11bVRpbWVzdGFtcCkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW1UaW1lc3RhbXApKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlREYXRlID0gVERhdGU7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRGdW5jdGlvbiAqL1xuICAgIGZ1bmN0aW9uIFRGdW5jdGlvbihzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGlmICghKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnRnVuY3Rpb24nICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS5pbnN0YW5jZU9mID09PSAnRnVuY3Rpb24nICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc0FycmF5KHNjaGVtYS5wYXJhbWV0ZXJzKSAmJlxuICAgICAgICAgICAgVFNjaGVtYShzY2hlbWEucmV0dXJucykpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBwYXJhbWV0ZXIgb2Ygc2NoZW1hLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGlmICghVFNjaGVtYShwYXJhbWV0ZXIpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRGdW5jdGlvbiA9IFRGdW5jdGlvbjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVEludGVnZXIgKi9cbiAgICBmdW5jdGlvbiBUSW50ZWdlcihzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0ludGVnZXInICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ2ludGVnZXInICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5tdWx0aXBsZU9mKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubWluaW11bSkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm1heGltdW0pICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5leGNsdXNpdmVNaW5pbXVtKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEuZXhjbHVzaXZlTWF4aW11bSkpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVEludGVnZXIgPSBUSW50ZWdlcjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVEludGVyc2VjdCAqL1xuICAgIGZ1bmN0aW9uIFRJbnRlcnNlY3Qoc2NoZW1hKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBpZiAoIShUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0ludGVyc2VjdCcgJiZcbiAgICAgICAgICAgIElzQXJyYXkoc2NoZW1hLmFsbE9mKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEudHlwZSkgJiZcbiAgICAgICAgICAgIChJc09wdGlvbmFsQm9vbGVhbihzY2hlbWEudW5ldmFsdWF0ZWRQcm9wZXJ0aWVzKSB8fCBJc09wdGlvbmFsU2NoZW1hKHNjaGVtYS51bmV2YWx1YXRlZFByb3BlcnRpZXMpKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ3R5cGUnIGluIHNjaGVtYSAmJiBzY2hlbWEudHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGlubmVyIG9mIHNjaGVtYS5hbGxPZikge1xuICAgICAgICAgICAgaWYgKCFUU2NoZW1hKGlubmVyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5USW50ZXJzZWN0ID0gVEludGVyc2VjdDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVEtpbmQgKi9cbiAgICBmdW5jdGlvbiBUS2luZChzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIElzT2JqZWN0KHNjaGVtYSkgJiYgZXhwb3J0cy5LaW5kIGluIHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdzdHJpbmcnOyAvLyBUUyA0LjEuNTogYW55IHJlcXVpcmVkIGZvciBzeW1ib2wgaW5kZXhlclxuICAgIH1cbiAgICBUeXBlR3VhcmQuVEtpbmQgPSBUS2luZDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVExpdGVyYWw8c3RyaW5nPiAqL1xuICAgIGZ1bmN0aW9uIFRMaXRlcmFsU3RyaW5nKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gVEtpbmQoc2NoZW1hKSAmJiBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0xpdGVyYWwnICYmIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiYgdHlwZW9mIHNjaGVtYS5jb25zdCA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UTGl0ZXJhbFN0cmluZyA9IFRMaXRlcmFsU3RyaW5nO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUTGl0ZXJhbDxudW1iZXI+ICovXG4gICAgZnVuY3Rpb24gVExpdGVyYWxOdW1iZXIoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBUS2luZChzY2hlbWEpICYmIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnTGl0ZXJhbCcgJiYgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSAmJiB0eXBlb2Ygc2NoZW1hLmNvbnN0ID09PSAnbnVtYmVyJztcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRMaXRlcmFsTnVtYmVyID0gVExpdGVyYWxOdW1iZXI7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRMaXRlcmFsPGJvb2xlYW4+ICovXG4gICAgZnVuY3Rpb24gVExpdGVyYWxCb29sZWFuKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gVEtpbmQoc2NoZW1hKSAmJiBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0xpdGVyYWwnICYmIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiYgdHlwZW9mIHNjaGVtYS5jb25zdCA9PT0gJ2Jvb2xlYW4nO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVExpdGVyYWxCb29sZWFuID0gVExpdGVyYWxCb29sZWFuO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUTGl0ZXJhbCAqL1xuICAgIGZ1bmN0aW9uIFRMaXRlcmFsKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gVExpdGVyYWxTdHJpbmcoc2NoZW1hKSB8fCBUTGl0ZXJhbE51bWJlcihzY2hlbWEpIHx8IFRMaXRlcmFsQm9vbGVhbihzY2hlbWEpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVExpdGVyYWwgPSBUTGl0ZXJhbDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVE5ldmVyICovXG4gICAgZnVuY3Rpb24gVE5ldmVyKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gVEtpbmQoc2NoZW1hKSAmJiBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ05ldmVyJyAmJiBJc09iamVjdChzY2hlbWEubm90KSAmJiBnbG9iYWxUaGlzLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNjaGVtYS5ub3QpLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlROZXZlciA9IFROZXZlcjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVE5vdCAqL1xuICAgIGZ1bmN0aW9uIFROb3Qoc2NoZW1hKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnTm90JyAmJlxuICAgICAgICAgICAgVFNjaGVtYShzY2hlbWEubm90KSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UTm90ID0gVE5vdDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVE51bGwgKi9cbiAgICBmdW5jdGlvbiBUTnVsbChzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdOdWxsJyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGUgPT09ICdudWxsJyAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UTnVsbCA9IFROdWxsO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUTnVtYmVyICovXG4gICAgZnVuY3Rpb24gVE51bWJlcihzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ051bWJlcicgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubXVsdGlwbGVPZikgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm1pbmltdW0pICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5tYXhpbXVtKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEuZXhjbHVzaXZlTWluaW11bSkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0pKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlROdW1iZXIgPSBUTnVtYmVyO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUT2JqZWN0ICovXG4gICAgZnVuY3Rpb24gVE9iamVjdChzY2hlbWEpIHtcbiAgICAgICAgaWYgKCEoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdPYmplY3QnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIElzT2JqZWN0KHNjaGVtYS5wcm9wZXJ0aWVzKSAmJlxuICAgICAgICAgICAgSXNBZGRpdGlvbmFsUHJvcGVydGllcyhzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMpICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsTnVtYmVyKHNjaGVtYS5taW5Qcm9wZXJ0aWVzKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubWF4UHJvcGVydGllcykpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc2NoZW1hLnByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICBpZiAoIUlzQ29udHJvbENoYXJhY3RlckZyZWUoa2V5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIVRTY2hlbWEodmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRPYmplY3QgPSBUT2JqZWN0O1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUUHJvbWlzZSAqL1xuICAgIGZ1bmN0aW9uIFRQcm9taXNlKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1Byb21pc2UnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS5pbnN0YW5jZU9mID09PSAnUHJvbWlzZScgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIFRTY2hlbWEoc2NoZW1hLml0ZW0pKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRQcm9taXNlID0gVFByb21pc2U7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRSZWNvcmQgKi9cbiAgICBmdW5jdGlvbiBUUmVjb3JkKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgaWYgKCEoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdSZWNvcmQnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIElzQWRkaXRpb25hbFByb3BlcnRpZXMoc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKSAmJlxuICAgICAgICAgICAgSXNPYmplY3Qoc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKTtcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFJc1BhdHRlcm4oa2V5c1swXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIVRTY2hlbWEoc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzW2tleXNbMF1dKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFJlY29yZCA9IFRSZWNvcmQ7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRSZWYgKi9cbiAgICBmdW5jdGlvbiBUUmVmKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1JlZicgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIElzU3RyaW5nKHNjaGVtYS4kcmVmKSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UUmVmID0gVFJlZjtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVFN0cmluZyAqL1xuICAgIGZ1bmN0aW9uIFRTdHJpbmcoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiAoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdTdHJpbmcnICYmXG4gICAgICAgICAgICBzY2hlbWEudHlwZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm1pbkxlbmd0aCkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxOdW1iZXIoc2NoZW1hLm1heExlbmd0aCkgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxQYXR0ZXJuKHNjaGVtYS5wYXR0ZXJuKSAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbEZvcm1hdChzY2hlbWEuZm9ybWF0KSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UU3RyaW5nID0gVFN0cmluZztcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVFN5bWJvbCAqL1xuICAgIGZ1bmN0aW9uIFRTeW1ib2woc2NoZW1hKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnU3ltYm9sJyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGUgPT09ICdudWxsJyAmJlxuICAgICAgICAgICAgc2NoZW1hLnR5cGVPZiA9PT0gJ1N5bWJvbCcgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFN5bWJvbCA9IFRTeW1ib2w7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRUZW1wbGF0ZUxpdGVyYWwgKi9cbiAgICBmdW5jdGlvbiBUVGVtcGxhdGVMaXRlcmFsKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1RlbXBsYXRlTGl0ZXJhbCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgSXNTdHJpbmcoc2NoZW1hLnBhdHRlcm4pICYmXG4gICAgICAgICAgICBzY2hlbWEucGF0dGVyblswXSA9PT0gJ14nICYmXG4gICAgICAgICAgICBzY2hlbWEucGF0dGVybltzY2hlbWEucGF0dGVybi5sZW5ndGggLSAxXSA9PT0gJyQnKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRUZW1wbGF0ZUxpdGVyYWwgPSBUVGVtcGxhdGVMaXRlcmFsO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUVGhpcyAqL1xuICAgIGZ1bmN0aW9uIFRUaGlzKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1RoaXMnICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc1N0cmluZyhzY2hlbWEuJHJlZikpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFRoaXMgPSBUVGhpcztcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVFR1cGxlICovXG4gICAgZnVuY3Rpb24gVFR1cGxlKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgaWYgKCEoVEtpbmQoc2NoZW1hKSAmJlxuICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdUdXBsZScgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlID09PSAnYXJyYXknICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmXG4gICAgICAgICAgICBJc051bWJlcihzY2hlbWEubWluSXRlbXMpICYmXG4gICAgICAgICAgICBJc051bWJlcihzY2hlbWEubWF4SXRlbXMpICYmXG4gICAgICAgICAgICBzY2hlbWEubWluSXRlbXMgPT09IHNjaGVtYS5tYXhJdGVtcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLml0ZW1zID09PSB1bmRlZmluZWQgJiYgc2NoZW1hLmFkZGl0aW9uYWxJdGVtcyA9PT0gdW5kZWZpbmVkICYmIHNjaGVtYS5taW5JdGVtcyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFJc0FycmF5KHNjaGVtYS5pdGVtcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGlubmVyIG9mIHNjaGVtYS5pdGVtcykge1xuICAgICAgICAgICAgaWYgKCFUU2NoZW1hKGlubmVyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UVHVwbGUgPSBUVHVwbGU7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRVbmRlZmluZWQgKi9cbiAgICBmdW5jdGlvbiBUVW5kZWZpbmVkKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlID09PSAnbnVsbCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlT2YgPT09ICdVbmRlZmluZWQnICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRVbmRlZmluZWQgPSBUVW5kZWZpbmVkO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUVW5pb248TGl0ZXJhbDxzdHJpbmcgfCBudW1iZXI+W10+ICovXG4gICAgZnVuY3Rpb24gVFVuaW9uTGl0ZXJhbChzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIFRVbmlvbihzY2hlbWEpICYmIHNjaGVtYS5hbnlPZi5ldmVyeSgoc2NoZW1hKSA9PiBUTGl0ZXJhbFN0cmluZyhzY2hlbWEpIHx8IFRMaXRlcmFsTnVtYmVyKHNjaGVtYSkpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFVuaW9uTGl0ZXJhbCA9IFRVbmlvbkxpdGVyYWw7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRVbmlvbiAqL1xuICAgIGZ1bmN0aW9uIFRVbmlvbihzY2hlbWEpIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGlmICghKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnVW5pb24nICYmXG4gICAgICAgICAgICBJc0FycmF5KHNjaGVtYS5hbnlPZikgJiZcbiAgICAgICAgICAgIElzT3B0aW9uYWxTdHJpbmcoc2NoZW1hLiRpZCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBpbm5lciBvZiBzY2hlbWEuYW55T2YpIHtcbiAgICAgICAgICAgIGlmICghVFNjaGVtYShpbm5lcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFVuaW9uID0gVFVuaW9uO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUVWludDhBcnJheSAqL1xuICAgIGZ1bmN0aW9uIFRVaW50OEFycmF5KHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gVEtpbmQoc2NoZW1hKSAmJiBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1VpbnQ4QXJyYXknICYmIHNjaGVtYS50eXBlID09PSAnb2JqZWN0JyAmJiBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpICYmIHNjaGVtYS5pbnN0YW5jZU9mID09PSAnVWludDhBcnJheScgJiYgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubWluQnl0ZUxlbmd0aCkgJiYgSXNPcHRpb25hbE51bWJlcihzY2hlbWEubWF4Qnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UVWludDhBcnJheSA9IFRVaW50OEFycmF5O1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNjaGVtYSBpcyBUVW5rbm93biAqL1xuICAgIGZ1bmN0aW9uIFRVbmtub3duKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1Vua25vd24nICYmXG4gICAgICAgICAgICBJc09wdGlvbmFsU3RyaW5nKHNjaGVtYS4kaWQpKTtcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRVbmtub3duID0gVFVua25vd247XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIGEgcmF3IFRVbnNhZmUgKi9cbiAgICBmdW5jdGlvbiBUVW5zYWZlKHNjaGVtYSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChUS2luZChzY2hlbWEpICYmXG4gICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1Vuc2FmZScpO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFVuc2FmZSA9IFRVbnNhZmU7XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2NoZW1hIGlzIFRWb2lkICovXG4gICAgZnVuY3Rpb24gVFZvaWQoc2NoZW1hKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gKFRLaW5kKHNjaGVtYSkgJiZcbiAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnVm9pZCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlID09PSAnbnVsbCcgJiZcbiAgICAgICAgICAgIHNjaGVtYS50eXBlT2YgPT09ICdWb2lkJyAmJlxuICAgICAgICAgICAgSXNPcHRpb25hbFN0cmluZyhzY2hlbWEuJGlkKSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UVm9pZCA9IFRWb2lkO1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBzY2hlbWEgaGFzIHRoZSBSZWFkb25seU9wdGlvbmFsIG1vZGlmaWVyICovXG4gICAgZnVuY3Rpb24gVFJlYWRvbmx5T3B0aW9uYWwoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBJc09iamVjdChzY2hlbWEpICYmIHNjaGVtYVtleHBvcnRzLk1vZGlmaWVyXSA9PT0gJ1JlYWRvbmx5T3B0aW9uYWwnO1xuICAgIH1cbiAgICBUeXBlR3VhcmQuVFJlYWRvbmx5T3B0aW9uYWwgPSBUUmVhZG9ubHlPcHRpb25hbDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoaXMgc2NoZW1hIGhhcyB0aGUgUmVhZG9ubHkgbW9kaWZpZXIgKi9cbiAgICBmdW5jdGlvbiBUUmVhZG9ubHkoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBJc09iamVjdChzY2hlbWEpICYmIHNjaGVtYVtleHBvcnRzLk1vZGlmaWVyXSA9PT0gJ1JlYWRvbmx5JztcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRSZWFkb25seSA9IFRSZWFkb25seTtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoaXMgc2NoZW1hIGhhcyB0aGUgT3B0aW9uYWwgbW9kaWZpZXIgKi9cbiAgICBmdW5jdGlvbiBUT3B0aW9uYWwoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBJc09iamVjdChzY2hlbWEpICYmIHNjaGVtYVtleHBvcnRzLk1vZGlmaWVyXSA9PT0gJ09wdGlvbmFsJztcbiAgICB9XG4gICAgVHlwZUd1YXJkLlRPcHRpb25hbCA9IFRPcHRpb25hbDtcbiAgICAvKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzY2hlbWEgaXMgVFNjaGVtYSAqL1xuICAgIGZ1bmN0aW9uIFRTY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHNjaGVtYSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIChUQW55KHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUQXJyYXkoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRCb29sZWFuKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUQmlnSW50KHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUQ29uc3RydWN0b3Ioc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFREYXRlKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBURnVuY3Rpb24oc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRJbnRlZ2VyKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUSW50ZXJzZWN0KHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUTGl0ZXJhbChzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVE5ldmVyKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUTm90KHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUTnVsbChzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVE51bWJlcihzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVE9iamVjdChzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVFByb21pc2Uoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRSZWNvcmQoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRSZWYoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRTdHJpbmcoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRTeW1ib2woc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRUZW1wbGF0ZUxpdGVyYWwoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRUaGlzKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUVHVwbGUoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRVbmRlZmluZWQoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRVbmlvbihzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgVFVpbnQ4QXJyYXkoc2NoZW1hKSB8fFxuICAgICAgICAgICAgICAgIFRVbmtub3duKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUVW5zYWZlKHNjaGVtYSkgfHxcbiAgICAgICAgICAgICAgICBUVm9pZChzY2hlbWEpIHx8XG4gICAgICAgICAgICAgICAgKFRLaW5kKHNjaGVtYSkgJiYgVHlwZVJlZ2lzdHJ5LkhhcyhzY2hlbWFbZXhwb3J0cy5LaW5kXSkpKSk7XG4gICAgfVxuICAgIFR5cGVHdWFyZC5UU2NoZW1hID0gVFNjaGVtYTtcbn0pKFR5cGVHdWFyZCB8fCAoZXhwb3J0cy5UeXBlR3VhcmQgPSBUeXBlR3VhcmQgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4dGVuZHNVbmRlZmluZWRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKiogRmFzdCB1bmRlZmluZWQgY2hlY2sgdXNlZCBmb3IgcHJvcGVydGllcyBvZiB0eXBlIHVuZGVmaW5lZCAqL1xudmFyIEV4dGVuZHNVbmRlZmluZWQ7XG4oZnVuY3Rpb24gKEV4dGVuZHNVbmRlZmluZWQpIHtcbiAgICBmdW5jdGlvbiBDaGVjayhzY2hlbWEpIHtcbiAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnVW5kZWZpbmVkJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdOb3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gIUNoZWNrKHNjaGVtYS5ub3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ0ludGVyc2VjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGludGVyc2VjdCA9IHNjaGVtYTtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcnNlY3QuYWxsT2YuZXZlcnkoKHNjaGVtYSkgPT4gQ2hlY2soc2NoZW1hKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnVW5pb24nKSB7XG4gICAgICAgICAgICBjb25zdCB1bmlvbiA9IHNjaGVtYTtcbiAgICAgICAgICAgIHJldHVybiB1bmlvbi5hbnlPZi5zb21lKChzY2hlbWEpID0+IENoZWNrKHNjaGVtYSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgRXh0ZW5kc1VuZGVmaW5lZC5DaGVjayA9IENoZWNrO1xufSkoRXh0ZW5kc1VuZGVmaW5lZCB8fCAoZXhwb3J0cy5FeHRlbmRzVW5kZWZpbmVkID0gRXh0ZW5kc1VuZGVmaW5lZCA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVHlwZUV4dGVuZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgVHlwZUV4dGVuZHNSZXN1bHQ7XG4oZnVuY3Rpb24gKFR5cGVFeHRlbmRzUmVzdWx0KSB7XG4gICAgVHlwZUV4dGVuZHNSZXN1bHRbVHlwZUV4dGVuZHNSZXN1bHRbXCJVbmlvblwiXSA9IDBdID0gXCJVbmlvblwiO1xuICAgIFR5cGVFeHRlbmRzUmVzdWx0W1R5cGVFeHRlbmRzUmVzdWx0W1wiVHJ1ZVwiXSA9IDFdID0gXCJUcnVlXCI7XG4gICAgVHlwZUV4dGVuZHNSZXN1bHRbVHlwZUV4dGVuZHNSZXN1bHRbXCJGYWxzZVwiXSA9IDJdID0gXCJGYWxzZVwiO1xufSkoVHlwZUV4dGVuZHNSZXN1bHQgfHwgKGV4cG9ydHMuVHlwZUV4dGVuZHNSZXN1bHQgPSBUeXBlRXh0ZW5kc1Jlc3VsdCA9IHt9KSk7XG52YXIgVHlwZUV4dGVuZHM7XG4oZnVuY3Rpb24gKFR5cGVFeHRlbmRzKSB7XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBJbnRvQm9vbGVhblJlc3VsdFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gSW50b0Jvb2xlYW5SZXN1bHQocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlID8gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2UgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEFueVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gQW55UmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEFueShsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpICYmIHJpZ2h0LmFueU9mLnNvbWUoKHNjaGVtYSkgPT4gVHlwZUd1YXJkLlRBbnkoc2NoZW1hKSB8fCBUeXBlR3VhcmQuVFVua25vd24oc2NoZW1hKSkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlVuaW9uO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5VbmlvbjtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBBcnJheVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gQXJyYXlSaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVW5pb247XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5ldmVyKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQXJyYXkobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkgJiYgSXNPYmplY3RBcnJheUxpa2UocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmICghVHlwZUd1YXJkLlRBcnJheShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIHJldHVybiBJbnRvQm9vbGVhblJlc3VsdChWaXNpdChsZWZ0Lml0ZW1zLCByaWdodC5pdGVtcykpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEJpZ0ludFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gQmlnSW50KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5ldmVyKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBOZXZlclJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFJlY29yZFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIFR5cGVHdWFyZC5UQmlnSW50KHJpZ2h0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBCb29sZWFuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBCb29sZWFuUmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTGl0ZXJhbChsZWZ0KSAmJiB0eXBlb2YgbGVmdC5jb25zdCA9PT0gJ2Jvb2xlYW4nKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVEJvb2xlYW4obGVmdCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEJvb2xlYW4obGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTmV2ZXIocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE5ldmVyUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFJlY29yZChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gUmVjb3JkUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRCb29sZWFuKHJpZ2h0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBDb25zdHJ1Y3RvclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gQ29uc3RydWN0b3IobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoIVR5cGVHdWFyZC5UQ29uc3RydWN0b3IocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBpZiAobGVmdC5wYXJhbWV0ZXJzLmxlbmd0aCA+IHJpZ2h0LnBhcmFtZXRlcnMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBpZiAoIWxlZnQucGFyYW1ldGVycy5ldmVyeSgoc2NoZW1hLCBpbmRleCkgPT4gSW50b0Jvb2xlYW5SZXN1bHQoVmlzaXQocmlnaHQucGFyYW1ldGVyc1tpbmRleF0sIHNjaGVtYSkpID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBJbnRvQm9vbGVhblJlc3VsdChWaXNpdChsZWZ0LnJldHVybnMsIHJpZ2h0LnJldHVybnMpKTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBEYXRlXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBEYXRlKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBSZWNvcmRSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVERhdGUocmlnaHQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEZ1bmN0aW9uXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBGdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmICghVHlwZUd1YXJkLlRGdW5jdGlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIGlmIChsZWZ0LnBhcmFtZXRlcnMubGVuZ3RoID4gcmlnaHQucGFyYW1ldGVycy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIGlmICghbGVmdC5wYXJhbWV0ZXJzLmV2ZXJ5KChzY2hlbWEsIGluZGV4KSA9PiBJbnRvQm9vbGVhblJlc3VsdChWaXNpdChyaWdodC5wYXJhbWV0ZXJzW2luZGV4XSwgc2NoZW1hKSkgPT09IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEludG9Cb29sZWFuUmVzdWx0KFZpc2l0KGxlZnQucmV0dXJucywgcmlnaHQucmV0dXJucykpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEludGVnZXJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIEludGVnZXJSaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRMaXRlcmFsKGxlZnQpICYmIHR5cGVvZiBsZWZ0LmNvbnN0ID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlROdW1iZXIobGVmdCkgfHwgVHlwZUd1YXJkLlRJbnRlZ2VyKGxlZnQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJbnRlZ2VyKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5ldmVyKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBOZXZlclJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFJlY29yZFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIFR5cGVHdWFyZC5USW50ZWdlcihyaWdodCkgfHwgVHlwZUd1YXJkLlROdW1iZXIocmlnaHQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEludGVyc2VjdFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHJpZ2h0LmFsbE9mLmV2ZXJ5KChzY2hlbWEpID0+IFZpc2l0KGxlZnQsIHNjaGVtYSkgPT09IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJbnRlcnNlY3QobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGxlZnQuYWxsT2Yuc29tZSgoc2NoZW1hKSA9PiBWaXNpdChzY2hlbWEsIHJpZ2h0KSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gTGl0ZXJhbFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gSXNMaXRlcmFsU3RyaW5nKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHNjaGVtYS5jb25zdCA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzTGl0ZXJhbE51bWJlcihzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBzY2hlbWEuY29uc3QgPT09ICdudW1iZXInO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0xpdGVyYWxCb29sZWFuKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHNjaGVtYS5jb25zdCA9PT0gJ2Jvb2xlYW4nO1xuICAgIH1cbiAgICBmdW5jdGlvbiBMaXRlcmFsKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5ldmVyKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBOZXZlclJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFJlY29yZFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UU3RyaW5nKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmdSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE51bWJlcihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlZ2VyKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlZ2VyUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRCb29sZWFuKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRMaXRlcmFsKHJpZ2h0KSAmJiByaWdodC5jb25zdCA9PT0gbGVmdC5jb25zdCA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBOZXZlclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gTmV2ZXJSaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE5ldmVyKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIE5vdFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gVW53cmFwTm90KHNjaGVtYSkge1xuICAgICAgICBsZXQgW2N1cnJlbnQsIGRlcHRoXSA9IFtzY2hlbWEsIDBdO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKCFUeXBlR3VhcmQuVE5vdChjdXJyZW50KSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5vdDtcbiAgICAgICAgICAgIGRlcHRoICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlcHRoICUgMiA9PT0gMCA/IGN1cnJlbnQgOiBleHBvcnRzLlR5cGUuVW5rbm93bigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBOb3QobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgLy8gVHlwZVNjcmlwdCBoYXMgbm8gY29uY2VwdCBvZiBuZWdhdGVkIHR5cGVzLCBhbmQgYXR0ZW1wdHMgdG8gY29ycmVjdGx5IGNoZWNrIHRoZSBuZWdhdGVkXG4gICAgICAgIC8vIHR5cGUgYXQgcnVudGltZSB3b3VsZCBwdXQgVHlwZUJveCBhdCBvZGRzIHdpdGggVHlwZVNjcmlwdHMgYWJpbGl0eSB0byBzdGF0aWNhbGx5IGluZmVyXG4gICAgICAgIC8vIHRoZSB0eXBlLiBJbnN0ZWFkIHdlIHVud3JhcCB0byBlaXRoZXIgdW5rbm93biBvciBUIGFuZCBjb250aW51ZSBldmFsdWF0aW5nLlxuICAgICAgICBpZiAoVHlwZUd1YXJkLlROb3QobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVmlzaXQoVW53cmFwTm90KGxlZnQpLCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5vdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVmlzaXQobGVmdCwgVW53cmFwTm90KHJpZ2h0KSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHlwZUV4dGVuZHM6IEludmFsaWQgZmFsbHRocm91Z2ggZm9yIE5vdGApO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIE51bGxcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIE51bGwobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTmV2ZXIocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE5ldmVyUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFJlY29yZChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gUmVjb3JkUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlROdWxsKHJpZ2h0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBOdW1iZXJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIE51bWJlclJpZ2h0KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVExpdGVyYWwobGVmdCkgJiYgSXNMaXRlcmFsTnVtYmVyKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVE51bWJlcihsZWZ0KSB8fCBUeXBlR3VhcmQuVEludGVnZXIobGVmdCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE51bWJlcihsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROZXZlcihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gTmV2ZXJSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBSZWNvcmRSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVEludGVnZXIocmlnaHQpIHx8IFR5cGVHdWFyZC5UTnVtYmVyKHJpZ2h0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBPYmplY3RcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0UHJvcGVydHlDb3VudChzY2hlbWEsIGNvdW50KSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLk9iamVjdC5rZXlzKHNjaGVtYS5wcm9wZXJ0aWVzKS5sZW5ndGggPT09IGNvdW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09iamVjdFN0cmluZ0xpa2Uoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBJc09iamVjdEFycmF5TGlrZShzY2hlbWEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc09iamVjdFN5bWJvbExpa2Uoc2NoZW1hKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMCkgfHwgKElzT2JqZWN0UHJvcGVydHlDb3VudChzY2hlbWEsIDEpICYmICdkZXNjcmlwdGlvbicgaW4gc2NoZW1hLnByb3BlcnRpZXMgJiYgVHlwZUd1YXJkLlRVbmlvbihzY2hlbWEucHJvcGVydGllcy5kZXNjcmlwdGlvbikgJiYgc2NoZW1hLnByb3BlcnRpZXMuZGVzY3JpcHRpb24uYW55T2YubGVuZ3RoID09PSAyICYmICgoVHlwZUd1YXJkLlRTdHJpbmcoc2NoZW1hLnByb3BlcnRpZXMuZGVzY3JpcHRpb24uYW55T2ZbMF0pICYmXG4gICAgICAgICAgICBUeXBlR3VhcmQuVFVuZGVmaW5lZChzY2hlbWEucHJvcGVydGllcy5kZXNjcmlwdGlvbi5hbnlPZlsxXSkpIHx8IChUeXBlR3VhcmQuVFN0cmluZyhzY2hlbWEucHJvcGVydGllcy5kZXNjcmlwdGlvbi5hbnlPZlsxXSkgJiZcbiAgICAgICAgICAgIFR5cGVHdWFyZC5UVW5kZWZpbmVkKHNjaGVtYS5wcm9wZXJ0aWVzLmRlc2NyaXB0aW9uLmFueU9mWzBdKSkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPYmplY3ROdW1iZXJMaWtlKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0Qm9vbGVhbkxpa2Uoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBJc09iamVjdFByb3BlcnR5Q291bnQoc2NoZW1hLCAwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPYmplY3RCaWdJbnRMaWtlKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0RGF0ZUxpa2Uoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBJc09iamVjdFByb3BlcnR5Q291bnQoc2NoZW1hLCAwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNPYmplY3RVaW50OEFycmF5TGlrZShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIElzT2JqZWN0QXJyYXlMaWtlKHNjaGVtYSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0RnVuY3Rpb25MaWtlKHNjaGVtYSkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBleHBvcnRzLlR5cGUuTnVtYmVyKCk7XG4gICAgICAgIHJldHVybiBJc09iamVjdFByb3BlcnR5Q291bnQoc2NoZW1hLCAwKSB8fCAoSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMSkgJiYgJ2xlbmd0aCcgaW4gc2NoZW1hLnByb3BlcnRpZXMgJiYgSW50b0Jvb2xlYW5SZXN1bHQoVmlzaXQoc2NoZW1hLnByb3BlcnRpZXNbJ2xlbmd0aCddLCBsZW5ndGgpKSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0Q29uc3RydWN0b3JMaWtlKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0QXJyYXlMaWtlKHNjaGVtYSkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBleHBvcnRzLlR5cGUuTnVtYmVyKCk7XG4gICAgICAgIHJldHVybiBJc09iamVjdFByb3BlcnR5Q291bnQoc2NoZW1hLCAwKSB8fCAoSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMSkgJiYgJ2xlbmd0aCcgaW4gc2NoZW1hLnByb3BlcnRpZXMgJiYgSW50b0Jvb2xlYW5SZXN1bHQoVmlzaXQoc2NoZW1hLnByb3BlcnRpZXNbJ2xlbmd0aCddLCBsZW5ndGgpKSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT2JqZWN0UHJvbWlzZUxpa2Uoc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IHRoZW4gPSBleHBvcnRzLlR5cGUuRnVuY3Rpb24oW2V4cG9ydHMuVHlwZS5BbnkoKV0sIGV4cG9ydHMuVHlwZS5BbnkoKSk7XG4gICAgICAgIHJldHVybiBJc09iamVjdFByb3BlcnR5Q291bnQoc2NoZW1hLCAwKSB8fCAoSXNPYmplY3RQcm9wZXJ0eUNvdW50KHNjaGVtYSwgMSkgJiYgJ3RoZW4nIGluIHNjaGVtYS5wcm9wZXJ0aWVzICYmIEludG9Cb29sZWFuUmVzdWx0KFZpc2l0KHNjaGVtYS5wcm9wZXJ0aWVzWyd0aGVuJ10sIHRoZW4pKSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUHJvcGVydHlcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIFByb3BlcnR5KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChWaXNpdChsZWZ0LCByaWdodCkgPT09IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPcHRpb25hbChsZWZ0KSAmJiAhVHlwZUd1YXJkLlRPcHRpb25hbChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBPYmplY3RSaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVW5pb247XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE5ldmVyKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVExpdGVyYWwobGVmdCkgJiYgSXNMaXRlcmFsU3RyaW5nKGxlZnQpICYmIElzT2JqZWN0U3RyaW5nTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTGl0ZXJhbChsZWZ0KSAmJiBJc0xpdGVyYWxOdW1iZXIobGVmdCkgJiYgSXNPYmplY3ROdW1iZXJMaWtlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRMaXRlcmFsKGxlZnQpICYmIElzTGl0ZXJhbEJvb2xlYW4obGVmdCkgJiYgSXNPYmplY3RCb29sZWFuTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UU3ltYm9sKGxlZnQpICYmIElzT2JqZWN0U3ltYm9sTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQmlnSW50KGxlZnQpICYmIElzT2JqZWN0QmlnSW50TGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UU3RyaW5nKGxlZnQpICYmIElzT2JqZWN0U3RyaW5nTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UU3ltYm9sKGxlZnQpICYmIElzT2JqZWN0U3ltYm9sTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTnVtYmVyKGxlZnQpICYmIElzT2JqZWN0TnVtYmVyTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZWdlcihsZWZ0KSAmJiBJc09iamVjdE51bWJlckxpa2UocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEJvb2xlYW4obGVmdCkgJiYgSXNPYmplY3RCb29sZWFuTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVWludDhBcnJheShsZWZ0KSAmJiBJc09iamVjdFVpbnQ4QXJyYXlMaWtlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlREYXRlKGxlZnQpICYmIElzT2JqZWN0RGF0ZUxpa2UocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVENvbnN0cnVjdG9yKGxlZnQpICYmIElzT2JqZWN0Q29uc3RydWN0b3JMaWtlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRGdW5jdGlvbihsZWZ0KSAmJiBJc09iamVjdEZ1bmN0aW9uTGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKGxlZnQpICYmIFR5cGVHdWFyZC5UU3RyaW5nKFJlY29yZEtleShsZWZ0KSkpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gZXhwcmVzc2luZyBhIFJlY29yZCB3aXRoIGxpdGVyYWwga2V5IHZhbHVlcywgdGhlIFJlY29yZCBpcyBjb252ZXJ0ZWQgaW50byBhIE9iamVjdCB3aXRoXG4gICAgICAgICAgICAvLyB0aGUgSGludCBhc3NpZ25lZCBhcyBgUmVjb3JkYC4gVGhpcyBpcyB1c2VkIHRvIGludmVydCB0aGUgZXh0ZW5kcyBsb2dpYy5cbiAgICAgICAgICAgIHJldHVybiByaWdodFtleHBvcnRzLkhpbnRdID09PSAnUmVjb3JkJyA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQobGVmdCkgJiYgVHlwZUd1YXJkLlROdW1iZXIoUmVjb3JkS2V5KGxlZnQpKSkge1xuICAgICAgICAgICAgcmV0dXJuIElzT2JqZWN0UHJvcGVydHlDb3VudChyaWdodCwgMCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBPYmplY3QobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5rbm93bihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5rbm93blJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFJlY29yZChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gUmVjb3JkUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoIVR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZ2xvYmFsVGhpcy5PYmplY3Qua2V5cyhyaWdodC5wcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgaWYgKCEoa2V5IGluIGxlZnQucHJvcGVydGllcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICAgICAgaWYgKFByb3BlcnR5KGxlZnQucHJvcGVydGllc1trZXldLCByaWdodC5wcm9wZXJ0aWVzW2tleV0pID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBQcm9taXNlXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBQcm9taXNlKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZXJzZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpICYmIElzT2JqZWN0UHJvbWlzZUxpa2UocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmICghVHlwZUd1YXJkLlRQcm9taXNlKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgcmV0dXJuIEludG9Cb29sZWFuUmVzdWx0KFZpc2l0KGxlZnQuaXRlbSwgcmlnaHQuaXRlbSkpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFJlY29yZFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gUmVjb3JkS2V5KHNjaGVtYSkge1xuICAgICAgICBpZiAoZXhwb3J0cy5QYXR0ZXJuTnVtYmVyRXhhY3QgaW4gc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuVHlwZS5OdW1iZXIoKTtcbiAgICAgICAgaWYgKGV4cG9ydHMuUGF0dGVyblN0cmluZ0V4YWN0IGluIHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcylcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuU3RyaW5nKCk7XG4gICAgICAgIHRocm93IEVycm9yKCdUeXBlRXh0ZW5kczogQ2Fubm90IGdldCByZWNvcmQga2V5Jyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlY29yZFZhbHVlKHNjaGVtYSkge1xuICAgICAgICBpZiAoZXhwb3J0cy5QYXR0ZXJuTnVtYmVyRXhhY3QgaW4gc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKVxuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllc1tleHBvcnRzLlBhdHRlcm5OdW1iZXJFeGFjdF07XG4gICAgICAgIGlmIChleHBvcnRzLlBhdHRlcm5TdHJpbmdFeGFjdCBpbiBzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpXG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzW2V4cG9ydHMuUGF0dGVyblN0cmluZ0V4YWN0XTtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1R5cGVFeHRlbmRzOiBDYW5ub3QgZ2V0IHJlY29yZCB2YWx1ZScpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWNvcmRSaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICBjb25zdCBLZXkgPSBSZWNvcmRLZXkocmlnaHQpO1xuICAgICAgICBjb25zdCBWYWx1ZSA9IFJlY29yZFZhbHVlKHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTGl0ZXJhbChsZWZ0KSAmJiBJc0xpdGVyYWxTdHJpbmcobGVmdCkgJiYgVHlwZUd1YXJkLlROdW1iZXIoS2V5KSAmJiBJbnRvQm9vbGVhblJlc3VsdChWaXNpdChsZWZ0LCBWYWx1ZSkpID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVpbnQ4QXJyYXkobGVmdCkgJiYgVHlwZUd1YXJkLlROdW1iZXIoS2V5KSlcbiAgICAgICAgICAgIHJldHVybiBWaXNpdChsZWZ0LCBWYWx1ZSk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFN0cmluZyhsZWZ0KSAmJiBUeXBlR3VhcmQuVE51bWJlcihLZXkpKVxuICAgICAgICAgICAgcmV0dXJuIFZpc2l0KGxlZnQsIFZhbHVlKTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQXJyYXkobGVmdCkgJiYgVHlwZUd1YXJkLlROdW1iZXIoS2V5KSlcbiAgICAgICAgICAgIHJldHVybiBWaXNpdChsZWZ0LCBWYWx1ZSk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChsZWZ0KSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZ2xvYmFsVGhpcy5PYmplY3Qua2V5cyhsZWZ0LnByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKFByb3BlcnR5KFZhbHVlLCBsZWZ0LnByb3BlcnRpZXNba2V5XSkgPT09IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlY29yZChsZWZ0LCByaWdodCkge1xuICAgICAgICBjb25zdCBWYWx1ZSA9IFJlY29yZFZhbHVlKGxlZnQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmICghVHlwZUd1YXJkLlRSZWNvcmQocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICByZXR1cm4gVmlzaXQoVmFsdWUsIFJlY29yZFZhbHVlKHJpZ2h0KSk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gU3RyaW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBTdHJpbmdSaWdodChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRMaXRlcmFsKGxlZnQpICYmIHR5cGVvZiBsZWZ0LmNvbnN0ID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRTdHJpbmcobGVmdCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFN0cmluZyhsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROZXZlcihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gTmV2ZXJSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBSZWNvcmRSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVFN0cmluZyhyaWdodCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gU3ltYm9sXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBTeW1ib2wobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTmV2ZXIocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE5ldmVyUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFJlY29yZChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gUmVjb3JkUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRTeW1ib2wocmlnaHQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFRlbXBsYXRlTGl0ZXJhbFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gVGVtcGxhdGVMaXRlcmFsKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIC8vIFRlbXBsYXRlTGl0ZXJhbCB0eXBlcyBhcmUgcmVzb2x2ZWQgdG8gZWl0aGVyIHVuaW9ucyBmb3IgZmluaXRlIGV4cHJlc3Npb25zIG9yIHN0cmluZ1xuICAgICAgICAvLyBmb3IgaW5maW5pdGUgZXhwcmVzc2lvbnMuIEhlcmUgd2UgY2FsbCB0byBUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlciB0byByZXNvbHZlIGZvclxuICAgICAgICAvLyBlaXRoZXIgdHlwZSBhbmQgY29udGludWUgZXZhbHVhdGluZy5cbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVGVtcGxhdGVMaXRlcmFsKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFZpc2l0KFRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyLlJlc29sdmUobGVmdCksIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVGVtcGxhdGVMaXRlcmFsKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBWaXNpdChsZWZ0LCBUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlci5SZXNvbHZlKHJpZ2h0KSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHlwZUV4dGVuZHM6IEludmFsaWQgZmFsbHRocm91Z2ggZm9yIFRlbXBsYXRlTGl0ZXJhbGApO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFR1cGxlXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBUdXBsZVJpZ2h0KGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24obGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5VbmlvbjtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTmV2ZXIobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0FycmF5T2ZUdXBsZShsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRBcnJheShyaWdodCkgJiYgbGVmdC5pdGVtcyAhPT0gdW5kZWZpbmVkICYmIGxlZnQuaXRlbXMuZXZlcnkoKHNjaGVtYSkgPT4gVmlzaXQoc2NoZW1hLCByaWdodC5pdGVtcykgPT09IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBUdXBsZShsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSAmJiBJc09iamVjdEFycmF5TGlrZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQXJyYXkocmlnaHQpICYmIElzQXJyYXlPZlR1cGxlKGxlZnQsIHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlO1xuICAgICAgICBpZiAoIVR5cGVHdWFyZC5UVHVwbGUocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBpZiAoKGxlZnQuaXRlbXMgPT09IHVuZGVmaW5lZCAmJiByaWdodC5pdGVtcyAhPT0gdW5kZWZpbmVkKSB8fCAobGVmdC5pdGVtcyAhPT0gdW5kZWZpbmVkICYmIHJpZ2h0Lml0ZW1zID09PSB1bmRlZmluZWQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgICAgICBpZiAobGVmdC5pdGVtcyA9PT0gdW5kZWZpbmVkICYmIHJpZ2h0Lml0ZW1zID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTtcbiAgICAgICAgcmV0dXJuIGxlZnQuaXRlbXMuZXZlcnkoKHNjaGVtYSwgaW5kZXgpID0+IFZpc2l0KHNjaGVtYSwgcmlnaHQuaXRlbXNbaW5kZXhdKSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVWludDhBcnJheVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZnVuY3Rpb24gVWludDhBcnJheShsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFJlY29yZChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gUmVjb3JkUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRVaW50OEFycmF5KHJpZ2h0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBVbmRlZmluZWRcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIFVuZGVmaW5lZChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROZXZlcihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gTmV2ZXJSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVua25vd24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd25SaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEFueShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQW55UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBSZWNvcmRSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFZvaWQocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFZvaWRSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVFVuZGVmaW5lZChyaWdodCkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVW5pb25cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZ1bmN0aW9uIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHJpZ2h0LmFueU9mLnNvbWUoKHNjaGVtYSkgPT4gVmlzaXQobGVmdCwgc2NoZW1hKSA9PT0gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSkgPyBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlIDogVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVuaW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBsZWZ0LmFueU9mLmV2ZXJ5KChzY2hlbWEpID0+IFZpc2l0KHNjaGVtYSwgcmlnaHQpID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5UcnVlKSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBVbmtub3duXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVua25vd24obGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZXJzZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmlvblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQW55KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBBbnlSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFN0cmluZyhyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROdW1iZXIocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIE51bWJlclJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5USW50ZWdlcihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZWdlclJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQm9vbGVhbihyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhblJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQXJyYXkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFycmF5UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRUdXBsZShyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVHVwbGVSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0UmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICByZXR1cm4gVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBWb2lkXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmdW5jdGlvbiBWb2lkUmlnaHQobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5kZWZpbmVkKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVFeHRlbmRzUmVzdWx0LlRydWU7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVFVuZGVmaW5lZChsZWZ0KSA/IFR5cGVFeHRlbmRzUmVzdWx0LlRydWUgOiBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVm9pZChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRJbnRlcnNlY3QocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdFJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24ocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBVbmtub3duUmlnaHQobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIEFueVJpZ2h0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UT2JqZWN0KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RSaWdodChsZWZ0LCByaWdodCk7XG4gICAgICAgIHJldHVybiBUeXBlR3VhcmQuVFZvaWQocmlnaHQpID8gVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZSA6IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBWaXNpdChsZWZ0LCByaWdodCkge1xuICAgICAgICAvLyBSZXNvbHZhYmxlIFR5cGVzXG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFRlbXBsYXRlTGl0ZXJhbChsZWZ0KSB8fCBUeXBlR3VhcmQuVFRlbXBsYXRlTGl0ZXJhbChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gVGVtcGxhdGVMaXRlcmFsKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UTm90KGxlZnQpIHx8IFR5cGVHdWFyZC5UTm90KHJpZ2h0KSlcbiAgICAgICAgICAgIHJldHVybiBOb3QobGVmdCwgcmlnaHQpO1xuICAgICAgICAvLyBTdGFuZGFyZCBUeXBlc1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRBbnkobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gQW55KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQXJyYXkobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gQXJyYXkobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRCaWdJbnQobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQm9vbGVhbihsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQ29uc3RydWN0b3IobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3IobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlREYXRlKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIERhdGUobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRGdW5jdGlvbihsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbihsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVnZXIobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gSW50ZWdlcihsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3QobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRMaXRlcmFsKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIExpdGVyYWwobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlROZXZlcihsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBOZXZlcihsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE51bGwobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gTnVsbChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE51bWJlcihsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRPYmplY3QobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UUmVjb3JkKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFJlY29yZChsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFN0cmluZyhsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRTeW1ib2wobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gU3ltYm9sKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVHVwbGUobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVHVwbGUobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRQcm9taXNlKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVaW50OEFycmF5KGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkobGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmRlZmluZWQobGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVW5kZWZpbmVkKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24obGVmdCkpXG4gICAgICAgICAgICByZXR1cm4gVW5pb24obGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmtub3duKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFVua25vd24obGVmdCwgcmlnaHQpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRWb2lkKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIFZvaWQobGVmdCwgcmlnaHQpO1xuICAgICAgICB0aHJvdyBFcnJvcihgVHlwZUV4dGVuZHM6IFVua25vd24gbGVmdCB0eXBlIG9wZXJhbmQgJyR7bGVmdFtleHBvcnRzLktpbmRdfSdgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gRXh0ZW5kcyhsZWZ0LCByaWdodCkge1xuICAgICAgICByZXR1cm4gVmlzaXQobGVmdCwgcmlnaHQpO1xuICAgIH1cbiAgICBUeXBlRXh0ZW5kcy5FeHRlbmRzID0gRXh0ZW5kcztcbn0pKFR5cGVFeHRlbmRzIHx8IChleHBvcnRzLlR5cGVFeHRlbmRzID0gVHlwZUV4dGVuZHMgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFR5cGVDbG9uZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKiBTcGVjaWFsaXplZCBDbG9uZSBmb3IgVHlwZXMgKi9cbnZhciBUeXBlQ2xvbmU7XG4oZnVuY3Rpb24gKFR5cGVDbG9uZSkge1xuICAgIGZ1bmN0aW9uIElzT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0FycmF5KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLkFycmF5LmlzQXJyYXkodmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBBcnJheSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2YWx1ZSkgPT4gVmlzaXQodmFsdWUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNsb25lZFByb3BlcnRpZXMgPSBnbG9iYWxUaGlzLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyAuLi5hY2MsIFtrZXldOiBWaXNpdCh2YWx1ZVtrZXldKSB9O1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIGNvbnN0IGNsb25lZFN5bWJvbHMgPSBnbG9iYWxUaGlzLk9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IC4uLmFjYywgW2tleV06IFZpc2l0KHZhbHVlW2tleV0pIH07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgcmV0dXJuIHsgLi4uY2xvbmVkUHJvcGVydGllcywgLi4uY2xvbmVkU3ltYm9scyB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBWaXNpdCh2YWx1ZSkge1xuICAgICAgICBpZiAoSXNBcnJheSh2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gQXJyYXkodmFsdWUpO1xuICAgICAgICBpZiAoSXNPYmplY3QodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqIENsb25lcyBhIHR5cGUuICovXG4gICAgZnVuY3Rpb24gQ2xvbmUoc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB7IC4uLlZpc2l0KHNjaGVtYSksIC4uLm9wdGlvbnMgfTtcbiAgICB9XG4gICAgVHlwZUNsb25lLkNsb25lID0gQ2xvbmU7XG59KShUeXBlQ2xvbmUgfHwgKGV4cG9ydHMuVHlwZUNsb25lID0gVHlwZUNsb25lID0ge30pKTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbmRleGVkQWNjZXNzb3Jcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgSW5kZXhlZEFjY2Vzc29yO1xuKGZ1bmN0aW9uIChJbmRleGVkQWNjZXNzb3IpIHtcbiAgICBmdW5jdGlvbiBPcHRpb25hbFVud3JhcChzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5tYXAoKHNjaGVtYSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBbZXhwb3J0cy5Nb2RpZmllcl06IF8sIC4uLmNsb25lIH0gPSBUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSk7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0ludGVyc2VjdE9wdGlvbmFsKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmV2ZXJ5KChzY2hlbWEpID0+IFR5cGVHdWFyZC5UT3B0aW9uYWwoc2NoZW1hKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzVW5pb25PcHRpb25hbChzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5zb21lKChzY2hlbWEpID0+IFR5cGVHdWFyZC5UT3B0aW9uYWwoc2NoZW1hKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlc29sdmVJbnRlcnNlY3Qoc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbmFsID0gSXNJbnRlcnNlY3RPcHRpb25hbChzY2hlbWEuYWxsT2YpO1xuICAgICAgICByZXR1cm4gb3B0aW9uYWwgPyBleHBvcnRzLlR5cGUuT3B0aW9uYWwoZXhwb3J0cy5UeXBlLkludGVyc2VjdChPcHRpb25hbFVud3JhcChzY2hlbWEuYWxsT2YpKSkgOiBzY2hlbWE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlc29sdmVVbmlvbihzY2hlbWEpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uYWwgPSBJc1VuaW9uT3B0aW9uYWwoc2NoZW1hLmFueU9mKTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbmFsID8gZXhwb3J0cy5UeXBlLk9wdGlvbmFsKGV4cG9ydHMuVHlwZS5VbmlvbihPcHRpb25hbFVud3JhcChzY2hlbWEuYW55T2YpKSkgOiBzY2hlbWE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlc29sdmVPcHRpb25hbChzY2hlbWEpIHtcbiAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnSW50ZXJzZWN0JylcbiAgICAgICAgICAgIHJldHVybiBSZXNvbHZlSW50ZXJzZWN0KHNjaGVtYSk7XG4gICAgICAgIGlmIChzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1VuaW9uJylcbiAgICAgICAgICAgIHJldHVybiBSZXNvbHZlVW5pb24oc2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSW50ZXJzZWN0KHNjaGVtYSwga2V5KSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gc2NoZW1hLmFsbE9mLnJlZHVjZSgoYWNjLCBzY2hlbWEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ZWQgPSBWaXNpdChzY2hlbWEsIGtleSk7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXhlZFtleHBvcnRzLktpbmRdID09PSAnTmV2ZXInID8gYWNjIDogWy4uLmFjYywgaW5kZXhlZF07XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgcmV0dXJuIFJlc29sdmVPcHRpb25hbChleHBvcnRzLlR5cGUuSW50ZXJzZWN0KHJlc29sdmVkKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVuaW9uKHNjaGVtYSwga2V5KSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gc2NoZW1hLmFueU9mLm1hcCgoc2NoZW1hKSA9PiBWaXNpdChzY2hlbWEsIGtleSkpO1xuICAgICAgICByZXR1cm4gUmVzb2x2ZU9wdGlvbmFsKGV4cG9ydHMuVHlwZS5VbmlvbihyZXNvbHZlZCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBPYmplY3Qoc2NoZW1hLCBrZXkpIHtcbiAgICAgICAgY29uc3QgcHJvcGVydHkgPSBzY2hlbWEucHJvcGVydGllc1trZXldO1xuICAgICAgICByZXR1cm4gcHJvcGVydHkgPT09IHVuZGVmaW5lZCA/IGV4cG9ydHMuVHlwZS5OZXZlcigpIDogZXhwb3J0cy5UeXBlLlVuaW9uKFtwcm9wZXJ0eV0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBUdXBsZShzY2hlbWEsIGtleSkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IHNjaGVtYS5pdGVtcztcbiAgICAgICAgaWYgKGl0ZW1zID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5UeXBlLk5ldmVyKCk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBpdGVtc1trZXldOyAvL1xuICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuVHlwZS5OZXZlcigpO1xuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gVmlzaXQoc2NoZW1hLCBrZXkpIHtcbiAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnSW50ZXJzZWN0JylcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3Qoc2NoZW1hLCBrZXkpO1xuICAgICAgICBpZiAoc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdVbmlvbicpXG4gICAgICAgICAgICByZXR1cm4gVW5pb24oc2NoZW1hLCBrZXkpO1xuICAgICAgICBpZiAoc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdPYmplY3QnKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdChzY2hlbWEsIGtleSk7XG4gICAgICAgIGlmIChzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1R1cGxlJylcbiAgICAgICAgICAgIHJldHVybiBUdXBsZShzY2hlbWEsIGtleSk7XG4gICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuTmV2ZXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVzb2x2ZShzY2hlbWEsIGtleXMsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCByZXNvbHZlZCA9IGtleXMubWFwKChrZXkpID0+IFZpc2l0KHNjaGVtYSwga2V5LnRvU3RyaW5nKCkpKTtcbiAgICAgICAgcmV0dXJuIFJlc29sdmVPcHRpb25hbChleHBvcnRzLlR5cGUuVW5pb24ocmVzb2x2ZWQsIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgSW5kZXhlZEFjY2Vzc29yLlJlc29sdmUgPSBSZXNvbHZlO1xufSkoSW5kZXhlZEFjY2Vzc29yIHx8IChleHBvcnRzLkluZGV4ZWRBY2Nlc3NvciA9IEluZGV4ZWRBY2Nlc3NvciA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT2JqZWN0TWFwXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIE9iamVjdE1hcDtcbihmdW5jdGlvbiAoT2JqZWN0TWFwKSB7XG4gICAgZnVuY3Rpb24gSW50ZXJzZWN0KHNjaGVtYSwgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuSW50ZXJzZWN0KHNjaGVtYS5hbGxPZi5tYXAoKGlubmVyKSA9PiBWaXNpdChpbm5lciwgY2FsbGJhY2spKSwgeyAuLi5zY2hlbWEgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVuaW9uKHNjaGVtYSwgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuVW5pb24oc2NoZW1hLmFueU9mLm1hcCgoaW5uZXIpID0+IFZpc2l0KGlubmVyLCBjYWxsYmFjaykpLCB7IC4uLnNjaGVtYSB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gT2JqZWN0KHNjaGVtYSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHNjaGVtYSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFZpc2l0KHNjaGVtYSwgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIGNhc2VzIHdoZXJlIHVzZXJzIG5lZWQgdG8gbWFwIG9iamVjdHMgd2l0aCB1bnJlZ2lzdGVyZWQga2luZHMuIFVzaW5nIGEgVHlwZUd1YXJkIGhlcmUgd291bGRcbiAgICAgICAgLy8gcHJldmVudCBzdWIgc2NoZW1hIG1hcHBpbmcgYXMgdW5yZWdpc3RlcmVkIGtpbmRzIHdpbGwgbm90IHBhc3MgVFNjaGVtYSBjaGVja3MuIFRoaXMgaXMgbm90YWJsZSBpbiB0aGVcbiAgICAgICAgLy8gY2FzZSBvZiBUT2JqZWN0IHdoZXJlIHVucmVnaXN0ZXJlZCBwcm9wZXJ0eSBraW5kcyBjYXVzZSB0aGUgVE9iamVjdCBjaGVjayB0byBmYWlsLiBBcyBtYXBwaW5nIGlzIG9ubHlcbiAgICAgICAgLy8gdXNlZCBmb3IgY29tcG9zaXRpb24sIHdlIHVzZSBleHBsaWNpdCBjaGVja3MgaW5zdGVhZC5cbiAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnSW50ZXJzZWN0JylcbiAgICAgICAgICAgIHJldHVybiBJbnRlcnNlY3Qoc2NoZW1hLCBjYWxsYmFjayk7XG4gICAgICAgIGlmIChzY2hlbWFbZXhwb3J0cy5LaW5kXSA9PT0gJ1VuaW9uJylcbiAgICAgICAgICAgIHJldHVybiBVbmlvbihzY2hlbWEsIGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKHNjaGVtYVtleHBvcnRzLktpbmRdID09PSAnT2JqZWN0JylcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qoc2NoZW1hLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE1hcChzY2hlbWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB7IC4uLlZpc2l0KFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSwgY2FsbGJhY2spLCAuLi5vcHRpb25zIH07XG4gICAgfVxuICAgIE9iamVjdE1hcC5NYXAgPSBNYXA7XG59KShPYmplY3RNYXAgfHwgKGV4cG9ydHMuT2JqZWN0TWFwID0gT2JqZWN0TWFwID0ge30pKTtcbnZhciBLZXlSZXNvbHZlcjtcbihmdW5jdGlvbiAoS2V5UmVzb2x2ZXIpIHtcbiAgICBmdW5jdGlvbiBVbndyYXBQYXR0ZXJuKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5WzBdID09PSAnXicgJiYga2V5W2tleS5sZW5ndGggLSAxXSA9PT0gJyQnID8ga2V5LnNsaWNlKDEsIGtleS5sZW5ndGggLSAxKSA6IGtleTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSW50ZXJzZWN0KHNjaGVtYSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmFsbE9mLnJlZHVjZSgoYWNjLCBzY2hlbWEpID0+IFsuLi5hY2MsIC4uLlZpc2l0KHNjaGVtYSwgb3B0aW9ucyldLCBbXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVuaW9uKHNjaGVtYSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBzZXRzID0gc2NoZW1hLmFueU9mLm1hcCgoaW5uZXIpID0+IFZpc2l0KGlubmVyLCBvcHRpb25zKSk7XG4gICAgICAgIHJldHVybiBbLi4uc2V0cy5yZWR1Y2UoKHNldCwgb3V0ZXIpID0+IG91dGVyLm1hcCgoa2V5KSA9PiAoc2V0cy5ldmVyeSgoaW5uZXIpID0+IGlubmVyLmluY2x1ZGVzKGtleSkpID8gc2V0LmFkZChrZXkpIDogc2V0KSlbMF0sIG5ldyBTZXQoKSldO1xuICAgIH1cbiAgICBmdW5jdGlvbiBPYmplY3Qoc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzLk9iamVjdC5rZXlzKHNjaGVtYS5wcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVjb3JkKHNjaGVtYSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5pbmNsdWRlUGF0dGVybnMgPyBnbG9iYWxUaGlzLk9iamVjdC5rZXlzKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcykgOiBbXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVmlzaXQoc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVEludGVyc2VjdChzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuIEludGVyc2VjdChzY2hlbWEsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRVbmlvbihzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuIFVuaW9uKHNjaGVtYSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVE9iamVjdChzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdChzY2hlbWEsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQoc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybiBSZWNvcmQoc2NoZW1hLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAvKiogUmVzb2x2ZXMgYW4gYXJyYXkgb2Yga2V5cyBpbiB0aGlzIHNjaGVtYSAqL1xuICAgIGZ1bmN0aW9uIFJlc29sdmVLZXlzKHNjaGVtYSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gWy4uLm5ldyBTZXQoVmlzaXQoc2NoZW1hLCBvcHRpb25zKSldO1xuICAgIH1cbiAgICBLZXlSZXNvbHZlci5SZXNvbHZlS2V5cyA9IFJlc29sdmVLZXlzO1xuICAgIC8qKiBSZXNvbHZlcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXR0ZXJuIG1hdGNoaW5nIGFsbCBrZXlzIGluIHRoaXMgc2NoZW1hICovXG4gICAgZnVuY3Rpb24gUmVzb2x2ZVBhdHRlcm4oc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBSZXNvbHZlS2V5cyhzY2hlbWEsIHsgaW5jbHVkZVBhdHRlcm5zOiB0cnVlIH0pO1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0ga2V5cy5tYXAoKGtleSkgPT4gYCgke1Vud3JhcFBhdHRlcm4oa2V5KX0pYCk7XG4gICAgICAgIHJldHVybiBgXigke3BhdHRlcm4uam9pbignfCcpfSkkYDtcbiAgICB9XG4gICAgS2V5UmVzb2x2ZXIuUmVzb2x2ZVBhdHRlcm4gPSBSZXNvbHZlUGF0dGVybjtcbn0pKEtleVJlc29sdmVyIHx8IChleHBvcnRzLktleVJlc29sdmVyID0gS2V5UmVzb2x2ZXIgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEtleUFycmF5UmVzb2x2ZXJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgS2V5QXJyYXlSZXNvbHZlcjtcbihmdW5jdGlvbiAoS2V5QXJyYXlSZXNvbHZlcikge1xuICAgIC8qKiBSZXNvbHZlcyBhbiBhcnJheSBvZiBzdHJpbmdbXSBrZXlzIGZyb20gdGhlIGdpdmVuIHNjaGVtYSBvciBhcnJheSB0eXBlLiAqL1xuICAgIGZ1bmN0aW9uIFJlc29sdmUoc2NoZW1hKSB7XG4gICAgICAgIGlmIChnbG9iYWxUaGlzLkFycmF5LmlzQXJyYXkoc2NoZW1hKSlcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uTGl0ZXJhbChzY2hlbWEpKVxuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS5hbnlPZi5tYXAoKHNjaGVtYSkgPT4gc2NoZW1hLmNvbnN0LnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRMaXRlcmFsKHNjaGVtYSkpXG4gICAgICAgICAgICByZXR1cm4gW3NjaGVtYS5jb25zdF07XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFRlbXBsYXRlTGl0ZXJhbChzY2hlbWEpKSB7XG4gICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gVGVtcGxhdGVMaXRlcmFsUGFyc2VyLlBhcnNlRXhhY3Qoc2NoZW1hLnBhdHRlcm4pO1xuICAgICAgICAgICAgaWYgKCFUZW1wbGF0ZUxpdGVyYWxGaW5pdGUuQ2hlY2soZXhwcmVzc2lvbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0tleUFycmF5UmVzb2x2ZXI6IENhbm5vdCByZXNvbHZlIGtleXMgZnJvbSBpbmZpbml0ZSB0ZW1wbGF0ZSBleHByZXNzaW9uJyk7XG4gICAgICAgICAgICByZXR1cm4gWy4uLlRlbXBsYXRlTGl0ZXJhbEdlbmVyYXRvci5HZW5lcmF0ZShleHByZXNzaW9uKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBLZXlBcnJheVJlc29sdmVyLlJlc29sdmUgPSBSZXNvbHZlO1xufSkoS2V5QXJyYXlSZXNvbHZlciB8fCAoZXhwb3J0cy5LZXlBcnJheVJlc29sdmVyID0gS2V5QXJyYXlSZXNvbHZlciA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVW5pb25SZXNvbHZlclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBVbmlvblJlc29sdmVyO1xuKGZ1bmN0aW9uIChVbmlvblJlc29sdmVyKSB7XG4gICAgZnVuY3Rpb24qIFVuaW9uKHVuaW9uKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc2NoZW1hIG9mIHVuaW9uLmFueU9mKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hW2V4cG9ydHMuS2luZF0gPT09ICdVbmlvbicpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogVW5pb24oc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHlpZWxkIHNjaGVtYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogUmV0dXJucyBhIHJlc29sdmVkIHVuaW9uIHdpdGggaW50ZXJpb3IgdW5pb25zIGZsYXR0ZW5lZCAqL1xuICAgIGZ1bmN0aW9uIFJlc29sdmUodW5pb24pIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuVHlwZS5VbmlvbihbLi4uVW5pb24odW5pb24pXSwgeyAuLi51bmlvbiB9KTtcbiAgICB9XG4gICAgVW5pb25SZXNvbHZlci5SZXNvbHZlID0gUmVzb2x2ZTtcbn0pKFVuaW9uUmVzb2x2ZXIgfHwgKGV4cG9ydHMuVW5pb25SZXNvbHZlciA9IFVuaW9uUmVzb2x2ZXIgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRlbXBsYXRlTGl0ZXJhbFBhdHRlcm5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgVGVtcGxhdGVMaXRlcmFsUGF0dGVybjtcbihmdW5jdGlvbiAoVGVtcGxhdGVMaXRlcmFsUGF0dGVybikge1xuICAgIGZ1bmN0aW9uIEVzY2FwZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVmlzaXQoc2NoZW1hLCBhY2MpIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVGVtcGxhdGVMaXRlcmFsKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBzY2hlbWEucGF0dGVybi5zbGljZSgxLCBzY2hlbWEucGF0dGVybi5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UVW5pb24oc2NoZW1hKSkge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5zID0gc2NoZW1hLmFueU9mLm1hcCgoc2NoZW1hKSA9PiBWaXNpdChzY2hlbWEsIGFjYykpLmpvaW4oJ3wnKTtcbiAgICAgICAgICAgIHJldHVybiBgKCR7dG9rZW5zfSlgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UTnVtYmVyKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHthY2N9JHtleHBvcnRzLlBhdHRlcm5OdW1iZXJ9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChUeXBlR3VhcmQuVEludGVnZXIoc2NoZW1hKSkge1xuICAgICAgICAgICAgcmV0dXJuIGAke2FjY30ke2V4cG9ydHMuUGF0dGVybk51bWJlcn1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UQmlnSW50KHNjaGVtYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHthY2N9JHtleHBvcnRzLlBhdHRlcm5OdW1iZXJ9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChUeXBlR3VhcmQuVFN0cmluZyhzY2hlbWEpKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7YWNjfSR7ZXhwb3J0cy5QYXR0ZXJuU3RyaW5nfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVHlwZUd1YXJkLlRMaXRlcmFsKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHthY2N9JHtFc2NhcGUoc2NoZW1hLmNvbnN0LnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVHlwZUd1YXJkLlRCb29sZWFuKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHthY2N9JHtleHBvcnRzLlBhdHRlcm5Cb29sZWFufWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVHlwZUd1YXJkLlROZXZlcihzY2hlbWEpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignVGVtcGxhdGVMaXRlcmFsUGF0dGVybjogVGVtcGxhdGVMaXRlcmFsIGNhbm5vdCBvcGVyYXRlIG9uIHR5cGVzIG9mIFROZXZlcicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFRlbXBsYXRlTGl0ZXJhbFBhdHRlcm46IFVuZXhwZWN0ZWQgS2luZCAnJHtzY2hlbWFbZXhwb3J0cy5LaW5kXX0nYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gQ3JlYXRlKGtpbmRzKSB7XG4gICAgICAgIHJldHVybiBgXiR7a2luZHMubWFwKChzY2hlbWEpID0+IFZpc2l0KHNjaGVtYSwgJycpKS5qb2luKCcnKX1cXCRgO1xuICAgIH1cbiAgICBUZW1wbGF0ZUxpdGVyYWxQYXR0ZXJuLkNyZWF0ZSA9IENyZWF0ZTtcbn0pKFRlbXBsYXRlTGl0ZXJhbFBhdHRlcm4gfHwgKGV4cG9ydHMuVGVtcGxhdGVMaXRlcmFsUGF0dGVybiA9IFRlbXBsYXRlTGl0ZXJhbFBhdHRlcm4gPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIFRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyO1xuKGZ1bmN0aW9uIChUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlcikge1xuICAgIC8qKiBSZXNvbHZlcyBhIHRlbXBsYXRlIGxpdGVyYWwgYXMgYSBUVW5pb24gKi9cbiAgICBmdW5jdGlvbiBSZXNvbHZlKHRlbXBsYXRlKSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBUZW1wbGF0ZUxpdGVyYWxQYXJzZXIuUGFyc2VFeGFjdCh0ZW1wbGF0ZS5wYXR0ZXJuKTtcbiAgICAgICAgaWYgKCFUZW1wbGF0ZUxpdGVyYWxGaW5pdGUuQ2hlY2soZXhwcmVzc2lvbikpXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5UeXBlLlN0cmluZygpO1xuICAgICAgICBjb25zdCBsaXRlcmFscyA9IFsuLi5UZW1wbGF0ZUxpdGVyYWxHZW5lcmF0b3IuR2VuZXJhdGUoZXhwcmVzc2lvbildLm1hcCgodmFsdWUpID0+IGV4cG9ydHMuVHlwZS5MaXRlcmFsKHZhbHVlKSk7XG4gICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuVW5pb24obGl0ZXJhbHMpO1xuICAgIH1cbiAgICBUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlci5SZXNvbHZlID0gUmVzb2x2ZTtcbn0pKFRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyIHx8IChleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyID0gVGVtcGxhdGVMaXRlcmFsUmVzb2x2ZXIgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRlbXBsYXRlTGl0ZXJhbFBhcnNlclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNsYXNzIFRlbXBsYXRlTGl0ZXJhbFBhcnNlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgfVxufVxuZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWxQYXJzZXJFcnJvciA9IFRlbXBsYXRlTGl0ZXJhbFBhcnNlckVycm9yO1xudmFyIFRlbXBsYXRlTGl0ZXJhbFBhcnNlcjtcbihmdW5jdGlvbiAoVGVtcGxhdGVMaXRlcmFsUGFyc2VyKSB7XG4gICAgZnVuY3Rpb24gSXNOb25Fc2NhcGVkKHBhdHRlcm4sIGluZGV4LCBjaGFyKSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuW2luZGV4XSA9PT0gY2hhciAmJiBwYXR0ZXJuLmNoYXJDb2RlQXQoaW5kZXggLSAxKSAhPT0gOTI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzT3BlblBhcmVuKHBhdHRlcm4sIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBJc05vbkVzY2FwZWQocGF0dGVybiwgaW5kZXgsICcoJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzQ2xvc2VQYXJlbihwYXR0ZXJuLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gSXNOb25Fc2NhcGVkKHBhdHRlcm4sIGluZGV4LCAnKScpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc1NlcGFyYXRvcihwYXR0ZXJuLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gSXNOb25Fc2NhcGVkKHBhdHRlcm4sIGluZGV4LCAnfCcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc0dyb3VwKHBhdHRlcm4pIHtcbiAgICAgICAgaWYgKCEoSXNPcGVuUGFyZW4ocGF0dGVybiwgMCkgJiYgSXNDbG9zZVBhcmVuKHBhdHRlcm4sIHBhdHRlcm4ubGVuZ3RoIC0gMSkpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGF0dGVybi5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChJc09wZW5QYXJlbihwYXR0ZXJuLCBpbmRleCkpXG4gICAgICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICAgIGlmIChJc0Nsb3NlUGFyZW4ocGF0dGVybiwgaW5kZXgpKVxuICAgICAgICAgICAgICAgIGNvdW50IC09IDE7XG4gICAgICAgICAgICBpZiAoY291bnQgPT09IDAgJiYgaW5kZXggIT09IHBhdHRlcm4ubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEluR3JvdXAocGF0dGVybikge1xuICAgICAgICByZXR1cm4gcGF0dGVybi5zbGljZSgxLCBwYXR0ZXJuLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc1ByZWNlZGVuY2VPcihwYXR0ZXJuKSB7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwYXR0ZXJuLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgaWYgKElzT3BlblBhcmVuKHBhdHRlcm4sIGluZGV4KSlcbiAgICAgICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgICAgaWYgKElzQ2xvc2VQYXJlbihwYXR0ZXJuLCBpbmRleCkpXG4gICAgICAgICAgICAgICAgY291bnQgLT0gMTtcbiAgICAgICAgICAgIGlmIChJc1NlcGFyYXRvcihwYXR0ZXJuLCBpbmRleCkgJiYgY291bnQgPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc1ByZWNlZGVuY2VBbmQocGF0dGVybikge1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGF0dGVybi5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChJc09wZW5QYXJlbihwYXR0ZXJuLCBpbmRleCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBPcihwYXR0ZXJuKSB7XG4gICAgICAgIGxldCBbY291bnQsIHN0YXJ0XSA9IFswLCAwXTtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBhdHRlcm4ubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAoSXNPcGVuUGFyZW4ocGF0dGVybiwgaW5kZXgpKVxuICAgICAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgICBpZiAoSXNDbG9zZVBhcmVuKHBhdHRlcm4sIGluZGV4KSlcbiAgICAgICAgICAgICAgICBjb3VudCAtPSAxO1xuICAgICAgICAgICAgaWYgKElzU2VwYXJhdG9yKHBhdHRlcm4sIGluZGV4KSAmJiBjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gcGF0dGVybi5zbGljZShzdGFydCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKFBhcnNlKHJhbmdlKSk7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBpbmRleCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmFuZ2UgPSBwYXR0ZXJuLnNsaWNlKHN0YXJ0KTtcbiAgICAgICAgaWYgKHJhbmdlLmxlbmd0aCA+IDApXG4gICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKFBhcnNlKHJhbmdlKSk7XG4gICAgICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnY29uc3QnLCBjb25zdDogJycgfTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb25zLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uc1swXTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ29yJywgZXhwcjogZXhwcmVzc2lvbnMgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQW5kKHBhdHRlcm4pIHtcbiAgICAgICAgZnVuY3Rpb24gR3JvdXAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIUlzT3BlblBhcmVuKHZhbHVlLCBpbmRleCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRlbXBsYXRlTGl0ZXJhbFBhcnNlckVycm9yKGBUZW1wbGF0ZUxpdGVyYWxQYXJzZXI6IEluZGV4IG11c3QgcG9pbnQgdG8gb3BlbiBwYXJlbnNgKTtcbiAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBzY2FuID0gaW5kZXg7IHNjYW4gPCB2YWx1ZS5sZW5ndGg7IHNjYW4rKykge1xuICAgICAgICAgICAgICAgIGlmIChJc09wZW5QYXJlbih2YWx1ZSwgc2NhbikpXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgaWYgKElzQ2xvc2VQYXJlbih2YWx1ZSwgc2NhbikpXG4gICAgICAgICAgICAgICAgICAgIGNvdW50IC09IDE7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2luZGV4LCBzY2FuXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBUZW1wbGF0ZUxpdGVyYWxQYXJzZXJFcnJvcihgVGVtcGxhdGVMaXRlcmFsUGFyc2VyOiBVbmNsb3NlZCBncm91cCBwYXJlbnMgaW4gZXhwcmVzc2lvbmApO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIFJhbmdlKHBhdHRlcm4sIGluZGV4KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzY2FuID0gaW5kZXg7IHNjYW4gPCBwYXR0ZXJuLmxlbmd0aDsgc2NhbisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKElzT3BlblBhcmVuKHBhdHRlcm4sIHNjYW4pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2luZGV4LCBzY2FuXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbaW5kZXgsIHBhdHRlcm4ubGVuZ3RoXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHByZXNzaW9ucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGF0dGVybi5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChJc09wZW5QYXJlbihwYXR0ZXJuLCBpbmRleCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSBHcm91cChwYXR0ZXJuLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBwYXR0ZXJuLnNsaWNlKHN0YXJ0LCBlbmQgKyAxKTtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKFBhcnNlKHJhbmdlKSk7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSBSYW5nZShwYXR0ZXJuLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBwYXR0ZXJuLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKFBhcnNlKHJhbmdlKSk7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBlbmQgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnY29uc3QnLCBjb25zdDogJycgfTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb25zLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uc1swXTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ2FuZCcsIGV4cHI6IGV4cHJlc3Npb25zIH07XG4gICAgfVxuICAgIC8qKiBQYXJzZXMgYSBwYXR0ZXJuIGFuZCByZXR1cm5zIGFuIGV4cHJlc3Npb24gdHJlZSAqL1xuICAgIGZ1bmN0aW9uIFBhcnNlKHBhdHRlcm4pIHtcbiAgICAgICAgaWYgKElzR3JvdXAocGF0dGVybikpXG4gICAgICAgICAgICByZXR1cm4gUGFyc2UoSW5Hcm91cChwYXR0ZXJuKSk7XG4gICAgICAgIGlmIChJc1ByZWNlZGVuY2VPcihwYXR0ZXJuKSlcbiAgICAgICAgICAgIHJldHVybiBPcihwYXR0ZXJuKTtcbiAgICAgICAgaWYgKElzUHJlY2VkZW5jZUFuZChwYXR0ZXJuKSlcbiAgICAgICAgICAgIHJldHVybiBBbmQocGF0dGVybik7XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdjb25zdCcsIGNvbnN0OiBwYXR0ZXJuIH07XG4gICAgfVxuICAgIFRlbXBsYXRlTGl0ZXJhbFBhcnNlci5QYXJzZSA9IFBhcnNlO1xuICAgIC8qKiBQYXJzZXMgYSBwYXR0ZXJuIGFuZCBzdHJpcHMgZm9yd2FyZCBhbmQgdHJhaWxpbmcgXiBhbmQgJCAqL1xuICAgIGZ1bmN0aW9uIFBhcnNlRXhhY3QocGF0dGVybikge1xuICAgICAgICByZXR1cm4gUGFyc2UocGF0dGVybi5zbGljZSgxLCBwYXR0ZXJuLmxlbmd0aCAtIDEpKTtcbiAgICB9XG4gICAgVGVtcGxhdGVMaXRlcmFsUGFyc2VyLlBhcnNlRXhhY3QgPSBQYXJzZUV4YWN0O1xufSkoVGVtcGxhdGVMaXRlcmFsUGFyc2VyIHx8IChleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbFBhcnNlciA9IFRlbXBsYXRlTGl0ZXJhbFBhcnNlciA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGVtcGxhdGVMaXRlcmFsRmluaXRlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIFRlbXBsYXRlTGl0ZXJhbEZpbml0ZTtcbihmdW5jdGlvbiAoVGVtcGxhdGVMaXRlcmFsRmluaXRlKSB7XG4gICAgZnVuY3Rpb24gSXNOdW1iZXIoZXhwcmVzc2lvbikge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIChleHByZXNzaW9uLnR5cGUgPT09ICdvcicgJiZcbiAgICAgICAgICAgIGV4cHJlc3Npb24uZXhwci5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgIGV4cHJlc3Npb24uZXhwclswXS50eXBlID09PSAnY29uc3QnICYmXG4gICAgICAgICAgICBleHByZXNzaW9uLmV4cHJbMF0uY29uc3QgPT09ICcwJyAmJlxuICAgICAgICAgICAgZXhwcmVzc2lvbi5leHByWzFdLnR5cGUgPT09ICdjb25zdCcgJiZcbiAgICAgICAgICAgIGV4cHJlc3Npb24uZXhwclsxXS5jb25zdCA9PT0gJ1sxLTldWzAtOV0qJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzQm9vbGVhbihleHByZXNzaW9uKSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gKGV4cHJlc3Npb24udHlwZSA9PT0gJ29yJyAmJlxuICAgICAgICAgICAgZXhwcmVzc2lvbi5leHByLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICAgICAgZXhwcmVzc2lvbi5leHByWzBdLnR5cGUgPT09ICdjb25zdCcgJiZcbiAgICAgICAgICAgIGV4cHJlc3Npb24uZXhwclswXS5jb25zdCA9PT0gJ3RydWUnICYmXG4gICAgICAgICAgICBleHByZXNzaW9uLmV4cHJbMV0udHlwZSA9PT0gJ2NvbnN0JyAmJlxuICAgICAgICAgICAgZXhwcmVzc2lvbi5leHByWzFdLmNvbnN0ID09PSAnZmFsc2UnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNTdHJpbmcoZXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbi50eXBlID09PSAnY29uc3QnICYmIGV4cHJlc3Npb24uY29uc3QgPT09ICcuKic7XG4gICAgfVxuICAgIGZ1bmN0aW9uIENoZWNrKGV4cHJlc3Npb24pIHtcbiAgICAgICAgaWYgKElzQm9vbGVhbihleHByZXNzaW9uKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoSXNOdW1iZXIoZXhwcmVzc2lvbikgfHwgSXNTdHJpbmcoZXhwcmVzc2lvbikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChleHByZXNzaW9uLnR5cGUgPT09ICdhbmQnKVxuICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24uZXhwci5ldmVyeSgoZXhwcikgPT4gQ2hlY2soZXhwcikpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbi50eXBlID09PSAnb3InKVxuICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24uZXhwci5ldmVyeSgoZXhwcikgPT4gQ2hlY2soZXhwcikpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbi50eXBlID09PSAnY29uc3QnKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHRocm93IEVycm9yKGBUZW1wbGF0ZUxpdGVyYWxGaW5pdGU6IFVua25vd24gZXhwcmVzc2lvbiB0eXBlYCk7XG4gICAgfVxuICAgIFRlbXBsYXRlTGl0ZXJhbEZpbml0ZS5DaGVjayA9IENoZWNrO1xufSkoVGVtcGxhdGVMaXRlcmFsRmluaXRlIHx8IChleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbEZpbml0ZSA9IFRlbXBsYXRlTGl0ZXJhbEZpbml0ZSA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGVtcGxhdGVMaXRlcmFsR2VuZXJhdG9yXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIFRlbXBsYXRlTGl0ZXJhbEdlbmVyYXRvcjtcbihmdW5jdGlvbiAoVGVtcGxhdGVMaXRlcmFsR2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24qIFJlZHVjZShidWZmZXIpIHtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICByZXR1cm4geWllbGQqIGJ1ZmZlclswXTtcbiAgICAgICAgZm9yIChjb25zdCBsZWZ0IG9mIGJ1ZmZlclswXSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCByaWdodCBvZiBSZWR1Y2UoYnVmZmVyLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGAke2xlZnR9JHtyaWdodH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uKiBBbmQoZXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4geWllbGQqIFJlZHVjZShleHByZXNzaW9uLmV4cHIubWFwKChleHByKSA9PiBbLi4uR2VuZXJhdGUoZXhwcildKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uKiBPcihleHByZXNzaW9uKSB7XG4gICAgICAgIGZvciAoY29uc3QgZXhwciBvZiBleHByZXNzaW9uLmV4cHIpXG4gICAgICAgICAgICB5aWVsZCogR2VuZXJhdGUoZXhwcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uKiBDb25zdChleHByZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiB5aWVsZCBleHByZXNzaW9uLmNvbnN0O1xuICAgIH1cbiAgICBmdW5jdGlvbiogR2VuZXJhdGUoZXhwcmVzc2lvbikge1xuICAgICAgICBpZiAoZXhwcmVzc2lvbi50eXBlID09PSAnYW5kJylcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogQW5kKGV4cHJlc3Npb24pO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbi50eXBlID09PSAnb3InKVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBPcihleHByZXNzaW9uKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24udHlwZSA9PT0gJ2NvbnN0JylcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogQ29uc3QoZXhwcmVzc2lvbik7XG4gICAgICAgIHRocm93IEVycm9yKCdUZW1wbGF0ZUxpdGVyYWxHZW5lcmF0b3I6IFVua25vd24gZXhwcmVzc2lvbicpO1xuICAgIH1cbiAgICBUZW1wbGF0ZUxpdGVyYWxHZW5lcmF0b3IuR2VuZXJhdGUgPSBHZW5lcmF0ZTtcbn0pKFRlbXBsYXRlTGl0ZXJhbEdlbmVyYXRvciB8fCAoZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWxHZW5lcmF0b3IgPSBUZW1wbGF0ZUxpdGVyYWxHZW5lcmF0b3IgPSB7fSkpO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUZW1wbGF0ZUxpdGVyYWxEc2xQYXJzZXJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIFRlbXBsYXRlTGl0ZXJhbERzbFBhcnNlcjtcbihmdW5jdGlvbiAoVGVtcGxhdGVMaXRlcmFsRHNsUGFyc2VyKSB7XG4gICAgZnVuY3Rpb24qIFBhcnNlVW5pb24odGVtcGxhdGUpIHtcbiAgICAgICAgY29uc3QgdHJpbSA9IHRlbXBsYXRlLnRyaW0oKS5yZXBsYWNlKC9cInwnL2csICcnKTtcbiAgICAgICAgaWYgKHRyaW0gPT09ICdib29sZWFuJylcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCBleHBvcnRzLlR5cGUuQm9vbGVhbigpO1xuICAgICAgICBpZiAodHJpbSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICByZXR1cm4geWllbGQgZXhwb3J0cy5UeXBlLk51bWJlcigpO1xuICAgICAgICBpZiAodHJpbSA9PT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICByZXR1cm4geWllbGQgZXhwb3J0cy5UeXBlLkJpZ0ludCgpO1xuICAgICAgICBpZiAodHJpbSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4geWllbGQgZXhwb3J0cy5UeXBlLlN0cmluZygpO1xuICAgICAgICBjb25zdCBsaXRlcmFscyA9IHRyaW0uc3BsaXQoJ3wnKS5tYXAoKGxpdGVyYWwpID0+IGV4cG9ydHMuVHlwZS5MaXRlcmFsKGxpdGVyYWwudHJpbSgpKSk7XG4gICAgICAgIHJldHVybiB5aWVsZCBsaXRlcmFscy5sZW5ndGggPT09IDAgPyBleHBvcnRzLlR5cGUuTmV2ZXIoKSA6IGxpdGVyYWxzLmxlbmd0aCA9PT0gMSA/IGxpdGVyYWxzWzBdIDogZXhwb3J0cy5UeXBlLlVuaW9uKGxpdGVyYWxzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24qIFBhcnNlVGVybWluYWwodGVtcGxhdGUpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlWzFdICE9PSAneycpIHtcbiAgICAgICAgICAgIGNvbnN0IEwgPSBleHBvcnRzLlR5cGUuTGl0ZXJhbCgnJCcpO1xuICAgICAgICAgICAgY29uc3QgUiA9IFBhcnNlTGl0ZXJhbCh0ZW1wbGF0ZS5zbGljZSgxKSk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQqIFtMLCAuLi5SXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IHRlbXBsYXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGVtcGxhdGVbaV0gPT09ICd9Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IEwgPSBQYXJzZVVuaW9uKHRlbXBsYXRlLnNsaWNlKDIsIGkpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBSID0gUGFyc2VMaXRlcmFsKHRlbXBsYXRlLnNsaWNlKGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBbLi4uTCwgLi4uUl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgZXhwb3J0cy5UeXBlLkxpdGVyYWwodGVtcGxhdGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiogUGFyc2VMaXRlcmFsKHRlbXBsYXRlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVtcGxhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0ZW1wbGF0ZVtpXSA9PT0gJyQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgTCA9IGV4cG9ydHMuVHlwZS5MaXRlcmFsKHRlbXBsYXRlLnNsaWNlKDAsIGkpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBSID0gUGFyc2VUZXJtaW5hbCh0ZW1wbGF0ZS5zbGljZShpKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiBbTCwgLi4uUl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgZXhwb3J0cy5UeXBlLkxpdGVyYWwodGVtcGxhdGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBQYXJzZSh0ZW1wbGF0ZV9kc2wpIHtcbiAgICAgICAgcmV0dXJuIFsuLi5QYXJzZUxpdGVyYWwodGVtcGxhdGVfZHNsKV07XG4gICAgfVxuICAgIFRlbXBsYXRlTGl0ZXJhbERzbFBhcnNlci5QYXJzZSA9IFBhcnNlO1xufSkoVGVtcGxhdGVMaXRlcmFsRHNsUGFyc2VyIHx8IChleHBvcnRzLlRlbXBsYXRlTGl0ZXJhbERzbFBhcnNlciA9IFRlbXBsYXRlTGl0ZXJhbERzbFBhcnNlciA9IHt9KSk7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVHlwZU9yZGluYWw6IFVzZWQgZm9yIGF1dG8gJGlkIGdlbmVyYXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5sZXQgVHlwZU9yZGluYWwgPSAwO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFR5cGVCdWlsZGVyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY2xhc3MgVHlwZUJ1aWxkZXIge1xuICAgIC8qKiBgW1V0aWxpdHldYCBDcmVhdGVzIGEgc2NoZW1hIHdpdGhvdXQgYHN0YXRpY2AgYW5kIGBwYXJhbXNgIHR5cGVzICovXG4gICAgQ3JlYXRlKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIE9taXRzIGNvbXBvc2l0aW5nIHN5bWJvbHMgZnJvbSB0aGlzIHNjaGVtYSAqL1xuICAgIFN0cmljdChzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc2NoZW1hKSk7XG4gICAgfVxufVxuZXhwb3J0cy5UeXBlQnVpbGRlciA9IFR5cGVCdWlsZGVyO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFN0YW5kYXJkVHlwZUJ1aWxkZXJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5jbGFzcyBTdGFuZGFyZFR5cGVCdWlsZGVyIGV4dGVuZHMgVHlwZUJ1aWxkZXIge1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIE1vZGlmaWVyc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8qKiBgW01vZGlmaWVyXWAgQ3JlYXRlcyBhIE9wdGlvbmFsIHByb3BlcnR5ICovXG4gICAgT3B0aW9uYWwoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiB7IFtleHBvcnRzLk1vZGlmaWVyXTogJ09wdGlvbmFsJywgLi4uVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pIH07XG4gICAgfVxuICAgIC8qKiBgW01vZGlmaWVyXWAgQ3JlYXRlcyBhIFJlYWRvbmx5T3B0aW9uYWwgcHJvcGVydHkgKi9cbiAgICBSZWFkb25seU9wdGlvbmFsKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4geyBbZXhwb3J0cy5Nb2RpZmllcl06ICdSZWFkb25seU9wdGlvbmFsJywgLi4uVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pIH07XG4gICAgfVxuICAgIC8qKiBgW01vZGlmaWVyXWAgQ3JlYXRlcyBhIFJlYWRvbmx5IG9iamVjdCBvciBwcm9wZXJ0eSAqL1xuICAgIFJlYWRvbmx5KHNjaGVtYSkge1xuICAgICAgICByZXR1cm4geyBbZXhwb3J0cy5Nb2RpZmllcl06ICdSZWFkb25seScsIC4uLnNjaGVtYSB9O1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBUeXBlc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhbiBBbnkgdHlwZSAqL1xuICAgIEFueShvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdBbnknIH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYW4gQXJyYXkgdHlwZSAqL1xuICAgIEFycmF5KGl0ZW1zLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdBcnJheScsIHR5cGU6ICdhcnJheScsIGl0ZW1zOiBUeXBlQ2xvbmUuQ2xvbmUoaXRlbXMsIHt9KSB9KTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgQm9vbGVhbiB0eXBlICovXG4gICAgQm9vbGVhbihvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdCb29sZWFuJywgdHlwZTogJ2Jvb2xlYW4nIH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBDb21wb3NpdGUgb2JqZWN0IHR5cGUuICovXG4gICAgQ29tcG9zaXRlKG9iamVjdHMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgaW50ZXJzZWN0ID0gZXhwb3J0cy5UeXBlLkludGVyc2VjdChvYmplY3RzLCB7fSk7XG4gICAgICAgIGNvbnN0IGtleXMgPSBLZXlSZXNvbHZlci5SZXNvbHZlS2V5cyhpbnRlcnNlY3QsIHsgaW5jbHVkZVBhdHRlcm5zOiBmYWxzZSB9KTtcbiAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IGtleXMucmVkdWNlKChhY2MsIGtleSkgPT4gKHsgLi4uYWNjLCBba2V5XTogZXhwb3J0cy5UeXBlLkluZGV4KGludGVyc2VjdCwgW2tleV0pIH0pLCB7fSk7XG4gICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUuT2JqZWN0KHByb3BlcnRpZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBFbnVtIHR5cGUgKi9cbiAgICBFbnVtKGl0ZW0sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgY29uc3QgdmFsdWVzID0gZ2xvYmFsVGhpcy5PYmplY3Qua2V5cyhpdGVtKS5maWx0ZXIoKGtleSkgPT4gaXNOYU4oa2V5KSkubWFwKChrZXkpID0+IGl0ZW1ba2V5XSk7XG4gICAgICAgIGNvbnN0IGFueU9mID0gdmFsdWVzLm1hcCgodmFsdWUpID0+ICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8geyBbZXhwb3J0cy5LaW5kXTogJ0xpdGVyYWwnLCB0eXBlOiAnc3RyaW5nJywgY29uc3Q6IHZhbHVlIH0gOiB7IFtleHBvcnRzLktpbmRdOiAnTGl0ZXJhbCcsIHR5cGU6ICdudW1iZXInLCBjb25zdDogdmFsdWUgfSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1VuaW9uJywgYW55T2YgfSk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQSBjb25kaXRpb25hbCB0eXBlIGV4cHJlc3Npb24gdGhhdCB3aWxsIHJldHVybiB0aGUgdHJ1ZSB0eXBlIGlmIHRoZSBsZWZ0IHR5cGUgZXh0ZW5kcyB0aGUgcmlnaHQgKi9cbiAgICBFeHRlbmRzKGxlZnQsIHJpZ2h0LCB0cnVlVHlwZSwgZmFsc2VUeXBlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3dpdGNoIChUeXBlRXh0ZW5kcy5FeHRlbmRzKGxlZnQsIHJpZ2h0KSkge1xuICAgICAgICAgICAgY2FzZSBUeXBlRXh0ZW5kc1Jlc3VsdC5VbmlvbjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5VbmlvbihbVHlwZUNsb25lLkNsb25lKHRydWVUeXBlLCBvcHRpb25zKSwgVHlwZUNsb25lLkNsb25lKGZhbHNlVHlwZSwgb3B0aW9ucyldKTtcbiAgICAgICAgICAgIGNhc2UgVHlwZUV4dGVuZHNSZXN1bHQuVHJ1ZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHlwZUNsb25lLkNsb25lKHRydWVUeXBlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNhc2UgVHlwZUV4dGVuZHNSZXN1bHQuRmFsc2U6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFR5cGVDbG9uZS5DbG9uZShmYWxzZVR5cGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgRXhjbHVkZXMgZnJvbSB0aGUgbGVmdCB0eXBlIGFueSB0eXBlIHRoYXQgaXMgbm90IGFzc2lnbmFibGUgdG8gdGhlIHJpZ2h0ICovXG4gICAgRXhjbHVkZShsZWZ0LCByaWdodCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFRlbXBsYXRlTGl0ZXJhbChsZWZ0KSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkV4Y2x1ZGUoVGVtcGxhdGVMaXRlcmFsUmVzb2x2ZXIuUmVzb2x2ZShsZWZ0KSwgcmlnaHQsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRUZW1wbGF0ZUxpdGVyYWwocmlnaHQpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRXhjbHVkZShsZWZ0LCBUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlci5SZXNvbHZlKHJpZ2h0KSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFVuaW9uKGxlZnQpKSB7XG4gICAgICAgICAgICBjb25zdCBuYXJyb3dlZCA9IGxlZnQuYW55T2YuZmlsdGVyKChpbm5lcikgPT4gVHlwZUV4dGVuZHMuRXh0ZW5kcyhpbm5lciwgcmlnaHQpID09PSBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gKG5hcnJvd2VkLmxlbmd0aCA9PT0gMSA/IFR5cGVDbG9uZS5DbG9uZShuYXJyb3dlZFswXSwgb3B0aW9ucykgOiB0aGlzLlVuaW9uKG5hcnJvd2VkLCBvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKFR5cGVFeHRlbmRzLkV4dGVuZHMobGVmdCwgcmlnaHQpICE9PSBUeXBlRXh0ZW5kc1Jlc3VsdC5GYWxzZSA/IHRoaXMuTmV2ZXIob3B0aW9ucykgOiBUeXBlQ2xvbmUuQ2xvbmUobGVmdCwgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgRXh0cmFjdHMgZnJvbSB0aGUgbGVmdCB0eXBlIGFueSB0eXBlIHRoYXQgaXMgYXNzaWduYWJsZSB0byB0aGUgcmlnaHQgKi9cbiAgICBFeHRyYWN0KGxlZnQsIHJpZ2h0LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVGVtcGxhdGVMaXRlcmFsKGxlZnQpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRXh0cmFjdChUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlci5SZXNvbHZlKGxlZnQpLCByaWdodCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFRlbXBsYXRlTGl0ZXJhbChyaWdodCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5FeHRyYWN0KGxlZnQsIFRlbXBsYXRlTGl0ZXJhbFJlc29sdmVyLlJlc29sdmUocmlnaHQpLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb24obGVmdCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hcnJvd2VkID0gbGVmdC5hbnlPZi5maWx0ZXIoKGlubmVyKSA9PiBUeXBlRXh0ZW5kcy5FeHRlbmRzKGlubmVyLCByaWdodCkgIT09IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiAobmFycm93ZWQubGVuZ3RoID09PSAxID8gVHlwZUNsb25lLkNsb25lKG5hcnJvd2VkWzBdLCBvcHRpb25zKSA6IHRoaXMuVW5pb24obmFycm93ZWQsIG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoVHlwZUV4dGVuZHMuRXh0ZW5kcyhsZWZ0LCByaWdodCkgIT09IFR5cGVFeHRlbmRzUmVzdWx0LkZhbHNlID8gVHlwZUNsb25lLkNsb25lKGxlZnQsIG9wdGlvbnMpIDogdGhpcy5OZXZlcihvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBSZXR1cm5zIGluZGV4ZWQgcHJvcGVydHkgdHlwZXMgZm9yIHRoZSBnaXZlbiBrZXlzICovXG4gICAgSW5kZXgoc2NoZW1hLCB1bnJlc29sdmVkLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKFR5cGVHdWFyZC5UQXJyYXkoc2NoZW1hKSAmJiBUeXBlR3VhcmQuVE51bWJlcih1bnJlc29sdmVkKSkge1xuICAgICAgICAgICAgcmV0dXJuIFR5cGVDbG9uZS5DbG9uZShzY2hlbWEuaXRlbXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UVHVwbGUoc2NoZW1hKSAmJiBUeXBlR3VhcmQuVE51bWJlcih1bnJlc29sdmVkKSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBzY2hlbWEuaXRlbXMgPT09IHVuZGVmaW5lZCA/IFtdIDogc2NoZW1hLml0ZW1zO1xuICAgICAgICAgICAgY29uc3QgY2xvbmVkID0gaXRlbXMubWFwKChzY2hlbWEpID0+IFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5VbmlvbihjbG9uZWQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IEtleUFycmF5UmVzb2x2ZXIuUmVzb2x2ZSh1bnJlc29sdmVkKTtcbiAgICAgICAgICAgIGNvbnN0IGNsb25lID0gVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pO1xuICAgICAgICAgICAgcmV0dXJuIEluZGV4ZWRBY2Nlc3Nvci5SZXNvbHZlKGNsb25lLCBrZXlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYW4gSW50ZWdlciB0eXBlICovXG4gICAgSW50ZWdlcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdJbnRlZ2VyJywgdHlwZTogJ2ludGVnZXInIH0pO1xuICAgIH1cbiAgICBJbnRlcnNlY3QoYWxsT2YsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoYWxsT2YubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuVHlwZS5OZXZlcigpO1xuICAgICAgICBpZiAoYWxsT2YubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIFR5cGVDbG9uZS5DbG9uZShhbGxPZlswXSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IG9iamVjdHMgPSBhbGxPZi5ldmVyeSgoc2NoZW1hKSA9PiBUeXBlR3VhcmQuVE9iamVjdChzY2hlbWEpKTtcbiAgICAgICAgY29uc3QgY2xvbmVkID0gYWxsT2YubWFwKChzY2hlbWEpID0+IFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSk7XG4gICAgICAgIGNvbnN0IGNsb25lZFVuZXZhbHVhdGVkUHJvcGVydGllcyA9IFR5cGVHdWFyZC5UU2NoZW1hKG9wdGlvbnMudW5ldmFsdWF0ZWRQcm9wZXJ0aWVzKSA/IHsgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzOiBUeXBlQ2xvbmUuQ2xvbmUob3B0aW9ucy51bmV2YWx1YXRlZFByb3BlcnRpZXMsIHt9KSB9IDoge307XG4gICAgICAgIGlmIChvcHRpb25zLnVuZXZhbHVhdGVkUHJvcGVydGllcyA9PT0gZmFsc2UgfHwgVHlwZUd1YXJkLlRTY2hlbWEob3B0aW9ucy51bmV2YWx1YXRlZFByb3BlcnRpZXMpIHx8IG9iamVjdHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIC4uLmNsb25lZFVuZXZhbHVhdGVkUHJvcGVydGllcywgW2V4cG9ydHMuS2luZF06ICdJbnRlcnNlY3QnLCB0eXBlOiAnb2JqZWN0JywgYWxsT2Y6IGNsb25lZCB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIC4uLmNsb25lZFVuZXZhbHVhdGVkUHJvcGVydGllcywgW2V4cG9ydHMuS2luZF06ICdJbnRlcnNlY3QnLCBhbGxPZjogY2xvbmVkIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIEtleU9mIHR5cGUgKi9cbiAgICBLZXlPZihzY2hlbWEsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRSZWNvcmQoc2NoZW1hKSkge1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcylbMF07XG4gICAgICAgICAgICBpZiAocGF0dGVybiA9PT0gZXhwb3J0cy5QYXR0ZXJuTnVtYmVyRXhhY3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuTnVtYmVyKG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm4gPT09IGV4cG9ydHMuUGF0dGVyblN0cmluZ0V4YWN0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlN0cmluZyhvcHRpb25zKTtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdTdGFuZGFyZFR5cGVCdWlsZGVyOiBVbmFibGUgdG8gcmVzb2x2ZSBrZXkgdHlwZSBmcm9tIFJlY29yZCBrZXkgcGF0dGVybicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UVHVwbGUoc2NoZW1hKSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBzY2hlbWEuaXRlbXMgPT09IHVuZGVmaW5lZCA/IFtdIDogc2NoZW1hLml0ZW1zO1xuICAgICAgICAgICAgY29uc3QgbGl0ZXJhbHMgPSBpdGVtcy5tYXAoKF8sIGluZGV4KSA9PiBleHBvcnRzLlR5cGUuTGl0ZXJhbChpbmRleCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuVW5pb24obGl0ZXJhbHMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UQXJyYXkoc2NoZW1hKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuTnVtYmVyKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IEtleVJlc29sdmVyLlJlc29sdmVLZXlzKHNjaGVtYSwgeyBpbmNsdWRlUGF0dGVybnM6IGZhbHNlIH0pO1xuICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLk5ldmVyKG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbGl0ZXJhbHMgPSBrZXlzLm1hcCgoa2V5KSA9PiB0aGlzLkxpdGVyYWwoa2V5KSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5VbmlvbihsaXRlcmFscywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgTGl0ZXJhbCB0eXBlICovXG4gICAgTGl0ZXJhbCh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnTGl0ZXJhbCcsIGNvbnN0OiB2YWx1ZSwgdHlwZTogdHlwZW9mIHZhbHVlIH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBOZXZlciB0eXBlICovXG4gICAgTmV2ZXIob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnTmV2ZXInLCBub3Q6IHt9IH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBOb3QgdHlwZSAqL1xuICAgIE5vdChub3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdOb3QnLCBub3QgfSk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIE51bGwgdHlwZSAqL1xuICAgIE51bGwob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnTnVsbCcsIHR5cGU6ICdudWxsJyB9KTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgTnVtYmVyIHR5cGUgKi9cbiAgICBOdW1iZXIob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnTnVtYmVyJywgdHlwZTogJ251bWJlcicgfSk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhbiBPYmplY3QgdHlwZSAqL1xuICAgIE9iamVjdChwcm9wZXJ0aWVzLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgcHJvcGVydHlLZXlzID0gZ2xvYmFsVGhpcy5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm9wZXJ0aWVzKTtcbiAgICAgICAgY29uc3Qgb3B0aW9uYWxLZXlzID0gcHJvcGVydHlLZXlzLmZpbHRlcigoa2V5KSA9PiBUeXBlR3VhcmQuVE9wdGlvbmFsKHByb3BlcnRpZXNba2V5XSkgfHwgVHlwZUd1YXJkLlRSZWFkb25seU9wdGlvbmFsKHByb3BlcnRpZXNba2V5XSkpO1xuICAgICAgICBjb25zdCByZXF1aXJlZEtleXMgPSBwcm9wZXJ0eUtleXMuZmlsdGVyKChuYW1lKSA9PiAhb3B0aW9uYWxLZXlzLmluY2x1ZGVzKG5hbWUpKTtcbiAgICAgICAgY29uc3QgY2xvbmVkQWRkaXRpb25hbFByb3BlcnRpZXMgPSBUeXBlR3VhcmQuVFNjaGVtYShvcHRpb25zLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKSA/IHsgYWRkaXRpb25hbFByb3BlcnRpZXM6IFR5cGVDbG9uZS5DbG9uZShvcHRpb25zLmFkZGl0aW9uYWxQcm9wZXJ0aWVzLCB7fSkgfSA6IHt9O1xuICAgICAgICBjb25zdCBjbG9uZWRQcm9wZXJ0aWVzID0gcHJvcGVydHlLZXlzLnJlZHVjZSgoYWNjLCBrZXkpID0+ICh7IC4uLmFjYywgW2tleV06IFR5cGVDbG9uZS5DbG9uZShwcm9wZXJ0aWVzW2tleV0sIHt9KSB9KSwge30pO1xuICAgICAgICBpZiAocmVxdWlyZWRLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIC4uLmNsb25lZEFkZGl0aW9uYWxQcm9wZXJ0aWVzLCBbZXhwb3J0cy5LaW5kXTogJ09iamVjdCcsIHR5cGU6ICdvYmplY3QnLCBwcm9wZXJ0aWVzOiBjbG9uZWRQcm9wZXJ0aWVzLCByZXF1aXJlZDogcmVxdWlyZWRLZXlzIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgLi4uY2xvbmVkQWRkaXRpb25hbFByb3BlcnRpZXMsIFtleHBvcnRzLktpbmRdOiAnT2JqZWN0JywgdHlwZTogJ29iamVjdCcsIHByb3BlcnRpZXM6IGNsb25lZFByb3BlcnRpZXMgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT21pdChzY2hlbWEsIHVucmVzb2x2ZWQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBrZXlzID0gS2V5QXJyYXlSZXNvbHZlci5SZXNvbHZlKHVucmVzb2x2ZWQpO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgcmV0dXJuIE9iamVjdE1hcC5NYXAoVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pLCAoc2NoZW1hKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hLnJlcXVpcmVkID0gc2NoZW1hLnJlcXVpcmVkLmZpbHRlcigoa2V5KSA9PiAha2V5cy5pbmNsdWRlcyhrZXkpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hLnJlcXVpcmVkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYS5yZXF1aXJlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGdsb2JhbFRoaXMuT2JqZWN0LmtleXMoc2NoZW1hLnByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleXMuaW5jbHVkZXMoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYS5wcm9wZXJ0aWVzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoc2NoZW1hKTtcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIG1hcHBlZCB0eXBlIHdoZXJlIGFsbCBwcm9wZXJ0aWVzIGFyZSBPcHRpb25hbCAqL1xuICAgIFBhcnRpYWwoc2NoZW1hLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgZnVuY3Rpb24gQXBwbHkoc2NoZW1hKSB7XG4gICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIHN3aXRjaCAoc2NoZW1hW2V4cG9ydHMuTW9kaWZpZXJdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnUmVhZG9ubHlPcHRpb25hbCc6XG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYVtleHBvcnRzLk1vZGlmaWVyXSA9ICdSZWFkb25seU9wdGlvbmFsJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnUmVhZG9ubHknOlxuICAgICAgICAgICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5Nb2RpZmllcl0gPSAnUmVhZG9ubHlPcHRpb25hbCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ09wdGlvbmFsJzpcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuTW9kaWZpZXJdID0gJ09wdGlvbmFsJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuTW9kaWZpZXJdID0gJ09wdGlvbmFsJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIHJldHVybiBPYmplY3RNYXAuTWFwKFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSwgKHNjaGVtYSkgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIHNjaGVtYS5yZXF1aXJlZDtcbiAgICAgICAgICAgIGdsb2JhbFRoaXMuT2JqZWN0LmtleXMoc2NoZW1hLnByb3BlcnRpZXMpLmZvckVhY2goa2V5ID0+IEFwcGx5KHNjaGVtYS5wcm9wZXJ0aWVzW2tleV0pKTtcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBQaWNrKHNjaGVtYSwgdW5yZXNvbHZlZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBLZXlBcnJheVJlc29sdmVyLlJlc29sdmUodW5yZXNvbHZlZCk7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gT2JqZWN0TWFwLk1hcChUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSksIChzY2hlbWEpID0+IHtcbiAgICAgICAgICAgIGlmIChzY2hlbWEucmVxdWlyZWQpIHtcbiAgICAgICAgICAgICAgICBzY2hlbWEucmVxdWlyZWQgPSBzY2hlbWEucmVxdWlyZWQuZmlsdGVyKChrZXkpID0+IGtleXMuaW5jbHVkZXMoa2V5KSk7XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYS5yZXF1aXJlZC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWEucmVxdWlyZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBnbG9iYWxUaGlzLk9iamVjdC5rZXlzKHNjaGVtYS5wcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgICAgIGlmICgha2V5cy5pbmNsdWRlcyhrZXkpKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hLnByb3BlcnRpZXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZShzY2hlbWEpO1xuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgUmVjb3JkIHR5cGUgKi9cbiAgICBSZWNvcmQoa2V5LCBzY2hlbWEsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRUZW1wbGF0ZUxpdGVyYWwoa2V5KSkge1xuICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IFRlbXBsYXRlTGl0ZXJhbFBhcnNlci5QYXJzZUV4YWN0KGtleS5wYXR0ZXJuKTtcbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgcmV0dXJuIFRlbXBsYXRlTGl0ZXJhbEZpbml0ZS5DaGVjayhleHByZXNzaW9uKVxuICAgICAgICAgICAgICAgID8gKHRoaXMuT2JqZWN0KFsuLi5UZW1wbGF0ZUxpdGVyYWxHZW5lcmF0b3IuR2VuZXJhdGUoZXhwcmVzc2lvbildLnJlZHVjZSgoYWNjLCBrZXkpID0+ICh7IC4uLmFjYywgW2tleV06IFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSB9KSwge30pLCBvcHRpb25zKSlcbiAgICAgICAgICAgICAgICA6IHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdSZWNvcmQnLCB0eXBlOiAnb2JqZWN0JywgcGF0dGVyblByb3BlcnRpZXM6IHsgW2tleS5wYXR0ZXJuXTogVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pIH0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVHlwZUd1YXJkLlRVbmlvbihrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCB1bmlvbiA9IFVuaW9uUmVzb2x2ZXIuUmVzb2x2ZShrZXkpO1xuICAgICAgICAgICAgaWYgKFR5cGVHdWFyZC5UVW5pb25MaXRlcmFsKHVuaW9uKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB1bmlvbi5hbnlPZi5yZWR1Y2UoKGFjYywgbGl0ZXJhbCkgPT4gKHsgLi4uYWNjLCBbbGl0ZXJhbC5jb25zdF06IFR5cGVDbG9uZS5DbG9uZShzY2hlbWEsIHt9KSB9KSwge30pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLk9iamVjdChwcm9wZXJ0aWVzLCB7IC4uLm9wdGlvbnMsIFtleHBvcnRzLkhpbnRdOiAnUmVjb3JkJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignVHlwZUJ1aWxkZXI6IFJlY29yZCBrZXkgb2YgdHlwZSB1bmlvbiBjb250YWlucyBub24tbGl0ZXJhbCB0eXBlcycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5UTGl0ZXJhbChrZXkpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleS5jb25zdCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGtleS5jb25zdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5PYmplY3QoeyBba2V5LmNvbnN0XTogVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pIH0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdUeXBlQnVpbGRlcjogUmVjb3JkIGtleSBvZiB0eXBlIGxpdGVyYWwgaXMgbm90IG9mIHR5cGUgc3RyaW5nIG9yIG51bWJlcicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFR5cGVHdWFyZC5USW50ZWdlcihrZXkpIHx8IFR5cGVHdWFyZC5UTnVtYmVyKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBleHBvcnRzLlBhdHRlcm5OdW1iZXJFeGFjdDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnUmVjb3JkJywgdHlwZTogJ29iamVjdCcsIHBhdHRlcm5Qcm9wZXJ0aWVzOiB7IFtwYXR0ZXJuXTogVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pIH0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVHlwZUd1YXJkLlRTdHJpbmcoa2V5KSkge1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IGtleS5wYXR0ZXJuID09PSB1bmRlZmluZWQgPyBleHBvcnRzLlBhdHRlcm5TdHJpbmdFeGFjdCA6IGtleS5wYXR0ZXJuO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdSZWNvcmQnLCB0eXBlOiAnb2JqZWN0JywgcGF0dGVyblByb3BlcnRpZXM6IHsgW3BhdHRlcm5dOiBUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSkgfSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBTdGFuZGFyZFR5cGVCdWlsZGVyOiBSZWNvcmQga2V5IGlzIGFuIGludmFsaWQgdHlwZWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIFJlY3Vyc2l2ZSB0eXBlICovXG4gICAgUmVjdXJzaXZlKGNhbGxiYWNrLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuJGlkID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBvcHRpb25zLiRpZCA9IGBUJHtUeXBlT3JkaW5hbCsrfWA7XG4gICAgICAgIGNvbnN0IHRoaXNUeXBlID0gY2FsbGJhY2soeyBbZXhwb3J0cy5LaW5kXTogJ1RoaXMnLCAkcmVmOiBgJHtvcHRpb25zLiRpZH1gIH0pO1xuICAgICAgICB0aGlzVHlwZS4kaWQgPSBvcHRpb25zLiRpZDtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuSGludF06ICdSZWN1cnNpdmUnLCAuLi50aGlzVHlwZSB9KTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgUmVmIHR5cGUuIFRoZSByZWZlcmVuY2VkIHR5cGUgbXVzdCBjb250YWluIGEgJGlkICovXG4gICAgUmVmKHNjaGVtYSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmIChzY2hlbWEuJGlkID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignU3RhbmRhcmRUeXBlQnVpbGRlci5SZWY6IFRhcmdldCB0eXBlIG11c3Qgc3BlY2lmeSBhbiAkaWQnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdSZWYnLCAkcmVmOiBzY2hlbWEuJGlkIH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSBtYXBwZWQgdHlwZSB3aGVyZSBhbGwgcHJvcGVydGllcyBhcmUgUmVxdWlyZWQgKi9cbiAgICBSZXF1aXJlZChzY2hlbWEsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBmdW5jdGlvbiBBcHBseShzY2hlbWEpIHtcbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgc3dpdGNoIChzY2hlbWFbZXhwb3J0cy5Nb2RpZmllcl0pIHtcbiAgICAgICAgICAgICAgICBjYXNlICdSZWFkb25seU9wdGlvbmFsJzpcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hW2V4cG9ydHMuTW9kaWZpZXJdID0gJ1JlYWRvbmx5JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnUmVhZG9ubHknOlxuICAgICAgICAgICAgICAgICAgICBzY2hlbWFbZXhwb3J0cy5Nb2RpZmllcl0gPSAnUmVhZG9ubHknO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdPcHRpb25hbCc6XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFbZXhwb3J0cy5Nb2RpZmllcl07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFbZXhwb3J0cy5Nb2RpZmllcl07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICByZXR1cm4gT2JqZWN0TWFwLk1hcChUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSksIChzY2hlbWEpID0+IHtcbiAgICAgICAgICAgIHNjaGVtYS5yZXF1aXJlZCA9IGdsb2JhbFRoaXMuT2JqZWN0LmtleXMoc2NoZW1hLnByb3BlcnRpZXMpO1xuICAgICAgICAgICAgZ2xvYmFsVGhpcy5PYmplY3Qua2V5cyhzY2hlbWEucHJvcGVydGllcykuZm9yRWFjaChrZXkgPT4gQXBwbHkoc2NoZW1hLnByb3BlcnRpZXNba2V5XSkpO1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgUmV0dXJucyBhIHNjaGVtYSBhcnJheSB3aGljaCBhbGxvd3MgdHlwZXMgdG8gY29tcG9zZSB3aXRoIHRoZSBKYXZhU2NyaXB0IHNwcmVhZCBvcGVyYXRvciAqL1xuICAgIFJlc3Qoc2NoZW1hKSB7XG4gICAgICAgIGlmIChUeXBlR3VhcmQuVFR1cGxlKHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWEuaXRlbXMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hLml0ZW1zLm1hcCgoc2NoZW1hKSA9PiBUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLCB7fSldO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIFN0cmluZyB0eXBlICovXG4gICAgU3RyaW5nKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1N0cmluZycsIHR5cGU6ICdzdHJpbmcnIH0pO1xuICAgIH1cbiAgICAvKiogYFtTdGFuZGFyZF1gIENyZWF0ZXMgYSB0ZW1wbGF0ZSBsaXRlcmFsIHR5cGUgKi9cbiAgICBUZW1wbGF0ZUxpdGVyYWwodW5yZXNvbHZlZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBjb25zdCBwYXR0ZXJuID0gKHR5cGVvZiB1bnJlc29sdmVkID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgID8gVGVtcGxhdGVMaXRlcmFsUGF0dGVybi5DcmVhdGUoVGVtcGxhdGVMaXRlcmFsRHNsUGFyc2VyLlBhcnNlKHVucmVzb2x2ZWQpKVxuICAgICAgICAgICAgOiBUZW1wbGF0ZUxpdGVyYWxQYXR0ZXJuLkNyZWF0ZSh1bnJlc29sdmVkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdUZW1wbGF0ZUxpdGVyYWwnLCB0eXBlOiAnc3RyaW5nJywgcGF0dGVybiB9KTtcbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGEgVHVwbGUgdHlwZSAqL1xuICAgIFR1cGxlKGl0ZW1zLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgW2FkZGl0aW9uYWxJdGVtcywgbWluSXRlbXMsIG1heEl0ZW1zXSA9IFtmYWxzZSwgaXRlbXMubGVuZ3RoLCBpdGVtcy5sZW5ndGhdO1xuICAgICAgICBjb25zdCBjbG9uZWRJdGVtcyA9IGl0ZW1zLm1hcCgoaXRlbSkgPT4gVHlwZUNsb25lLkNsb25lKGl0ZW0sIHt9KSk7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBjb25zdCBzY2hlbWEgPSAoaXRlbXMubGVuZ3RoID4gMCA/XG4gICAgICAgICAgICB7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnVHVwbGUnLCB0eXBlOiAnYXJyYXknLCBpdGVtczogY2xvbmVkSXRlbXMsIGFkZGl0aW9uYWxJdGVtcywgbWluSXRlbXMsIG1heEl0ZW1zIH0gOlxuICAgICAgICAgICAgeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1R1cGxlJywgdHlwZTogJ2FycmF5JywgbWluSXRlbXMsIG1heEl0ZW1zIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoc2NoZW1hKTtcbiAgICB9XG4gICAgVW5pb24odW5pb24sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoVHlwZUd1YXJkLlRUZW1wbGF0ZUxpdGVyYWwodW5pb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gVGVtcGxhdGVMaXRlcmFsUmVzb2x2ZXIuUmVzb2x2ZSh1bmlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBhbnlPZiA9IHVuaW9uO1xuICAgICAgICAgICAgaWYgKGFueU9mLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5OZXZlcihvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChhbnlPZi5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKFR5cGVDbG9uZS5DbG9uZShhbnlPZlswXSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgY29uc3QgY2xvbmVkQW55T2YgPSBhbnlPZi5tYXAoKHNjaGVtYSkgPT4gVHlwZUNsb25lLkNsb25lKHNjaGVtYSwge30pKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnVW5pb24nLCBhbnlPZjogY2xvbmVkQW55T2YgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIGBbU3RhbmRhcmRdYCBDcmVhdGVzIGFuIFVua25vd24gdHlwZSAqL1xuICAgIFVua25vd24ob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnVW5rbm93bicgfSk7XG4gICAgfVxuICAgIC8qKiBgW1N0YW5kYXJkXWAgQ3JlYXRlcyBhIFVuc2FmZSB0eXBlIHRoYXQgaW5mZXJzIGZvciB0aGUgZ2VuZXJpYyBhcmd1bWVudCAqL1xuICAgIFVuc2FmZShvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06IG9wdGlvbnNbZXhwb3J0cy5LaW5kXSB8fCAnVW5zYWZlJyB9KTtcbiAgICB9XG59XG5leHBvcnRzLlN0YW5kYXJkVHlwZUJ1aWxkZXIgPSBTdGFuZGFyZFR5cGVCdWlsZGVyO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4dGVuZGVkVHlwZUJ1aWxkZXJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5jbGFzcyBFeHRlbmRlZFR5cGVCdWlsZGVyIGV4dGVuZHMgU3RhbmRhcmRUeXBlQnVpbGRlciB7XG4gICAgLyoqIGBbRXh0ZW5kZWRdYCBDcmVhdGVzIGEgQmlnSW50IHR5cGUgKi9cbiAgICBCaWdJbnQob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnQmlnSW50JywgdHlwZTogJ251bGwnLCB0eXBlT2Y6ICdCaWdJbnQnIH0pO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIEV4dHJhY3RzIHRoZSBDb25zdHJ1Y3RvclBhcmFtZXRlcnMgZnJvbSB0aGUgZ2l2ZW4gQ29uc3RydWN0b3IgdHlwZSAqL1xuICAgIENvbnN0cnVjdG9yUGFyYW1ldGVycyhzY2hlbWEsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5UdXBsZShbLi4uc2NoZW1hLnBhcmFtZXRlcnNdLCB7IC4uLm9wdGlvbnMgfSk7XG4gICAgfVxuICAgIC8qKiBgW0V4dGVuZGVkXWAgQ3JlYXRlcyBhIENvbnN0cnVjdG9yIHR5cGUgKi9cbiAgICBDb25zdHJ1Y3RvcihwYXJhbWV0ZXJzLCByZXR1cm5zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNsb25lZFJldHVybnMgPSBUeXBlQ2xvbmUuQ2xvbmUocmV0dXJucywge30pO1xuICAgICAgICBjb25zdCBjbG9uZWRQYXJhbWV0ZXJzID0gcGFyYW1ldGVycy5tYXAoKHBhcmFtZXRlcikgPT4gVHlwZUNsb25lLkNsb25lKHBhcmFtZXRlciwge30pKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdDb25zdHJ1Y3RvcicsIHR5cGU6ICdvYmplY3QnLCBpbnN0YW5jZU9mOiAnQ29uc3RydWN0b3InLCBwYXJhbWV0ZXJzOiBjbG9uZWRQYXJhbWV0ZXJzLCByZXR1cm5zOiBjbG9uZWRSZXR1cm5zIH0pO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIENyZWF0ZXMgYSBEYXRlIHR5cGUgKi9cbiAgICBEYXRlKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ0RhdGUnLCB0eXBlOiAnb2JqZWN0JywgaW5zdGFuY2VPZjogJ0RhdGUnIH0pO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIENyZWF0ZXMgYSBGdW5jdGlvbiB0eXBlICovXG4gICAgRnVuY3Rpb24ocGFyYW1ldGVycywgcmV0dXJucywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjbG9uZWRSZXR1cm5zID0gVHlwZUNsb25lLkNsb25lKHJldHVybnMsIHt9KTtcbiAgICAgICAgY29uc3QgY2xvbmVkUGFyYW1ldGVycyA9IHBhcmFtZXRlcnMubWFwKChwYXJhbWV0ZXIpID0+IFR5cGVDbG9uZS5DbG9uZShwYXJhbWV0ZXIsIHt9KSk7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnRnVuY3Rpb24nLCB0eXBlOiAnb2JqZWN0JywgaW5zdGFuY2VPZjogJ0Z1bmN0aW9uJywgcGFyYW1ldGVyczogY2xvbmVkUGFyYW1ldGVycywgcmV0dXJuczogY2xvbmVkUmV0dXJucyB9KTtcbiAgICB9XG4gICAgLyoqIGBbRXh0ZW5kZWRdYCBFeHRyYWN0cyB0aGUgSW5zdGFuY2VUeXBlIGZyb20gdGhlIGdpdmVuIENvbnN0cnVjdG9yICovXG4gICAgSW5zdGFuY2VUeXBlKHNjaGVtYSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLnJldHVybnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIEV4dHJhY3RzIHRoZSBQYXJhbWV0ZXJzIGZyb20gdGhlIGdpdmVuIEZ1bmN0aW9uIHR5cGUgKi9cbiAgICBQYXJhbWV0ZXJzKHNjaGVtYSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLlR1cGxlKHNjaGVtYS5wYXJhbWV0ZXJzLCB7IC4uLm9wdGlvbnMgfSk7XG4gICAgfVxuICAgIC8qKiBgW0V4dGVuZGVkXWAgQ3JlYXRlcyBhIFByb21pc2UgdHlwZSAqL1xuICAgIFByb21pc2UoaXRlbSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnUHJvbWlzZScsIHR5cGU6ICdvYmplY3QnLCBpbnN0YW5jZU9mOiAnUHJvbWlzZScsIGl0ZW06IFR5cGVDbG9uZS5DbG9uZShpdGVtLCB7fSkgfSk7XG4gICAgfVxuICAgIC8qKiBgW0V4dGVuZGVkXWAgQ3JlYXRlcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0eXBlICovXG4gICAgUmVnRXgocmVnZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5DcmVhdGUoeyAuLi5vcHRpb25zLCBbZXhwb3J0cy5LaW5kXTogJ1N0cmluZycsIHR5cGU6ICdzdHJpbmcnLCBwYXR0ZXJuOiByZWdleC5zb3VyY2UgfSk7XG4gICAgfVxuICAgIC8qKiBgW0V4dGVuZGVkXWAgRXh0cmFjdHMgdGhlIFJldHVyblR5cGUgZnJvbSB0aGUgZ2l2ZW4gRnVuY3Rpb24gKi9cbiAgICBSZXR1cm5UeXBlKHNjaGVtYSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBUeXBlQ2xvbmUuQ2xvbmUoc2NoZW1hLnJldHVybnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIENyZWF0ZXMgYSBTeW1ib2wgdHlwZSAqL1xuICAgIFN5bWJvbChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnU3ltYm9sJywgdHlwZTogJ251bGwnLCB0eXBlT2Y6ICdTeW1ib2wnIH0pO1xuICAgIH1cbiAgICAvKiogYFtFeHRlbmRlZF1gIENyZWF0ZXMgYSBVbmRlZmluZWQgdHlwZSAqL1xuICAgIFVuZGVmaW5lZChvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ3JlYXRlKHsgLi4ub3B0aW9ucywgW2V4cG9ydHMuS2luZF06ICdVbmRlZmluZWQnLCB0eXBlOiAnbnVsbCcsIHR5cGVPZjogJ1VuZGVmaW5lZCcgfSk7XG4gICAgfVxuICAgIC8qKiBgW0V4dGVuZGVkXWAgQ3JlYXRlcyBhIFVpbnQ4QXJyYXkgdHlwZSAqL1xuICAgIFVpbnQ4QXJyYXkob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnVWludDhBcnJheScsIHR5cGU6ICdvYmplY3QnLCBpbnN0YW5jZU9mOiAnVWludDhBcnJheScgfSk7XG4gICAgfVxuICAgIC8qKiBgW0V4dGVuZGVkXWAgQ3JlYXRlcyBhIFZvaWQgdHlwZSAqL1xuICAgIFZvaWQob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkNyZWF0ZSh7IC4uLm9wdGlvbnMsIFtleHBvcnRzLktpbmRdOiAnVm9pZCcsIHR5cGU6ICdudWxsJywgdHlwZU9mOiAnVm9pZCcgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5FeHRlbmRlZFR5cGVCdWlsZGVyID0gRXh0ZW5kZWRUeXBlQnVpbGRlcjtcbi8qKiBKU09OIFNjaGVtYSBUeXBlQnVpbGRlciB3aXRoIFN0YXRpYyBSZXNvbHV0aW9uIGZvciBUeXBlU2NyaXB0ICovXG5leHBvcnRzLlN0YW5kYXJkVHlwZSA9IG5ldyBTdGFuZGFyZFR5cGVCdWlsZGVyKCk7XG4vKiogSlNPTiBTY2hlbWEgVHlwZUJ1aWxkZXIgd2l0aCBTdGF0aWMgUmVzb2x1dGlvbiBmb3IgVHlwZVNjcmlwdCAqL1xuZXhwb3J0cy5UeXBlID0gbmV3IEV4dGVuZGVkVHlwZUJ1aWxkZXIoKTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlR5cGUiLCJTdGFuZGFyZFR5cGUiLCJFeHRlbmRlZFR5cGVCdWlsZGVyIiwiU3RhbmRhcmRUeXBlQnVpbGRlciIsIlR5cGVCdWlsZGVyIiwiVGVtcGxhdGVMaXRlcmFsRHNsUGFyc2VyIiwiVGVtcGxhdGVMaXRlcmFsR2VuZXJhdG9yIiwiVGVtcGxhdGVMaXRlcmFsRmluaXRlIiwiVGVtcGxhdGVMaXRlcmFsUGFyc2VyIiwiVGVtcGxhdGVMaXRlcmFsUGFyc2VyRXJyb3IiLCJUZW1wbGF0ZUxpdGVyYWxSZXNvbHZlciIsIlRlbXBsYXRlTGl0ZXJhbFBhdHRlcm4iLCJVbmlvblJlc29sdmVyIiwiS2V5QXJyYXlSZXNvbHZlciIsIktleVJlc29sdmVyIiwiT2JqZWN0TWFwIiwiSW5kZXhlZEFjY2Vzc29yIiwiVHlwZUNsb25lIiwiVHlwZUV4dGVuZHMiLCJUeXBlRXh0ZW5kc1Jlc3VsdCIsIkV4dGVuZHNVbmRlZmluZWQiLCJUeXBlR3VhcmQiLCJUeXBlR3VhcmRVbmtub3duVHlwZUVycm9yIiwiRm9ybWF0UmVnaXN0cnkiLCJUeXBlUmVnaXN0cnkiLCJQYXR0ZXJuU3RyaW5nRXhhY3QiLCJQYXR0ZXJuTnVtYmVyRXhhY3QiLCJQYXR0ZXJuQm9vbGVhbkV4YWN0IiwiUGF0dGVyblN0cmluZyIsIlBhdHRlcm5OdW1iZXIiLCJQYXR0ZXJuQm9vbGVhbiIsIktpbmQiLCJIaW50IiwiTW9kaWZpZXIiLCJTeW1ib2wiLCJmb3IiLCJtYXAiLCJNYXAiLCJFbnRyaWVzIiwiQ2xlYXIiLCJjbGVhciIsIkhhcyIsImtpbmQiLCJoYXMiLCJTZXQiLCJmdW5jIiwic2V0IiwiR2V0IiwiZ2V0IiwiZm9ybWF0IiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsInNjaGVtYSIsIklzT2JqZWN0IiwiQXJyYXkiLCJpc0FycmF5IiwiSXNBcnJheSIsIklzUGF0dGVybiIsIlJlZ0V4cCIsIklzQ29udHJvbENoYXJhY3RlckZyZWUiLCJpIiwibGVuZ3RoIiwiY29kZSIsImNoYXJDb2RlQXQiLCJJc0FkZGl0aW9uYWxQcm9wZXJ0aWVzIiwiSXNPcHRpb25hbEJvb2xlYW4iLCJUU2NoZW1hIiwiSXNCaWdJbnQiLCJJc1N0cmluZyIsIklzTnVtYmVyIiwiZ2xvYmFsVGhpcyIsIk51bWJlciIsImlzRmluaXRlIiwiSXNCb29sZWFuIiwiSXNPcHRpb25hbEJpZ0ludCIsInVuZGVmaW5lZCIsIklzT3B0aW9uYWxOdW1iZXIiLCJJc09wdGlvbmFsU3RyaW5nIiwiSXNPcHRpb25hbFBhdHRlcm4iLCJJc09wdGlvbmFsRm9ybWF0IiwiSXNPcHRpb25hbFNjaGVtYSIsIlRBbnkiLCJUS2luZCIsIiRpZCIsIlRBcnJheSIsInR5cGUiLCJpdGVtcyIsIm1pbkl0ZW1zIiwibWF4SXRlbXMiLCJ1bmlxdWVJdGVtcyIsIlRCaWdJbnQiLCJ0eXBlT2YiLCJtdWx0aXBsZU9mIiwibWluaW11bSIsIm1heGltdW0iLCJleGNsdXNpdmVNaW5pbXVtIiwiZXhjbHVzaXZlTWF4aW11bSIsIlRCb29sZWFuIiwiVENvbnN0cnVjdG9yIiwiaW5zdGFuY2VPZiIsInBhcmFtZXRlcnMiLCJyZXR1cm5zIiwicGFyYW1ldGVyIiwiVERhdGUiLCJtaW5pbXVtVGltZXN0YW1wIiwibWF4aW11bVRpbWVzdGFtcCIsImV4Y2x1c2l2ZU1pbmltdW1UaW1lc3RhbXAiLCJleGNsdXNpdmVNYXhpbXVtVGltZXN0YW1wIiwiVEZ1bmN0aW9uIiwiVEludGVnZXIiLCJUSW50ZXJzZWN0IiwiYWxsT2YiLCJ1bmV2YWx1YXRlZFByb3BlcnRpZXMiLCJpbm5lciIsIlRMaXRlcmFsU3RyaW5nIiwiY29uc3QiLCJUTGl0ZXJhbE51bWJlciIsIlRMaXRlcmFsQm9vbGVhbiIsIlRMaXRlcmFsIiwiVE5ldmVyIiwibm90IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIlROb3QiLCJUTnVsbCIsIlROdW1iZXIiLCJUT2JqZWN0IiwicHJvcGVydGllcyIsImFkZGl0aW9uYWxQcm9wZXJ0aWVzIiwibWluUHJvcGVydGllcyIsIm1heFByb3BlcnRpZXMiLCJrZXkiLCJlbnRyaWVzIiwiVFByb21pc2UiLCJpdGVtIiwiVFJlY29yZCIsInBhdHRlcm5Qcm9wZXJ0aWVzIiwia2V5cyIsIlRSZWYiLCIkcmVmIiwiVFN0cmluZyIsIm1pbkxlbmd0aCIsIm1heExlbmd0aCIsInBhdHRlcm4iLCJUU3ltYm9sIiwiVFRlbXBsYXRlTGl0ZXJhbCIsIlRUaGlzIiwiVFR1cGxlIiwiYWRkaXRpb25hbEl0ZW1zIiwiVFVuZGVmaW5lZCIsIlRVbmlvbkxpdGVyYWwiLCJUVW5pb24iLCJhbnlPZiIsImV2ZXJ5IiwiVFVpbnQ4QXJyYXkiLCJtaW5CeXRlTGVuZ3RoIiwibWF4Qnl0ZUxlbmd0aCIsIlRVbmtub3duIiwiVFVuc2FmZSIsIlRWb2lkIiwiVFJlYWRvbmx5T3B0aW9uYWwiLCJUUmVhZG9ubHkiLCJUT3B0aW9uYWwiLCJDaGVjayIsImludGVyc2VjdCIsInVuaW9uIiwic29tZSIsIkludG9Cb29sZWFuUmVzdWx0IiwicmVzdWx0IiwiRmFsc2UiLCJUcnVlIiwiQW55UmlnaHQiLCJsZWZ0IiwicmlnaHQiLCJBbnkiLCJJbnRlcnNlY3RSaWdodCIsIlVuaW9uIiwiQXJyYXlSaWdodCIsIlVuaW9uUmlnaHQiLCJVbmtub3duUmlnaHQiLCJJc09iamVjdEFycmF5TGlrZSIsIlZpc2l0IiwiQmlnSW50IiwiTmV2ZXJSaWdodCIsIk9iamVjdFJpZ2h0IiwiUmVjb3JkUmlnaHQiLCJCb29sZWFuUmlnaHQiLCJCb29sZWFuIiwiQ29uc3RydWN0b3IiLCJpbmRleCIsIkRhdGUiLCJGdW5jdGlvbiIsIkludGVnZXJSaWdodCIsIkludGVnZXIiLCJJbnRlcnNlY3QiLCJJc0xpdGVyYWxTdHJpbmciLCJJc0xpdGVyYWxOdW1iZXIiLCJJc0xpdGVyYWxCb29sZWFuIiwiTGl0ZXJhbCIsIlN0cmluZ1JpZ2h0IiwiTnVtYmVyUmlnaHQiLCJOZXZlciIsIlVud3JhcE5vdCIsImN1cnJlbnQiLCJkZXB0aCIsIlVua25vd24iLCJOb3QiLCJOdWxsIiwiSXNPYmplY3RQcm9wZXJ0eUNvdW50IiwiY291bnQiLCJJc09iamVjdFN0cmluZ0xpa2UiLCJJc09iamVjdFN5bWJvbExpa2UiLCJkZXNjcmlwdGlvbiIsIklzT2JqZWN0TnVtYmVyTGlrZSIsIklzT2JqZWN0Qm9vbGVhbkxpa2UiLCJJc09iamVjdEJpZ0ludExpa2UiLCJJc09iamVjdERhdGVMaWtlIiwiSXNPYmplY3RVaW50OEFycmF5TGlrZSIsIklzT2JqZWN0RnVuY3Rpb25MaWtlIiwiSXNPYmplY3RDb25zdHJ1Y3Rvckxpa2UiLCJJc09iamVjdFByb21pc2VMaWtlIiwidGhlbiIsIlByb3BlcnR5IiwiUmVjb3JkS2V5IiwiUHJvbWlzZSIsIlN0cmluZyIsIlJlY29yZFZhbHVlIiwiS2V5IiwiVmFsdWUiLCJSZWNvcmQiLCJUZW1wbGF0ZUxpdGVyYWwiLCJSZXNvbHZlIiwiVHVwbGVSaWdodCIsIklzQXJyYXlPZlR1cGxlIiwiVHVwbGUiLCJVaW50OEFycmF5IiwiVW5kZWZpbmVkIiwiVm9pZFJpZ2h0IiwiVm9pZCIsIkV4dGVuZHMiLCJjbG9uZWRQcm9wZXJ0aWVzIiwicmVkdWNlIiwiYWNjIiwiY2xvbmVkU3ltYm9scyIsImdldE93blByb3BlcnR5U3ltYm9scyIsIkNsb25lIiwib3B0aW9ucyIsIk9wdGlvbmFsVW53cmFwIiwiXyIsImNsb25lIiwiSXNJbnRlcnNlY3RPcHRpb25hbCIsIklzVW5pb25PcHRpb25hbCIsIlJlc29sdmVJbnRlcnNlY3QiLCJvcHRpb25hbCIsIk9wdGlvbmFsIiwiUmVzb2x2ZVVuaW9uIiwiUmVzb2x2ZU9wdGlvbmFsIiwicmVzb2x2ZWQiLCJpbmRleGVkIiwicHJvcGVydHkiLCJlbGVtZW50IiwidG9TdHJpbmciLCJjYWxsYmFjayIsIlVud3JhcFBhdHRlcm4iLCJzbGljZSIsInNldHMiLCJvdXRlciIsImluY2x1ZGVzIiwiYWRkIiwiaW5jbHVkZVBhdHRlcm5zIiwiUmVzb2x2ZUtleXMiLCJSZXNvbHZlUGF0dGVybiIsImpvaW4iLCJleHByZXNzaW9uIiwiUGFyc2VFeGFjdCIsIkdlbmVyYXRlIiwiRXNjYXBlIiwicmVwbGFjZSIsInRva2VucyIsIkNyZWF0ZSIsImtpbmRzIiwidGVtcGxhdGUiLCJsaXRlcmFscyIsIm1lc3NhZ2UiLCJJc05vbkVzY2FwZWQiLCJjaGFyIiwiSXNPcGVuUGFyZW4iLCJJc0Nsb3NlUGFyZW4iLCJJc1NlcGFyYXRvciIsIklzR3JvdXAiLCJJbkdyb3VwIiwiSXNQcmVjZWRlbmNlT3IiLCJJc1ByZWNlZGVuY2VBbmQiLCJPciIsInN0YXJ0IiwiZXhwcmVzc2lvbnMiLCJyYW5nZSIsInB1c2giLCJQYXJzZSIsImV4cHIiLCJBbmQiLCJHcm91cCIsInNjYW4iLCJSYW5nZSIsImVuZCIsIlJlZHVjZSIsImJ1ZmZlciIsIkNvbnN0IiwiUGFyc2VVbmlvbiIsInRyaW0iLCJzcGxpdCIsImxpdGVyYWwiLCJQYXJzZVRlcm1pbmFsIiwiTCIsIlIiLCJQYXJzZUxpdGVyYWwiLCJ0ZW1wbGF0ZV9kc2wiLCJUeXBlT3JkaW5hbCIsIlN0cmljdCIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsIlJlYWRvbmx5T3B0aW9uYWwiLCJSZWFkb25seSIsIkNvbXBvc2l0ZSIsIm9iamVjdHMiLCJJbmRleCIsIkVudW0iLCJ2YWx1ZXMiLCJmaWx0ZXIiLCJpc05hTiIsInRydWVUeXBlIiwiZmFsc2VUeXBlIiwiRXhjbHVkZSIsIm5hcnJvd2VkIiwiRXh0cmFjdCIsInVucmVzb2x2ZWQiLCJjbG9uZWQiLCJjbG9uZWRVbmV2YWx1YXRlZFByb3BlcnRpZXMiLCJLZXlPZiIsInByb3BlcnR5S2V5cyIsIm9wdGlvbmFsS2V5cyIsInJlcXVpcmVkS2V5cyIsIm5hbWUiLCJjbG9uZWRBZGRpdGlvbmFsUHJvcGVydGllcyIsInJlcXVpcmVkIiwiT21pdCIsIlBhcnRpYWwiLCJBcHBseSIsImZvckVhY2giLCJQaWNrIiwiUmVjdXJzaXZlIiwidGhpc1R5cGUiLCJSZWYiLCJSZXF1aXJlZCIsIlJlc3QiLCJjbG9uZWRJdGVtcyIsImNsb25lZEFueU9mIiwiVW5zYWZlIiwiQ29uc3RydWN0b3JQYXJhbWV0ZXJzIiwiY2xvbmVkUmV0dXJucyIsImNsb25lZFBhcmFtZXRlcnMiLCJJbnN0YW5jZVR5cGUiLCJQYXJhbWV0ZXJzIiwiUmVnRXgiLCJyZWdleCIsInNvdXJjZSIsIlJldHVyblR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@sinclair/typebox/typebox.js\n");

/***/ })

};
;