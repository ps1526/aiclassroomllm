"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/flat";
exports.ids = ["vendor-chunks/flat"];
exports.modules = {

/***/ "(rsc)/./node_modules/flat/index.js":
/*!************************************!*\
  !*** ./node_modules/flat/index.js ***!
  \************************************/
/***/ ((module) => {

eval("\nmodule.exports = flatten;\nflatten.flatten = flatten;\nflatten.unflatten = unflatten;\nfunction isBuffer(obj) {\n    return obj && obj.constructor && typeof obj.constructor.isBuffer === \"function\" && obj.constructor.isBuffer(obj);\n}\nfunction keyIdentity(key) {\n    return key;\n}\nfunction flatten(target, opts) {\n    opts = opts || {};\n    const delimiter = opts.delimiter || \".\";\n    const maxDepth = opts.maxDepth;\n    const transformKey = opts.transformKey || keyIdentity;\n    const output = {};\n    function step(object, prev, currentDepth) {\n        currentDepth = currentDepth || 1;\n        Object.keys(object).forEach(function(key) {\n            const value = object[key];\n            const isarray = opts.safe && Array.isArray(value);\n            const type = Object.prototype.toString.call(value);\n            const isbuffer = isBuffer(value);\n            const isobject = type === \"[object Object]\" || type === \"[object Array]\";\n            const newKey = prev ? prev + delimiter + transformKey(key) : transformKey(key);\n            if (!isarray && !isbuffer && isobject && Object.keys(value).length && (!opts.maxDepth || currentDepth < maxDepth)) {\n                return step(value, newKey, currentDepth + 1);\n            }\n            output[newKey] = value;\n        });\n    }\n    step(target);\n    return output;\n}\nfunction unflatten(target, opts) {\n    opts = opts || {};\n    const delimiter = opts.delimiter || \".\";\n    const overwrite = opts.overwrite || false;\n    const transformKey = opts.transformKey || keyIdentity;\n    const result = {};\n    const isbuffer = isBuffer(target);\n    if (isbuffer || Object.prototype.toString.call(target) !== \"[object Object]\") {\n        return target;\n    }\n    // safely ensure that the key is\n    // an integer.\n    function getkey(key) {\n        const parsedKey = Number(key);\n        return isNaN(parsedKey) || key.indexOf(\".\") !== -1 || opts.object ? key : parsedKey;\n    }\n    function addKeys(keyPrefix, recipient, target) {\n        return Object.keys(target).reduce(function(result, key) {\n            result[keyPrefix + delimiter + key] = target[key];\n            return result;\n        }, recipient);\n    }\n    function isEmpty(val) {\n        const type = Object.prototype.toString.call(val);\n        const isArray = type === \"[object Array]\";\n        const isObject = type === \"[object Object]\";\n        if (!val) {\n            return true;\n        } else if (isArray) {\n            return !val.length;\n        } else if (isObject) {\n            return !Object.keys(val).length;\n        }\n    }\n    target = Object.keys(target).reduce(function(result, key) {\n        const type = Object.prototype.toString.call(target[key]);\n        const isObject = type === \"[object Object]\" || type === \"[object Array]\";\n        if (!isObject || isEmpty(target[key])) {\n            result[key] = target[key];\n            return result;\n        } else {\n            return addKeys(key, result, flatten(target[key], opts));\n        }\n    }, {});\n    Object.keys(target).forEach(function(key) {\n        const split = key.split(delimiter).map(transformKey);\n        let key1 = getkey(split.shift());\n        let key2 = getkey(split[0]);\n        let recipient = result;\n        while(key2 !== undefined){\n            if (key1 === \"__proto__\") {\n                return;\n            }\n            const type = Object.prototype.toString.call(recipient[key1]);\n            const isobject = type === \"[object Object]\" || type === \"[object Array]\";\n            // do not write over falsey, non-undefined values if overwrite is false\n            if (!overwrite && !isobject && typeof recipient[key1] !== \"undefined\") {\n                return;\n            }\n            if (overwrite && !isobject || !overwrite && recipient[key1] == null) {\n                recipient[key1] = typeof key2 === \"number\" && !opts.object ? [] : {};\n            }\n            recipient = recipient[key1];\n            if (split.length > 0) {\n                key1 = getkey(split.shift());\n                key2 = getkey(split[0]);\n            }\n        }\n        // unflatten again for 'messy objects'\n        recipient[key1] = unflatten(target[key], opts);\n    });\n    return result;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LE9BQU9SLE9BQU9TLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJLENBQUNjLFNBQVMsQ0FBQ08sS0FBSztZQUMzRCxNQUFNbkIsV0FDSkwsU0FBUyxxQkFDVEEsU0FBUztZQUdYLHVFQUF1RTtZQUN2RSxJQUFJLENBQUNRLGFBQWEsQ0FBQ0gsWUFBWSxPQUFPWSxTQUFTLENBQUNPLEtBQUssS0FBSyxhQUFhO2dCQUNyRTtZQUNGO1lBRUEsSUFBSSxhQUFjLENBQUNuQixZQUFjLENBQUNHLGFBQWFTLFNBQVMsQ0FBQ08sS0FBSyxJQUFJLE1BQU87Z0JBQ3ZFUCxTQUFTLENBQUNPLEtBQUssR0FDYixPQUFPRSxTQUFTLFlBQ2hCLENBQUMzQyxLQUFLTSxNQUFNLEdBQUcsRUFBRSxHQUFHLENBQUM7WUFFekI7WUFFQTRCLFlBQVlBLFNBQVMsQ0FBQ08sS0FBSztZQUMzQixJQUFJRixNQUFNZixNQUFNLEdBQUcsR0FBRztnQkFDcEJpQixPQUFPZCxPQUFPWSxNQUFNRyxLQUFLO2dCQUN6QkMsT0FBT2hCLE9BQU9ZLEtBQUssQ0FBQyxFQUFFO1lBQ3hCO1FBQ0Y7UUFFQSxzQ0FBc0M7UUFDdENMLFNBQVMsQ0FBQ08sS0FBSyxHQUFHaEQsVUFBVU0sTUFBTSxDQUFDRCxJQUFJLEVBQUVFO0lBQzNDO0lBRUEsT0FBTzBCO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYXJkd2FyZS1kb2MtY2hhdGJvdC8uL25vZGVfbW9kdWxlcy9mbGF0L2luZGV4LmpzP2FkZjAiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuXG5mbGF0dGVuLmZsYXR0ZW4gPSBmbGF0dGVuXG5mbGF0dGVuLnVuZmxhdHRlbiA9IHVuZmxhdHRlblxuXG5mdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiBvYmogJiZcbiAgICBvYmouY29uc3RydWN0b3IgJiZcbiAgICAodHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJykgJiZcbiAgICBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG5mdW5jdGlvbiBrZXlJZGVudGl0eSAoa2V5KSB7XG4gIHJldHVybiBrZXlcbn1cblxuZnVuY3Rpb24gZmxhdHRlbiAodGFyZ2V0LCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgY29uc3QgZGVsaW1pdGVyID0gb3B0cy5kZWxpbWl0ZXIgfHwgJy4nXG4gIGNvbnN0IG1heERlcHRoID0gb3B0cy5tYXhEZXB0aFxuICBjb25zdCB0cmFuc2Zvcm1LZXkgPSBvcHRzLnRyYW5zZm9ybUtleSB8fCBrZXlJZGVudGl0eVxuICBjb25zdCBvdXRwdXQgPSB7fVxuXG4gIGZ1bmN0aW9uIHN0ZXAgKG9iamVjdCwgcHJldiwgY3VycmVudERlcHRoKSB7XG4gICAgY3VycmVudERlcHRoID0gY3VycmVudERlcHRoIHx8IDFcbiAgICBPYmplY3Qua2V5cyhvYmplY3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvYmplY3Rba2V5XVxuICAgICAgY29uc3QgaXNhcnJheSA9IG9wdHMuc2FmZSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKVxuICAgICAgY29uc3QgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSlcbiAgICAgIGNvbnN0IGlzYnVmZmVyID0gaXNCdWZmZXIodmFsdWUpXG4gICAgICBjb25zdCBpc29iamVjdCA9IChcbiAgICAgICAgdHlwZSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgfHxcbiAgICAgICAgdHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgICAgKVxuXG4gICAgICBjb25zdCBuZXdLZXkgPSBwcmV2XG4gICAgICAgID8gcHJldiArIGRlbGltaXRlciArIHRyYW5zZm9ybUtleShrZXkpXG4gICAgICAgIDogdHJhbnNmb3JtS2V5KGtleSlcblxuICAgICAgaWYgKCFpc2FycmF5ICYmICFpc2J1ZmZlciAmJiBpc29iamVjdCAmJiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoICYmXG4gICAgICAgICghb3B0cy5tYXhEZXB0aCB8fCBjdXJyZW50RGVwdGggPCBtYXhEZXB0aCkpIHtcbiAgICAgICAgcmV0dXJuIHN0ZXAodmFsdWUsIG5ld0tleSwgY3VycmVudERlcHRoICsgMSlcbiAgICAgIH1cblxuICAgICAgb3V0cHV0W25ld0tleV0gPSB2YWx1ZVxuICAgIH0pXG4gIH1cblxuICBzdGVwKHRhcmdldClcblxuICByZXR1cm4gb3V0cHV0XG59XG5cbmZ1bmN0aW9uIHVuZmxhdHRlbiAodGFyZ2V0LCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgY29uc3QgZGVsaW1pdGVyID0gb3B0cy5kZWxpbWl0ZXIgfHwgJy4nXG4gIGNvbnN0IG92ZXJ3cml0ZSA9IG9wdHMub3ZlcndyaXRlIHx8IGZhbHNlXG4gIGNvbnN0IHRyYW5zZm9ybUtleSA9IG9wdHMudHJhbnNmb3JtS2V5IHx8IGtleUlkZW50aXR5XG4gIGNvbnN0IHJlc3VsdCA9IHt9XG5cbiAgY29uc3QgaXNidWZmZXIgPSBpc0J1ZmZlcih0YXJnZXQpXG4gIGlmIChpc2J1ZmZlciB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGFyZ2V0KSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICByZXR1cm4gdGFyZ2V0XG4gIH1cblxuICAvLyBzYWZlbHkgZW5zdXJlIHRoYXQgdGhlIGtleSBpc1xuICAvLyBhbiBpbnRlZ2VyLlxuICBmdW5jdGlvbiBnZXRrZXkgKGtleSkge1xuICAgIGNvbnN0IHBhcnNlZEtleSA9IE51bWJlcihrZXkpXG5cbiAgICByZXR1cm4gKFxuICAgICAgaXNOYU4ocGFyc2VkS2V5KSB8fFxuICAgICAga2V5LmluZGV4T2YoJy4nKSAhPT0gLTEgfHxcbiAgICAgIG9wdHMub2JqZWN0XG4gICAgKSA/IGtleVxuICAgICAgOiBwYXJzZWRLZXlcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEtleXMgKGtleVByZWZpeCwgcmVjaXBpZW50LCB0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGFyZ2V0KS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwga2V5KSB7XG4gICAgICByZXN1bHRba2V5UHJlZml4ICsgZGVsaW1pdGVyICsga2V5XSA9IHRhcmdldFtrZXldXG5cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9LCByZWNpcGllbnQpXG4gIH1cblxuICBmdW5jdGlvbiBpc0VtcHR5ICh2YWwpIHtcbiAgICBjb25zdCB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbClcbiAgICBjb25zdCBpc0FycmF5ID0gdHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgIGNvbnN0IGlzT2JqZWN0ID0gdHlwZSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcblxuICAgIGlmICghdmFsKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaXNBcnJheSkge1xuICAgICAgcmV0dXJuICF2YWwubGVuZ3RoXG4gICAgfSBlbHNlIGlmIChpc09iamVjdCkge1xuICAgICAgcmV0dXJuICFPYmplY3Qua2V5cyh2YWwpLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHRhcmdldCA9IE9iamVjdC5rZXlzKHRhcmdldCkucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGtleSkge1xuICAgIGNvbnN0IHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGFyZ2V0W2tleV0pXG4gICAgY29uc3QgaXNPYmplY3QgPSAodHlwZSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJylcbiAgICBpZiAoIWlzT2JqZWN0IHx8IGlzRW1wdHkodGFyZ2V0W2tleV0pKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHRhcmdldFtrZXldXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhZGRLZXlzKFxuICAgICAgICBrZXksXG4gICAgICAgIHJlc3VsdCxcbiAgICAgICAgZmxhdHRlbih0YXJnZXRba2V5XSwgb3B0cylcbiAgICAgIClcbiAgICB9XG4gIH0sIHt9KVxuXG4gIE9iamVjdC5rZXlzKHRhcmdldCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgY29uc3Qgc3BsaXQgPSBrZXkuc3BsaXQoZGVsaW1pdGVyKS5tYXAodHJhbnNmb3JtS2V5KVxuICAgIGxldCBrZXkxID0gZ2V0a2V5KHNwbGl0LnNoaWZ0KCkpXG4gICAgbGV0IGtleTIgPSBnZXRrZXkoc3BsaXRbMF0pXG4gICAgbGV0IHJlY2lwaWVudCA9IHJlc3VsdFxuXG4gICAgd2hpbGUgKGtleTIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGtleTEgPT09ICdfX3Byb3RvX18nKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHJlY2lwaWVudFtrZXkxXSlcbiAgICAgIGNvbnN0IGlzb2JqZWN0ID0gKFxuICAgICAgICB0eXBlID09PSAnW29iamVjdCBPYmplY3RdJyB8fFxuICAgICAgICB0eXBlID09PSAnW29iamVjdCBBcnJheV0nXG4gICAgICApXG5cbiAgICAgIC8vIGRvIG5vdCB3cml0ZSBvdmVyIGZhbHNleSwgbm9uLXVuZGVmaW5lZCB2YWx1ZXMgaWYgb3ZlcndyaXRlIGlzIGZhbHNlXG4gICAgICBpZiAoIW92ZXJ3cml0ZSAmJiAhaXNvYmplY3QgJiYgdHlwZW9mIHJlY2lwaWVudFtrZXkxXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmICgob3ZlcndyaXRlICYmICFpc29iamVjdCkgfHwgKCFvdmVyd3JpdGUgJiYgcmVjaXBpZW50W2tleTFdID09IG51bGwpKSB7XG4gICAgICAgIHJlY2lwaWVudFtrZXkxXSA9IChcbiAgICAgICAgICB0eXBlb2Yga2V5MiA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAhb3B0cy5vYmplY3QgPyBbXSA6IHt9XG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgcmVjaXBpZW50ID0gcmVjaXBpZW50W2tleTFdXG4gICAgICBpZiAoc3BsaXQubGVuZ3RoID4gMCkge1xuICAgICAgICBrZXkxID0gZ2V0a2V5KHNwbGl0LnNoaWZ0KCkpXG4gICAgICAgIGtleTIgPSBnZXRrZXkoc3BsaXRbMF0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdW5mbGF0dGVuIGFnYWluIGZvciAnbWVzc3kgb2JqZWN0cydcbiAgICByZWNpcGllbnRba2V5MV0gPSB1bmZsYXR0ZW4odGFyZ2V0W2tleV0sIG9wdHMpXG4gIH0pXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJmbGF0dGVuIiwidW5mbGF0dGVuIiwiaXNCdWZmZXIiLCJvYmoiLCJjb25zdHJ1Y3RvciIsImtleUlkZW50aXR5Iiwia2V5IiwidGFyZ2V0Iiwib3B0cyIsImRlbGltaXRlciIsIm1heERlcHRoIiwidHJhbnNmb3JtS2V5Iiwib3V0cHV0Iiwic3RlcCIsIm9iamVjdCIsInByZXYiLCJjdXJyZW50RGVwdGgiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsInZhbHVlIiwiaXNhcnJheSIsInNhZmUiLCJBcnJheSIsImlzQXJyYXkiLCJ0eXBlIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiaXNidWZmZXIiLCJpc29iamVjdCIsIm5ld0tleSIsImxlbmd0aCIsIm92ZXJ3cml0ZSIsInJlc3VsdCIsImdldGtleSIsInBhcnNlZEtleSIsIk51bWJlciIsImlzTmFOIiwiaW5kZXhPZiIsImFkZEtleXMiLCJrZXlQcmVmaXgiLCJyZWNpcGllbnQiLCJyZWR1Y2UiLCJpc0VtcHR5IiwidmFsIiwiaXNPYmplY3QiLCJzcGxpdCIsIm1hcCIsImtleTEiLCJzaGlmdCIsImtleTIiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/flat/index.js\n");

/***/ })

};
;