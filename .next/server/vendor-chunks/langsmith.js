"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/langsmith";
exports.ids = ["vendor-chunks/langsmith"];
exports.modules = {

/***/ "(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/native.js":
/*!**************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/uuid/dist/esm-node/native.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    randomUUID: (node_crypto__WEBPACK_IMPORTED_MODULE_0___default().randomUUID)\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbmF0aXZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpQztBQUNqQyxpRUFBZTtJQUNiQyxZQUFZRCwrREFBaUI7QUFDL0IsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGFyZHdhcmUtZG9jLWNoYXRib3QvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbmF0aXZlLmpzP2FiM2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyeXB0byBmcm9tICdub2RlOmNyeXB0byc7XG5leHBvcnQgZGVmYXVsdCB7XG4gIHJhbmRvbVVVSUQ6IGNyeXB0by5yYW5kb21VVUlEXG59OyJdLCJuYW1lcyI6WyJjcnlwdG8iLCJyYW5kb21VVUlEIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/native.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/regex.js":
/*!*************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/uuid/dist/esm-node/regex.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcmVnZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLDBKQUEwSixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGFyZHdhcmUtZG9jLWNoYXRib3QvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcmVnZXguanM/OTI4YiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLThdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMHxmZmZmZmZmZi1mZmZmLWZmZmYtZmZmZi1mZmZmZmZmZmZmZmYpJC9pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/regex.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/rng.js":
/*!***********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/uuid/dist/esm-node/rng.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\nlet poolPtr = rnds8Pool.length;\nfunction rng() {\n    if (poolPtr > rnds8Pool.length - 16) {\n        node_crypto__WEBPACK_IMPORTED_MODULE_0___default().randomFillSync(rnds8Pool);\n        poolPtr = 0;\n    }\n    return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcm5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpQztBQUNqQyxNQUFNQyxZQUFZLElBQUlDLFdBQVcsTUFBTSxxQ0FBcUM7QUFDNUUsSUFBSUMsVUFBVUYsVUFBVUcsTUFBTTtBQUNmLFNBQVNDO0lBQ3RCLElBQUlGLFVBQVVGLFVBQVVHLE1BQU0sR0FBRyxJQUFJO1FBQ25DSixpRUFBcUIsQ0FBQ0M7UUFDdEJFLFVBQVU7SUFDWjtJQUNBLE9BQU9GLFVBQVVNLEtBQUssQ0FBQ0osU0FBU0EsV0FBVztBQUM3QyIsInNvdXJjZXMiOlsid2VicGFjazovL2hhcmR3YXJlLWRvYy1jaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3JuZy5qcz8wYmE5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcnlwdG8gZnJvbSAnbm9kZTpjcnlwdG8nO1xuY29uc3Qgcm5kczhQb29sID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTsgLy8gIyBvZiByYW5kb20gdmFsdWVzIHRvIHByZS1hbGxvY2F0ZVxubGV0IHBvb2xQdHIgPSBybmRzOFBvb2wubGVuZ3RoO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcm5nKCkge1xuICBpZiAocG9vbFB0ciA+IHJuZHM4UG9vbC5sZW5ndGggLSAxNikge1xuICAgIGNyeXB0by5yYW5kb21GaWxsU3luYyhybmRzOFBvb2wpO1xuICAgIHBvb2xQdHIgPSAwO1xuICB9XG4gIHJldHVybiBybmRzOFBvb2wuc2xpY2UocG9vbFB0ciwgcG9vbFB0ciArPSAxNik7XG59Il0sIm5hbWVzIjpbImNyeXB0byIsInJuZHM4UG9vbCIsIlVpbnQ4QXJyYXkiLCJwb29sUHRyIiwibGVuZ3RoIiwicm5nIiwicmFuZG9tRmlsbFN5bmMiLCJzbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/rng.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/stringify.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/uuid/dist/esm-node/stringify.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/validate.js\");\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */ const byteToHex = [];\nfor(let i = 0; i < 256; ++i){\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nfunction unsafeStringify(arr, offset = 0) {\n    // Note: Be careful editing this code!  It's been tuned for performance\n    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n    //\n    // Note to future-self: No, you can't remove the `toLowerCase()` call.\n    // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351\n    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + \"-\" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + \"-\" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + \"-\" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + \"-\" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    // Consistency check for valid UUID.  If this throws, it's likely due to one\n    // of the following:\n    // - One or more input array values don't map to a hex octet (leading to\n    // \"undefined\" in the uuid)\n    // - Invalid input values for the RFC `version` or `variant` fields\n    if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n        throw TypeError(\"Stringified UUID is invalid\");\n    }\n    return uuid;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc3RyaW5naWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxQztBQUVyQzs7O0NBR0MsR0FDRCxNQUFNQyxZQUFZLEVBQUU7QUFDcEIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUksS0FBSyxFQUFFQSxFQUFHO0lBQzVCRCxVQUFVRSxJQUFJLENBQUMsQ0FBQ0QsSUFBSSxLQUFJLEVBQUdFLFFBQVEsQ0FBQyxJQUFJQyxLQUFLLENBQUM7QUFDaEQ7QUFDTyxTQUFTQyxnQkFBZ0JDLEdBQUcsRUFBRUMsU0FBUyxDQUFDO0lBQzdDLHVFQUF1RTtJQUN2RSxvRkFBb0Y7SUFDcEYsRUFBRTtJQUNGLHNFQUFzRTtJQUN0RSx1RUFBdUU7SUFDdkUsT0FBTyxDQUFDUCxTQUFTLENBQUNNLEdBQUcsQ0FBQ0MsU0FBUyxFQUFFLENBQUMsR0FBR1AsU0FBUyxDQUFDTSxHQUFHLENBQUNDLFNBQVMsRUFBRSxDQUFDLEdBQUdQLFNBQVMsQ0FBQ00sR0FBRyxDQUFDQyxTQUFTLEVBQUUsQ0FBQyxHQUFHUCxTQUFTLENBQUNNLEdBQUcsQ0FBQ0MsU0FBUyxFQUFFLENBQUMsR0FBRyxNQUFNUCxTQUFTLENBQUNNLEdBQUcsQ0FBQ0MsU0FBUyxFQUFFLENBQUMsR0FBR1AsU0FBUyxDQUFDTSxHQUFHLENBQUNDLFNBQVMsRUFBRSxDQUFDLEdBQUcsTUFBTVAsU0FBUyxDQUFDTSxHQUFHLENBQUNDLFNBQVMsRUFBRSxDQUFDLEdBQUdQLFNBQVMsQ0FBQ00sR0FBRyxDQUFDQyxTQUFTLEVBQUUsQ0FBQyxHQUFHLE1BQU1QLFNBQVMsQ0FBQ00sR0FBRyxDQUFDQyxTQUFTLEVBQUUsQ0FBQyxHQUFHUCxTQUFTLENBQUNNLEdBQUcsQ0FBQ0MsU0FBUyxFQUFFLENBQUMsR0FBRyxNQUFNUCxTQUFTLENBQUNNLEdBQUcsQ0FBQ0MsU0FBUyxHQUFHLENBQUMsR0FBR1AsU0FBUyxDQUFDTSxHQUFHLENBQUNDLFNBQVMsR0FBRyxDQUFDLEdBQUdQLFNBQVMsQ0FBQ00sR0FBRyxDQUFDQyxTQUFTLEdBQUcsQ0FBQyxHQUFHUCxTQUFTLENBQUNNLEdBQUcsQ0FBQ0MsU0FBUyxHQUFHLENBQUMsR0FBR1AsU0FBUyxDQUFDTSxHQUFHLENBQUNDLFNBQVMsR0FBRyxDQUFDLEdBQUdQLFNBQVMsQ0FBQ00sR0FBRyxDQUFDQyxTQUFTLEdBQUcsQ0FBQyxFQUFFQyxXQUFXO0FBQ2xnQjtBQUNBLFNBQVNDLFVBQVVILEdBQUcsRUFBRUMsU0FBUyxDQUFDO0lBQ2hDLE1BQU1HLE9BQU9MLGdCQUFnQkMsS0FBS0M7SUFDbEMsNEVBQTRFO0lBQzVFLG9CQUFvQjtJQUNwQix3RUFBd0U7SUFDeEUsMkJBQTJCO0lBQzNCLG1FQUFtRTtJQUNuRSxJQUFJLENBQUNSLHdEQUFRQSxDQUFDVyxPQUFPO1FBQ25CLE1BQU1DLFVBQVU7SUFDbEI7SUFDQSxPQUFPRDtBQUNUO0FBQ0EsaUVBQWVELFNBQVNBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYXJkd2FyZS1kb2MtY2hhdGJvdC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9zdHJpbmdpZnkuanM/OWRmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5cbi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xuY29uc3QgYnl0ZVRvSGV4ID0gW107XG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleC5wdXNoKChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zbGljZSgxKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdW5zYWZlU3RyaW5naWZ5KGFyciwgb2Zmc2V0ID0gMCkge1xuICAvLyBOb3RlOiBCZSBjYXJlZnVsIGVkaXRpbmcgdGhpcyBjb2RlISAgSXQncyBiZWVuIHR1bmVkIGZvciBwZXJmb3JtYW5jZVxuICAvLyBhbmQgd29ya3MgaW4gd2F5cyB5b3UgbWF5IG5vdCBleHBlY3QuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQvcHVsbC80MzRcbiAgLy9cbiAgLy8gTm90ZSB0byBmdXR1cmUtc2VsZjogTm8sIHlvdSBjYW4ndCByZW1vdmUgdGhlIGB0b0xvd2VyQ2FzZSgpYCBjYWxsLlxuICAvLyBSRUY6IGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZC9wdWxsLzY3NyNpc3N1ZWNvbW1lbnQtMTc1NzM1MTM1MVxuICByZXR1cm4gKGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgM11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDVdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA3XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDhdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxM11dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNV1dKS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5KGFyciwgb2Zmc2V0ID0gMCkge1xuICBjb25zdCB1dWlkID0gdW5zYWZlU3RyaW5naWZ5KGFyciwgb2Zmc2V0KTtcbiAgLy8gQ29uc2lzdGVuY3kgY2hlY2sgZm9yIHZhbGlkIFVVSUQuICBJZiB0aGlzIHRocm93cywgaXQncyBsaWtlbHkgZHVlIHRvIG9uZVxuICAvLyBvZiB0aGUgZm9sbG93aW5nOlxuICAvLyAtIE9uZSBvciBtb3JlIGlucHV0IGFycmF5IHZhbHVlcyBkb24ndCBtYXAgdG8gYSBoZXggb2N0ZXQgKGxlYWRpbmcgdG9cbiAgLy8gXCJ1bmRlZmluZWRcIiBpbiB0aGUgdXVpZClcbiAgLy8gLSBJbnZhbGlkIGlucHV0IHZhbHVlcyBmb3IgdGhlIFJGQyBgdmVyc2lvbmAgb3IgYHZhcmlhbnRgIGZpZWxkc1xuICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmdpZmllZCBVVUlEIGlzIGludmFsaWQnKTtcbiAgfVxuICByZXR1cm4gdXVpZDtcbn1cbmV4cG9ydCBkZWZhdWx0IHN0cmluZ2lmeTsiXSwibmFtZXMiOlsidmFsaWRhdGUiLCJieXRlVG9IZXgiLCJpIiwicHVzaCIsInRvU3RyaW5nIiwic2xpY2UiLCJ1bnNhZmVTdHJpbmdpZnkiLCJhcnIiLCJvZmZzZXQiLCJ0b0xvd2VyQ2FzZSIsInN0cmluZ2lmeSIsInV1aWQiLCJUeXBlRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/stringify.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/v4.js":
/*!**********************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/uuid/dist/esm-node/v4.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ \"(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/native.js\");\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ \"(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\nfunction v4(options, buf, offset) {\n    if (_native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID && !buf && !options) {\n        return _native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID();\n    }\n    options = options || {};\n    const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n    rnds[6] = rnds[6] & 0x0f | 0x40;\n    rnds[8] = rnds[8] & 0x3f | 0x80;\n    // Copy bytes to buffer, if provided\n    if (buf) {\n        offset = offset || 0;\n        for(let i = 0; i < 16; ++i){\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpQztBQUNOO0FBQ3NCO0FBQ2pELFNBQVNHLEdBQUdDLE9BQU8sRUFBRUMsR0FBRyxFQUFFQyxNQUFNO0lBQzlCLElBQUlOLGtEQUFNQSxDQUFDTyxVQUFVLElBQUksQ0FBQ0YsT0FBTyxDQUFDRCxTQUFTO1FBQ3pDLE9BQU9KLGtEQUFNQSxDQUFDTyxVQUFVO0lBQzFCO0lBQ0FILFVBQVVBLFdBQVcsQ0FBQztJQUN0QixNQUFNSSxPQUFPSixRQUFRSyxNQUFNLElBQUksQ0FBQ0wsUUFBUUgsR0FBRyxJQUFJQSwrQ0FBRTtJQUVqRCxnRUFBZ0U7SUFDaEVPLElBQUksQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxFQUFFLEdBQUcsT0FBTztJQUMzQkEsSUFBSSxDQUFDLEVBQUUsR0FBR0EsSUFBSSxDQUFDLEVBQUUsR0FBRyxPQUFPO0lBRTNCLG9DQUFvQztJQUNwQyxJQUFJSCxLQUFLO1FBQ1BDLFNBQVNBLFVBQVU7UUFDbkIsSUFBSyxJQUFJSSxJQUFJLEdBQUdBLElBQUksSUFBSSxFQUFFQSxFQUFHO1lBQzNCTCxHQUFHLENBQUNDLFNBQVNJLEVBQUUsR0FBR0YsSUFBSSxDQUFDRSxFQUFFO1FBQzNCO1FBQ0EsT0FBT0w7SUFDVDtJQUNBLE9BQU9ILDhEQUFlQSxDQUFDTTtBQUN6QjtBQUNBLGlFQUFlTCxFQUFFQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGFyZHdhcmUtZG9jLWNoYXRib3QvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjQuanM/YWI4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbmF0aXZlIGZyb20gJy4vbmF0aXZlLmpzJztcbmltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgaWYgKG5hdGl2ZS5yYW5kb21VVUlEICYmICFidWYgJiYgIW9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmF0aXZlLnJhbmRvbVVVSUQoKTtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3Qgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwO1xuXG4gIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICBpZiAoYnVmKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICBidWZbb2Zmc2V0ICsgaV0gPSBybmRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xuICB9XG4gIHJldHVybiB1bnNhZmVTdHJpbmdpZnkocm5kcyk7XG59XG5leHBvcnQgZGVmYXVsdCB2NDsiXSwibmFtZXMiOlsibmF0aXZlIiwicm5nIiwidW5zYWZlU3RyaW5naWZ5IiwidjQiLCJvcHRpb25zIiwiYnVmIiwib2Zmc2V0IiwicmFuZG9tVVVJRCIsInJuZHMiLCJyYW5kb20iLCJpIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/v4.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/validate.js":
/*!****************************************************************************!*\
  !*** ./node_modules/langsmith/node_modules/uuid/dist/esm-node/validate.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/regex.js\");\n\nfunction validate(uuid) {\n    return typeof uuid === \"string\" && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmFsaWRhdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0I7QUFDL0IsU0FBU0MsU0FBU0MsSUFBSTtJQUNwQixPQUFPLE9BQU9BLFNBQVMsWUFBWUYsaURBQUtBLENBQUNHLElBQUksQ0FBQ0Q7QUFDaEQ7QUFDQSxpRUFBZUQsUUFBUUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hhcmR3YXJlLWRvYy1jaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3ZhbGlkYXRlLmpzP2Y1OTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJFR0VYIGZyb20gJy4vcmVnZXguanMnO1xuZnVuY3Rpb24gdmFsaWRhdGUodXVpZCkge1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnICYmIFJFR0VYLnRlc3QodXVpZCk7XG59XG5leHBvcnQgZGVmYXVsdCB2YWxpZGF0ZTsiXSwibmFtZXMiOlsiUkVHRVgiLCJ2YWxpZGF0ZSIsInV1aWQiLCJ0ZXN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/validate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/client.js":
/*!***********************************************!*\
  !*** ./node_modules/langsmith/dist/client.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* binding */ Client),\n/* harmony export */   DEFAULT_BATCH_SIZE_LIMIT_BYTES: () => (/* binding */ DEFAULT_BATCH_SIZE_LIMIT_BYTES),\n/* harmony export */   Queue: () => (/* binding */ Queue),\n/* harmony export */   mergeRuntimeEnvIntoRunCreate: () => (/* binding */ mergeRuntimeEnvIntoRunCreate)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/async_caller.js */ \"(rsc)/./node_modules/langsmith/dist/utils/async_caller.js\");\n/* harmony import */ var _utils_messages_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/messages.js */ \"(rsc)/./node_modules/langsmith/dist/utils/messages.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/env.js */ \"(rsc)/./node_modules/langsmith/dist/utils/env.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./index.js */ \"(rsc)/./node_modules/langsmith/dist/index.js\");\n/* harmony import */ var _utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/_uuid.js */ \"(rsc)/./node_modules/langsmith/dist/utils/_uuid.js\");\n/* harmony import */ var _utils_warn_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/warn.js */ \"(rsc)/./node_modules/langsmith/dist/utils/warn.js\");\n/* harmony import */ var _utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/prompts.js */ \"(rsc)/./node_modules/langsmith/dist/utils/prompts.js\");\n/* harmony import */ var _utils_error_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/error.js */ \"(rsc)/./node_modules/langsmith/dist/utils/error.js\");\n/* harmony import */ var _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./singletons/fetch.js */ \"(rsc)/./node_modules/langsmith/dist/singletons/fetch.js\");\n/* harmony import */ var _utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/fast-safe-stringify/index.js */ \"(rsc)/./node_modules/langsmith/dist/utils/fast-safe-stringify/index.js\");\n\n\n\n\n\n\n\n\n\n\n\nfunction mergeRuntimeEnvIntoRunCreate(run) {\n    const runtimeEnv = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getRuntimeEnvironment)();\n    const envVars = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangChainEnvVarsMetadata)();\n    const extra = run.extra ?? {};\n    const metadata = extra.metadata;\n    run.extra = {\n        ...extra,\n        runtime: {\n            ...runtimeEnv,\n            ...extra?.runtime\n        },\n        metadata: {\n            ...envVars,\n            ...envVars.revision_id || run.revision_id ? {\n                revision_id: run.revision_id ?? envVars.revision_id\n            } : {},\n            ...metadata\n        }\n    };\n    return run;\n}\nconst getTracingSamplingRate = ()=>{\n    const samplingRateStr = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangSmithEnvironmentVariable)(\"TRACING_SAMPLING_RATE\");\n    if (samplingRateStr === undefined) {\n        return undefined;\n    }\n    const samplingRate = parseFloat(samplingRateStr);\n    if (samplingRate < 0 || samplingRate > 1) {\n        throw new Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);\n    }\n    return samplingRate;\n};\n// utility functions\nconst isLocalhost = (url)=>{\n    const strippedUrl = url.replace(\"http://\", \"\").replace(\"https://\", \"\");\n    const hostname = strippedUrl.split(\"/\")[0].split(\":\")[0];\n    return hostname === \"localhost\" || hostname === \"127.0.0.1\" || hostname === \"::1\";\n};\nasync function toArray(iterable) {\n    const result = [];\n    for await (const item of iterable){\n        result.push(item);\n    }\n    return result;\n}\nfunction trimQuotes(str) {\n    if (str === undefined) {\n        return undefined;\n    }\n    return str.trim().replace(/^\"(.*)\"$/, \"$1\").replace(/^'(.*)'$/, \"$1\");\n}\nconst handle429 = async (response)=>{\n    if (response?.status === 429) {\n        const retryAfter = parseInt(response.headers.get(\"retry-after\") ?? \"30\", 10) * 1000;\n        if (retryAfter > 0) {\n            await new Promise((resolve)=>setTimeout(resolve, retryAfter));\n            // Return directly after calling this check\n            return true;\n        }\n    }\n    // Fall back to existing status checks\n    return false;\n};\nclass Queue {\n    constructor(){\n        Object.defineProperty(this, \"items\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"sizeBytes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n    }\n    peek() {\n        return this.items[0];\n    }\n    push(item) {\n        let itemPromiseResolve;\n        const itemPromise = new Promise((resolve)=>{\n            // Setting itemPromiseResolve is synchronous with promise creation:\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise\n            itemPromiseResolve = resolve;\n        });\n        const size = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__.stringify)(item.item).length;\n        this.items.push({\n            action: item.action,\n            payload: item.item,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            itemPromiseResolve: itemPromiseResolve,\n            itemPromise,\n            size\n        });\n        this.sizeBytes += size;\n        return itemPromise;\n    }\n    pop(upToSizeBytes) {\n        if (upToSizeBytes < 1) {\n            throw new Error(\"Number of bytes to pop off may not be less than 1.\");\n        }\n        const popped = [];\n        let poppedSizeBytes = 0;\n        // Pop items until we reach or exceed the size limit\n        while(poppedSizeBytes + (this.peek()?.size ?? 0) < upToSizeBytes && this.items.length > 0){\n            const item = this.items.shift();\n            if (item) {\n                popped.push(item);\n                poppedSizeBytes += item.size;\n                this.sizeBytes -= item.size;\n            }\n        }\n        // If there is an item on the queue we were unable to pop,\n        // just return it as a single batch.\n        if (popped.length === 0 && this.items.length > 0) {\n            const item = this.items.shift();\n            popped.push(item);\n            poppedSizeBytes += item.size;\n            this.sizeBytes -= item.size;\n        }\n        return [\n            popped.map((it)=>({\n                    action: it.action,\n                    item: it.payload\n                })),\n            ()=>popped.forEach((it)=>it.itemPromiseResolve())\n        ];\n    }\n}\n// 20 MB\nconst DEFAULT_BATCH_SIZE_LIMIT_BYTES = 20971520;\nconst SERVER_INFO_REQUEST_TIMEOUT = 1000;\nclass Client {\n    constructor(config = {}){\n        Object.defineProperty(this, \"apiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"webUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"batchIngestCaller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"timeout_ms\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_tenantId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n        Object.defineProperty(this, \"hideInputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"hideOutputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tracingSampleRate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"filteredPostUuids\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Set()\n        });\n        Object.defineProperty(this, \"autoBatchTracing\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"autoBatchQueue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Queue()\n        });\n        Object.defineProperty(this, \"autoBatchTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"autoBatchInitialDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 250\n        });\n        Object.defineProperty(this, \"autoBatchAggregationDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 50\n        });\n        Object.defineProperty(this, \"batchSizeBytesLimit\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fetchOptions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"settings\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"blockOnRootRunFinalization\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"_serverInfo\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"_getServerInfoPromise\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const defaultConfig = Client.getDefaultClientConfig();\n        this.tracingSampleRate = getTracingSamplingRate();\n        this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? \"\";\n        if (this.apiUrl.endsWith(\"/\")) {\n            this.apiUrl = this.apiUrl.slice(0, -1);\n        }\n        this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);\n        this.webUrl = trimQuotes(config.webUrl ?? defaultConfig.webUrl);\n        if (this.webUrl?.endsWith(\"/\")) {\n            this.webUrl = this.webUrl.slice(0, -1);\n        }\n        this.timeout_ms = config.timeout_ms ?? 12000;\n        this.caller = new _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_0__.AsyncCaller(config.callerOptions ?? {});\n        this.batchIngestCaller = new _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_0__.AsyncCaller({\n            ...config.callerOptions ?? {},\n            onFailedResponseHook: handle429\n        });\n        this.hideInputs = config.hideInputs ?? config.anonymizer ?? defaultConfig.hideInputs;\n        this.hideOutputs = config.hideOutputs ?? config.anonymizer ?? defaultConfig.hideOutputs;\n        this.autoBatchTracing = config.autoBatchTracing ?? this.autoBatchTracing;\n        this.blockOnRootRunFinalization = config.blockOnRootRunFinalization ?? this.blockOnRootRunFinalization;\n        this.batchSizeBytesLimit = config.batchSizeBytesLimit;\n        this.fetchOptions = config.fetchOptions || {};\n    }\n    static getDefaultClientConfig() {\n        const apiKey = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangSmithEnvironmentVariable)(\"API_KEY\");\n        const apiUrl = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangSmithEnvironmentVariable)(\"ENDPOINT\") ?? \"https://api.smith.langchain.com\";\n        const hideInputs = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangSmithEnvironmentVariable)(\"HIDE_INPUTS\") === \"true\";\n        const hideOutputs = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangSmithEnvironmentVariable)(\"HIDE_OUTPUTS\") === \"true\";\n        return {\n            apiUrl: apiUrl,\n            apiKey: apiKey,\n            webUrl: undefined,\n            hideInputs: hideInputs,\n            hideOutputs: hideOutputs\n        };\n    }\n    getHostUrl() {\n        if (this.webUrl) {\n            return this.webUrl;\n        } else if (isLocalhost(this.apiUrl)) {\n            this.webUrl = \"http://localhost:3000\";\n            return this.webUrl;\n        } else if (this.apiUrl.includes(\"/api\") && !this.apiUrl.split(\".\", 1)[0].endsWith(\"api\")) {\n            this.webUrl = this.apiUrl.replace(\"/api\", \"\");\n            return this.webUrl;\n        } else if (this.apiUrl.split(\".\", 1)[0].includes(\"dev\")) {\n            this.webUrl = \"https://dev.smith.langchain.com\";\n            return this.webUrl;\n        } else if (this.apiUrl.split(\".\", 1)[0].includes(\"eu\")) {\n            this.webUrl = \"https://eu.smith.langchain.com\";\n            return this.webUrl;\n        } else {\n            this.webUrl = \"https://smith.langchain.com\";\n            return this.webUrl;\n        }\n    }\n    get headers() {\n        const headers = {\n            \"User-Agent\": `langsmith-js/${_index_js__WEBPACK_IMPORTED_MODULE_3__.__version__}`\n        };\n        if (this.apiKey) {\n            headers[\"x-api-key\"] = `${this.apiKey}`;\n        }\n        return headers;\n    }\n    processInputs(inputs) {\n        if (this.hideInputs === false) {\n            return inputs;\n        }\n        if (this.hideInputs === true) {\n            return {};\n        }\n        if (typeof this.hideInputs === \"function\") {\n            return this.hideInputs(inputs);\n        }\n        return inputs;\n    }\n    processOutputs(outputs) {\n        if (this.hideOutputs === false) {\n            return outputs;\n        }\n        if (this.hideOutputs === true) {\n            return {};\n        }\n        if (typeof this.hideOutputs === \"function\") {\n            return this.hideOutputs(outputs);\n        }\n        return outputs;\n    }\n    prepareRunCreateOrUpdateInputs(run) {\n        const runParams = {\n            ...run\n        };\n        if (runParams.inputs !== undefined) {\n            runParams.inputs = this.processInputs(runParams.inputs);\n        }\n        if (runParams.outputs !== undefined) {\n            runParams.outputs = this.processOutputs(runParams.outputs);\n        }\n        return runParams;\n    }\n    async _getResponse(path, queryParams) {\n        const paramsString = queryParams?.toString() ?? \"\";\n        const url = `${this.apiUrl}${path}?${paramsString}`;\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), url, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, `Failed to fetch ${path}`);\n        return response;\n    }\n    async _get(path, queryParams) {\n        const response = await this._getResponse(path, queryParams);\n        return response.json();\n    }\n    async *_getPaginated(path, queryParams = new URLSearchParams(), transform) {\n        let offset = Number(queryParams.get(\"offset\")) || 0;\n        const limit = Number(queryParams.get(\"limit\")) || 100;\n        while(true){\n            queryParams.set(\"offset\", String(offset));\n            queryParams.set(\"limit\", String(limit));\n            const url = `${this.apiUrl}${path}?${queryParams}`;\n            const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), url, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, `Failed to fetch ${path}`);\n            const items = transform ? transform(await response.json()) : await response.json();\n            if (items.length === 0) {\n                break;\n            }\n            yield items;\n            if (items.length < limit) {\n                break;\n            }\n            offset += items.length;\n        }\n    }\n    async *_getCursorPaginatedList(path, body = null, requestMethod = \"POST\", dataKey = \"runs\") {\n        const bodyParams = body ? {\n            ...body\n        } : {};\n        while(true){\n            const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}${path}`, {\n                method: requestMethod,\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\"\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: JSON.stringify(bodyParams)\n            });\n            const responseBody = await response.json();\n            if (!responseBody) {\n                break;\n            }\n            if (!responseBody[dataKey]) {\n                break;\n            }\n            yield responseBody[dataKey];\n            const cursors = responseBody.cursors;\n            if (!cursors) {\n                break;\n            }\n            if (!cursors.next) {\n                break;\n            }\n            bodyParams.cursor = cursors.next;\n        }\n    }\n    _filterForSampling(runs, patch = false) {\n        if (this.tracingSampleRate === undefined) {\n            return runs;\n        }\n        if (patch) {\n            const sampled = [];\n            for (const run of runs){\n                if (!this.filteredPostUuids.has(run.id)) {\n                    sampled.push(run);\n                } else {\n                    this.filteredPostUuids.delete(run.id);\n                }\n            }\n            return sampled;\n        } else {\n            const sampled = [];\n            for (const run of runs){\n                if (run.id !== run.trace_id && !this.filteredPostUuids.has(run.trace_id) || Math.random() < this.tracingSampleRate) {\n                    sampled.push(run);\n                } else {\n                    this.filteredPostUuids.add(run.id);\n                }\n            }\n            return sampled;\n        }\n    }\n    async _getBatchSizeLimitBytes() {\n        const serverInfo = await this._ensureServerInfo();\n        return this.batchSizeBytesLimit ?? serverInfo.batch_ingest_config?.size_limit_bytes ?? DEFAULT_BATCH_SIZE_LIMIT_BYTES;\n    }\n    async drainAutoBatchQueue() {\n        while(this.autoBatchQueue.items.length >= 0){\n            const [batch, done] = this.autoBatchQueue.pop(await this._getBatchSizeLimitBytes());\n            if (!batch.length) {\n                done();\n                return;\n            }\n            try {\n                const ingestParams = {\n                    runCreates: batch.filter((item)=>item.action === \"create\").map((item)=>item.item),\n                    runUpdates: batch.filter((item)=>item.action === \"update\").map((item)=>item.item)\n                };\n                const serverInfo = await this._ensureServerInfo();\n                if (serverInfo?.batch_ingest_config?.use_multipart_endpoint) {\n                    await this.multipartIngestRuns(ingestParams);\n                } else {\n                    await this.batchIngestRuns(ingestParams);\n                }\n            } finally{\n                done();\n            }\n        }\n    }\n    async processRunOperation(item, immediatelyTriggerBatch) {\n        const oldTimeout = this.autoBatchTimeout;\n        clearTimeout(this.autoBatchTimeout);\n        this.autoBatchTimeout = undefined;\n        if (item.action === \"create\") {\n            item.item = mergeRuntimeEnvIntoRunCreate(item.item);\n        }\n        const itemPromise = this.autoBatchQueue.push(item);\n        const sizeLimitBytes = await this._getBatchSizeLimitBytes();\n        if (immediatelyTriggerBatch || this.autoBatchQueue.sizeBytes > sizeLimitBytes) {\n            await this.drainAutoBatchQueue().catch(console.error);\n        }\n        if (this.autoBatchQueue.items.length > 0) {\n            this.autoBatchTimeout = setTimeout(()=>{\n                this.autoBatchTimeout = undefined;\n                // This error would happen in the background and is uncatchable\n                // from the outside. So just log instead.\n                void this.drainAutoBatchQueue().catch(console.error);\n            }, oldTimeout ? this.autoBatchAggregationDelayMs : this.autoBatchInitialDelayMs);\n        }\n        return itemPromise;\n    }\n    async _getServerInfo() {\n        const response = await (0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)()(`${this.apiUrl}/info`, {\n            method: \"GET\",\n            headers: {\n                Accept: \"application/json\"\n            },\n            signal: AbortSignal.timeout(SERVER_INFO_REQUEST_TIMEOUT),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"get server info\");\n        return response.json();\n    }\n    async _ensureServerInfo() {\n        if (this._getServerInfoPromise === undefined) {\n            this._getServerInfoPromise = (async ()=>{\n                if (this._serverInfo === undefined) {\n                    try {\n                        this._serverInfo = await this._getServerInfo();\n                    } catch (e) {\n                        console.warn(`[WARNING]: LangSmith failed to fetch info on supported operations. Falling back to single calls and default limits.`);\n                    }\n                }\n                return this._serverInfo ?? {};\n            })();\n        }\n        return this._getServerInfoPromise.then((serverInfo)=>{\n            if (this._serverInfo === undefined) {\n                this._getServerInfoPromise = undefined;\n            }\n            return serverInfo;\n        });\n    }\n    async _getSettings() {\n        if (!this.settings) {\n            this.settings = this._get(\"/settings\");\n        }\n        return await this.settings;\n    }\n    async createRun(run) {\n        if (!this._filterForSampling([\n            run\n        ]).length) {\n            return;\n        }\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\"\n        };\n        const session_name = run.project_name;\n        delete run.project_name;\n        const runCreate = this.prepareRunCreateOrUpdateInputs({\n            session_name,\n            ...run,\n            start_time: run.start_time ?? Date.now()\n        });\n        if (this.autoBatchTracing && runCreate.trace_id !== undefined && runCreate.dotted_order !== undefined) {\n            void this.processRunOperation({\n                action: \"create\",\n                item: runCreate\n            }).catch(console.error);\n            return;\n        }\n        const mergedRunCreateParam = mergeRuntimeEnvIntoRunCreate(runCreate);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/runs`, {\n            method: \"POST\",\n            headers,\n            body: (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__.stringify)(mergedRunCreateParam),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"create run\", true);\n    }\n    /**\n     * Batch ingest/upsert multiple runs in the Langsmith system.\n     * @param runs\n     */ async batchIngestRuns({ runCreates, runUpdates }) {\n        if (runCreates === undefined && runUpdates === undefined) {\n            return;\n        }\n        let preparedCreateParams = runCreates?.map((create)=>this.prepareRunCreateOrUpdateInputs(create)) ?? [];\n        let preparedUpdateParams = runUpdates?.map((update)=>this.prepareRunCreateOrUpdateInputs(update)) ?? [];\n        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n            const createById = preparedCreateParams.reduce((params, run)=>{\n                if (!run.id) {\n                    return params;\n                }\n                params[run.id] = run;\n                return params;\n            }, {});\n            const standaloneUpdates = [];\n            for (const updateParam of preparedUpdateParams){\n                if (updateParam.id !== undefined && createById[updateParam.id]) {\n                    createById[updateParam.id] = {\n                        ...createById[updateParam.id],\n                        ...updateParam\n                    };\n                } else {\n                    standaloneUpdates.push(updateParam);\n                }\n            }\n            preparedCreateParams = Object.values(createById);\n            preparedUpdateParams = standaloneUpdates;\n        }\n        const rawBatch = {\n            post: this._filterForSampling(preparedCreateParams),\n            patch: this._filterForSampling(preparedUpdateParams, true)\n        };\n        if (!rawBatch.post.length && !rawBatch.patch.length) {\n            return;\n        }\n        const serverInfo = await this._ensureServerInfo();\n        if (serverInfo.version === undefined) {\n            this.autoBatchTracing = false;\n            for (const preparedCreateParam of rawBatch.post){\n                await this.createRun(preparedCreateParam);\n            }\n            for (const preparedUpdateParam of rawBatch.patch){\n                if (preparedUpdateParam.id !== undefined) {\n                    await this.updateRun(preparedUpdateParam.id, preparedUpdateParam);\n                }\n            }\n            return;\n        }\n        const batchChunks = {\n            post: [],\n            patch: []\n        };\n        for (const k of [\n            \"post\",\n            \"patch\"\n        ]){\n            const key = k;\n            const batchItems = rawBatch[key].reverse();\n            let batchItem = batchItems.pop();\n            while(batchItem !== undefined){\n                batchChunks[key].push(batchItem);\n                batchItem = batchItems.pop();\n            }\n        }\n        if (batchChunks.post.length > 0 || batchChunks.patch.length > 0) {\n            await this._postBatchIngestRuns((0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__.stringify)(batchChunks));\n        }\n    }\n    async _postBatchIngestRuns(body) {\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\",\n            Accept: \"application/json\"\n        };\n        const response = await this.batchIngestCaller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/runs/batch`, {\n            method: \"POST\",\n            headers,\n            body: body,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"batch create run\", true);\n    }\n    /**\n     * Batch ingest/upsert multiple runs in the Langsmith system.\n     * @param runs\n     */ async multipartIngestRuns({ runCreates, runUpdates }) {\n        if (runCreates === undefined && runUpdates === undefined) {\n            return;\n        }\n        // transform and convert to dicts\n        const allAttachments = {};\n        let preparedCreateParams = [];\n        for (const create of runCreates ?? []){\n            const preparedCreate = this.prepareRunCreateOrUpdateInputs(create);\n            if (preparedCreate.id !== undefined && preparedCreate.attachments !== undefined) {\n                allAttachments[preparedCreate.id] = preparedCreate.attachments;\n            }\n            delete preparedCreate.attachments;\n            preparedCreateParams.push(preparedCreate);\n        }\n        let preparedUpdateParams = [];\n        for (const update of runUpdates ?? []){\n            preparedUpdateParams.push(this.prepareRunCreateOrUpdateInputs(update));\n        }\n        // require trace_id and dotted_order\n        const invalidRunCreate = preparedCreateParams.find((runCreate)=>{\n            return runCreate.trace_id === undefined || runCreate.dotted_order === undefined;\n        });\n        if (invalidRunCreate !== undefined) {\n            throw new Error(`Multipart ingest requires \"trace_id\" and \"dotted_order\" to be set when creating a run`);\n        }\n        const invalidRunUpdate = preparedUpdateParams.find((runUpdate)=>{\n            return runUpdate.trace_id === undefined || runUpdate.dotted_order === undefined;\n        });\n        if (invalidRunUpdate !== undefined) {\n            throw new Error(`Multipart ingest requires \"trace_id\" and \"dotted_order\" to be set when updating a run`);\n        }\n        // combine post and patch dicts where possible\n        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n            const createById = preparedCreateParams.reduce((params, run)=>{\n                if (!run.id) {\n                    return params;\n                }\n                params[run.id] = run;\n                return params;\n            }, {});\n            const standaloneUpdates = [];\n            for (const updateParam of preparedUpdateParams){\n                if (updateParam.id !== undefined && createById[updateParam.id]) {\n                    createById[updateParam.id] = {\n                        ...createById[updateParam.id],\n                        ...updateParam\n                    };\n                } else {\n                    standaloneUpdates.push(updateParam);\n                }\n            }\n            preparedCreateParams = Object.values(createById);\n            preparedUpdateParams = standaloneUpdates;\n        }\n        if (preparedCreateParams.length === 0 && preparedUpdateParams.length === 0) {\n            return;\n        }\n        // send the runs in multipart requests\n        const accumulatedContext = [];\n        const accumulatedParts = [];\n        for (const [method, payloads] of [\n            [\n                \"post\",\n                preparedCreateParams\n            ],\n            [\n                \"patch\",\n                preparedUpdateParams\n            ]\n        ]){\n            for (const originalPayload of payloads){\n                // collect fields to be sent as separate parts\n                const { inputs, outputs, events, ...payload } = originalPayload;\n                const fields = {\n                    inputs,\n                    outputs,\n                    events\n                };\n                // encode the main run payload\n                const stringifiedPayload = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__.stringify)(payload);\n                accumulatedParts.push({\n                    name: `${method}.${payload.id}`,\n                    payload: new Blob([\n                        stringifiedPayload\n                    ], {\n                        type: `application/json; length=${stringifiedPayload.length}`\n                    })\n                });\n                // encode the fields we collected\n                for (const [key, value] of Object.entries(fields)){\n                    if (value === undefined) {\n                        continue;\n                    }\n                    const stringifiedValue = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__.stringify)(value);\n                    accumulatedParts.push({\n                        name: `${method}.${payload.id}.${key}`,\n                        payload: new Blob([\n                            stringifiedValue\n                        ], {\n                            type: `application/json; length=${stringifiedValue.length}`\n                        })\n                    });\n                }\n                // encode the attachments\n                if (payload.id !== undefined) {\n                    const attachments = allAttachments[payload.id];\n                    if (attachments) {\n                        delete allAttachments[payload.id];\n                        for (const [name, [contentType, content]] of Object.entries(attachments)){\n                            accumulatedParts.push({\n                                name: `attachment.${payload.id}.${name}`,\n                                payload: new Blob([\n                                    content\n                                ], {\n                                    type: `${contentType}; length=${content.length}`\n                                })\n                            });\n                        }\n                    }\n                }\n                // compute context\n                accumulatedContext.push(`trace=${payload.trace_id},id=${payload.id}`);\n            }\n        }\n        await this._sendMultipartRequest(accumulatedParts, accumulatedContext.join(\"; \"));\n    }\n    async _sendMultipartRequest(parts, context) {\n        try {\n            const formData = new FormData();\n            for (const part of parts){\n                formData.append(part.name, part.payload);\n            }\n            await this.batchIngestCaller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/runs/multipart`, {\n                method: \"POST\",\n                headers: {\n                    ...this.headers\n                },\n                body: formData,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions\n            });\n        } catch (e) {\n            let errorMessage = \"Failed to multipart ingest runs\";\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (e instanceof Error) {\n                errorMessage += `: ${e.stack || e.message}`;\n            } else {\n                errorMessage += `: ${String(e)}`;\n            }\n            console.warn(`${errorMessage.trim()}\\n\\nContext: ${context}`);\n        }\n    }\n    async updateRun(runId, run) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(runId);\n        if (run.inputs) {\n            run.inputs = this.processInputs(run.inputs);\n        }\n        if (run.outputs) {\n            run.outputs = this.processOutputs(run.outputs);\n        }\n        // TODO: Untangle types\n        const data = {\n            ...run,\n            id: runId\n        };\n        if (!this._filterForSampling([\n            data\n        ], true).length) {\n            return;\n        }\n        if (this.autoBatchTracing && data.trace_id !== undefined && data.dotted_order !== undefined) {\n            if (run.end_time !== undefined && data.parent_run_id === undefined && this.blockOnRootRunFinalization) {\n                // Trigger a batch as soon as a root trace ends and block to ensure trace finishes\n                // in serverless environments.\n                await this.processRunOperation({\n                    action: \"update\",\n                    item: data\n                }, true);\n                return;\n            } else {\n                void this.processRunOperation({\n                    action: \"update\",\n                    item: data\n                }).catch(console.error);\n            }\n            return;\n        }\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\"\n        };\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/runs/${runId}`, {\n            method: \"PATCH\",\n            headers,\n            body: (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_9__.stringify)(run),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"update run\", true);\n    }\n    async readRun(runId, { loadChildRuns } = {\n        loadChildRuns: false\n    }) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(runId);\n        let run = await this._get(`/runs/${runId}`);\n        if (loadChildRuns && run.child_run_ids) {\n            run = await this._loadChildRuns(run);\n        }\n        return run;\n    }\n    async getRunUrl({ runId, run, projectOpts }) {\n        if (run !== undefined) {\n            let sessionId;\n            if (run.session_id) {\n                sessionId = run.session_id;\n            } else if (projectOpts?.projectName) {\n                sessionId = (await this.readProject({\n                    projectName: projectOpts?.projectName\n                })).id;\n            } else if (projectOpts?.projectId) {\n                sessionId = projectOpts?.projectId;\n            } else {\n                const project = await this.readProject({\n                    projectName: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_2__.getLangSmithEnvironmentVariable)(\"PROJECT\") || \"default\"\n                });\n                sessionId = project.id;\n            }\n            const tenantId = await this._getTenantId();\n            return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;\n        } else if (runId !== undefined) {\n            const run_ = await this.readRun(runId);\n            if (!run_.app_path) {\n                throw new Error(`Run ${runId} has no app_path`);\n            }\n            const baseUrl = this.getHostUrl();\n            return `${baseUrl}${run_.app_path}`;\n        } else {\n            throw new Error(\"Must provide either runId or run\");\n        }\n    }\n    async _loadChildRuns(run) {\n        const childRuns = await toArray(this.listRuns({\n            id: run.child_run_ids\n        }));\n        const treemap = {};\n        const runs = {};\n        // TODO: make dotted order required when the migration finishes\n        childRuns.sort((a, b)=>(a?.dotted_order ?? \"\").localeCompare(b?.dotted_order ?? \"\"));\n        for (const childRun of childRuns){\n            if (childRun.parent_run_id === null || childRun.parent_run_id === undefined) {\n                throw new Error(`Child run ${childRun.id} has no parent`);\n            }\n            if (!(childRun.parent_run_id in treemap)) {\n                treemap[childRun.parent_run_id] = [];\n            }\n            treemap[childRun.parent_run_id].push(childRun);\n            runs[childRun.id] = childRun;\n        }\n        run.child_runs = treemap[run.id] || [];\n        for(const runId in treemap){\n            if (runId !== run.id) {\n                runs[runId].child_runs = treemap[runId];\n            }\n        }\n        return run;\n    }\n    /**\n     * List runs from the LangSmith server.\n     * @param projectId - The ID of the project to filter by.\n     * @param projectName - The name of the project to filter by.\n     * @param parentRunId - The ID of the parent run to filter by.\n     * @param traceId - The ID of the trace to filter by.\n     * @param referenceExampleId - The ID of the reference example to filter by.\n     * @param startTime - The start time to filter by.\n     * @param isRoot - Indicates whether to only return root runs.\n     * @param runType - The run type to filter by.\n     * @param error - Indicates whether to filter by error runs.\n     * @param id - The ID of the run to filter by.\n     * @param query - The query string to filter by.\n     * @param filter - The filter string to apply to the run spans.\n     * @param traceFilter - The filter string to apply on the root run of the trace.\n     * @param limit - The maximum number of runs to retrieve.\n     * @returns {AsyncIterable<Run>} - The runs.\n     *\n     * @example\n     * // List all runs in a project\n     * const projectRuns = client.listRuns({ projectName: \"<your_project>\" });\n     *\n     * @example\n     * // List LLM and Chat runs in the last 24 hours\n     * const todaysLLMRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),\n     *   run_type: \"llm\",\n     * });\n     *\n     * @example\n     * // List traces in a project\n     * const rootRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   execution_order: 1,\n     * });\n     *\n     * @example\n     * // List runs without errors\n     * const correctRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   error: false,\n     * });\n     *\n     * @example\n     * // List runs by run ID\n     * const runIds = [\n     *   \"a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836\",\n     *   \"9398e6be-964f-4aa4-8ae9-ad78cd4b7074\",\n     * ];\n     * const selectedRuns = client.listRuns({ run_ids: runIds });\n     *\n     * @example\n     * // List all \"chain\" type runs that took more than 10 seconds and had `total_tokens` greater than 5000\n     * const chainRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(eq(run_type, \"chain\"), gt(latency, 10), gt(total_tokens, 5000))',\n     * });\n     *\n     * @example\n     * // List all runs called \"extractor\" whose root of the trace was assigned feedback \"user_score\" score of 1\n     * const goodExtractorRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'eq(name, \"extractor\")',\n     *   traceFilter: 'and(eq(feedback_key, \"user_score\"), eq(feedback_score, 1))',\n     * });\n     *\n     * @example\n     * // List all runs that started after a specific timestamp and either have \"error\" not equal to null or a \"Correctness\" feedback score equal to 0\n     * const complexRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(gt(start_time, \"2023-07-15T12:34:56Z\"), or(neq(error, null), and(eq(feedback_key, \"Correctness\"), eq(feedback_score, 0.0))))',\n     * });\n     *\n     * @example\n     * // List all runs where `tags` include \"experimental\" or \"beta\" and `latency` is greater than 2 seconds\n     * const taggedRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(or(has(tags, \"experimental\"), has(tags, \"beta\")), gt(latency, 2))',\n     * });\n     */ async *listRuns(props) {\n        const { projectId, projectName, parentRunId, traceId, referenceExampleId, startTime, executionOrder, isRoot, runType, error, id, query, filter, traceFilter, treeFilter, limit, select } = props;\n        let projectIds = [];\n        if (projectId) {\n            projectIds = Array.isArray(projectId) ? projectId : [\n                projectId\n            ];\n        }\n        if (projectName) {\n            const projectNames = Array.isArray(projectName) ? projectName : [\n                projectName\n            ];\n            const projectIds_ = await Promise.all(projectNames.map((name)=>this.readProject({\n                    projectName: name\n                }).then((project)=>project.id)));\n            projectIds.push(...projectIds_);\n        }\n        const default_select = [\n            \"app_path\",\n            \"child_run_ids\",\n            \"completion_cost\",\n            \"completion_tokens\",\n            \"dotted_order\",\n            \"end_time\",\n            \"error\",\n            \"events\",\n            \"extra\",\n            \"feedback_stats\",\n            \"first_token_time\",\n            \"id\",\n            \"inputs\",\n            \"name\",\n            \"outputs\",\n            \"parent_run_id\",\n            \"parent_run_ids\",\n            \"prompt_cost\",\n            \"prompt_tokens\",\n            \"reference_example_id\",\n            \"run_type\",\n            \"session_id\",\n            \"start_time\",\n            \"status\",\n            \"tags\",\n            \"total_cost\",\n            \"total_tokens\",\n            \"trace_id\"\n        ];\n        const body = {\n            session: projectIds.length ? projectIds : null,\n            run_type: runType,\n            reference_example: referenceExampleId,\n            query,\n            filter,\n            trace_filter: traceFilter,\n            tree_filter: treeFilter,\n            execution_order: executionOrder,\n            parent_run: parentRunId,\n            start_time: startTime ? startTime.toISOString() : null,\n            error,\n            id,\n            limit,\n            trace: traceId,\n            select: select ? select : default_select,\n            is_root: isRoot\n        };\n        let runsYielded = 0;\n        for await (const runs of this._getCursorPaginatedList(\"/runs/query\", body)){\n            if (limit) {\n                if (runsYielded >= limit) {\n                    break;\n                }\n                if (runs.length + runsYielded > limit) {\n                    const newRuns = runs.slice(0, limit - runsYielded);\n                    yield* newRuns;\n                    break;\n                }\n                runsYielded += runs.length;\n                yield* runs;\n            } else {\n                yield* runs;\n            }\n        }\n    }\n    async getRunStats({ id, trace, parentRun, runType, projectNames, projectIds, referenceExampleIds, startTime, endTime, error, query, filter, traceFilter, treeFilter, isRoot, dataSourceType }) {\n        let projectIds_ = projectIds || [];\n        if (projectNames) {\n            projectIds_ = [\n                ...projectIds || [],\n                ...await Promise.all(projectNames.map((name)=>this.readProject({\n                        projectName: name\n                    }).then((project)=>project.id)))\n            ];\n        }\n        const payload = {\n            id,\n            trace,\n            parent_run: parentRun,\n            run_type: runType,\n            session: projectIds_,\n            reference_example: referenceExampleIds,\n            start_time: startTime,\n            end_time: endTime,\n            error,\n            query,\n            filter,\n            trace_filter: traceFilter,\n            tree_filter: treeFilter,\n            is_root: isRoot,\n            data_source_type: dataSourceType\n        };\n        // Remove undefined values from the payload\n        const filteredPayload = Object.fromEntries(Object.entries(payload).filter(([_, value])=>value !== undefined));\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/runs/stats`, {\n            method: \"POST\",\n            headers: this.headers,\n            body: JSON.stringify(filteredPayload),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        const result = await response.json();\n        return result;\n    }\n    async shareRun(runId, { shareId } = {}) {\n        const data = {\n            run_id: runId,\n            share_token: shareId || uuid__WEBPACK_IMPORTED_MODULE_10__[\"default\"]()\n        };\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(runId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"PUT\",\n            headers: this.headers,\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            throw new Error(\"Invalid response from server\");\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async unshareRun(runId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(runId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"unshare run\", true);\n    }\n    async readRunSharedLink(runId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(runId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            return undefined;\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async listSharedRuns(shareToken, { runIds } = {}) {\n        const queryParams = new URLSearchParams({\n            share_token: shareToken\n        });\n        if (runIds !== undefined) {\n            for (const runId of runIds){\n                queryParams.append(\"id\", runId);\n            }\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(shareToken);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        const runs = await response.json();\n        return runs;\n    }\n    async readDatasetSharedSchema(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId = dataset.id;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async shareDataset(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId = dataset.id;\n        }\n        const data = {\n            dataset_id: datasetId\n        };\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"PUT\",\n            headers: this.headers,\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async unshareDataset(datasetId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"unshare dataset\", true);\n    }\n    async readSharedDataset(shareToken) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(shareToken);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/public/${shareToken}/datasets`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        const dataset = await response.json();\n        return dataset;\n    }\n    /**\n     * Get shared examples.\n     *\n     * @param {string} shareToken The share token to get examples for. A share token is the UUID (or LangSmith URL, including UUID) generated when explicitly marking an example as public.\n     * @param {Object} [options] Additional options for listing the examples.\n     * @param {string[] | undefined} [options.exampleIds] A list of example IDs to filter by.\n     * @returns {Promise<Example[]>} The shared examples.\n     */ async listSharedExamples(shareToken, options) {\n        const params = {};\n        if (options?.exampleIds) {\n            params.id = options.exampleIds;\n        }\n        const urlParams = new URLSearchParams();\n        Object.entries(params).forEach(([key, value])=>{\n            if (Array.isArray(value)) {\n                value.forEach((v)=>urlParams.append(key, v));\n            } else {\n                urlParams.append(key, value);\n            }\n        });\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/public/${shareToken}/examples?${urlParams.toString()}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        const result = await response.json();\n        if (!response.ok) {\n            if (\"detail\" in result) {\n                throw new Error(`Failed to list shared examples.\\nStatus: ${response.status}\\nMessage: ${result.detail.join(\"\\n\")}`);\n            }\n            throw new Error(`Failed to list shared examples: ${response.status} ${response.statusText}`);\n        }\n        return result.map((example)=>({\n                ...example,\n                _hostUrl: this.getHostUrl()\n            }));\n    }\n    async createProject({ projectName, description = null, metadata = null, upsert = false, projectExtra = null, referenceDatasetId = null }) {\n        const upsert_ = upsert ? `?upsert=true` : \"\";\n        const endpoint = `${this.apiUrl}/sessions${upsert_}`;\n        const extra = projectExtra || {};\n        if (metadata) {\n            extra[\"metadata\"] = metadata;\n        }\n        const body = {\n            name: projectName,\n            extra,\n            description\n        };\n        if (referenceDatasetId !== null) {\n            body[\"reference_dataset_id\"] = referenceDatasetId;\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), endpoint, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"create project\");\n        const result = await response.json();\n        return result;\n    }\n    async updateProject(projectId, { name = null, description = null, metadata = null, projectExtra = null, endTime = null }) {\n        const endpoint = `${this.apiUrl}/sessions/${projectId}`;\n        let extra = projectExtra;\n        if (metadata) {\n            extra = {\n                ...extra || {},\n                metadata\n            };\n        }\n        const body = {\n            name,\n            extra,\n            description,\n            end_time: endTime ? new Date(endTime).toISOString() : null\n        };\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), endpoint, {\n            method: \"PATCH\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"update project\");\n        const result = await response.json();\n        return result;\n    }\n    async hasProject({ projectId, projectName }) {\n        // TODO: Add a head request\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        } else if (projectId !== undefined) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(projectId);\n            path += `/${projectId}`;\n        } else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        } else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}${path}?${params}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        // consume the response body to release the connection\n        // https://undici.nodejs.org/#/?id=garbage-collection\n        try {\n            const result = await response.json();\n            if (!response.ok) {\n                return false;\n            }\n            // If it's OK and we're querying by name, need to check the list is not empty\n            if (Array.isArray(result)) {\n                return result.length > 0;\n            }\n            // projectId querying\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n    async readProject({ projectId, projectName, includeStats }) {\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        } else if (projectId !== undefined) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(projectId);\n            path += `/${projectId}`;\n        } else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        } else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        if (includeStats !== undefined) {\n            params.append(\"include_stats\", includeStats.toString());\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);\n            }\n            result = response[0];\n        } else {\n            result = response;\n        }\n        return result;\n    }\n    async getProjectUrl({ projectId, projectName }) {\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide either projectName or projectId\");\n        }\n        const project = await this.readProject({\n            projectId,\n            projectName\n        });\n        const tenantId = await this._getTenantId();\n        return `${this.getHostUrl()}/o/${tenantId}/projects/p/${project.id}`;\n    }\n    async getDatasetUrl({ datasetId, datasetName }) {\n        if (datasetId === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const dataset = await this.readDataset({\n            datasetId,\n            datasetName\n        });\n        const tenantId = await this._getTenantId();\n        return `${this.getHostUrl()}/o/${tenantId}/datasets/${dataset.id}`;\n    }\n    async _getTenantId() {\n        if (this._tenantId !== null) {\n            return this._tenantId;\n        }\n        const queryParams = new URLSearchParams({\n            limit: \"1\"\n        });\n        for await (const projects of this._getPaginated(\"/sessions\", queryParams)){\n            this._tenantId = projects[0].tenant_id;\n            return projects[0].tenant_id;\n        }\n        throw new Error(\"No projects found to resolve tenant.\");\n    }\n    async *listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, referenceFree, metadata } = {}) {\n        const params = new URLSearchParams();\n        if (projectIds !== undefined) {\n            for (const projectId of projectIds){\n                params.append(\"id\", projectId);\n            }\n        }\n        if (name !== undefined) {\n            params.append(\"name\", name);\n        }\n        if (nameContains !== undefined) {\n            params.append(\"name_contains\", nameContains);\n        }\n        if (referenceDatasetId !== undefined) {\n            params.append(\"reference_dataset\", referenceDatasetId);\n        } else if (referenceDatasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName: referenceDatasetName\n            });\n            params.append(\"reference_dataset\", dataset.id);\n        }\n        if (referenceFree !== undefined) {\n            params.append(\"reference_free\", referenceFree.toString());\n        }\n        if (metadata !== undefined) {\n            params.append(\"metadata\", JSON.stringify(metadata));\n        }\n        for await (const projects of this._getPaginated(\"/sessions\", params)){\n            yield* projects;\n        }\n    }\n    async deleteProject({ projectId, projectName }) {\n        let projectId_;\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide projectName or projectId\");\n        } else if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        } else if (projectId === undefined) {\n            projectId_ = (await this.readProject({\n                projectName\n            })).id;\n        } else {\n            projectId_ = projectId;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(projectId_);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/sessions/${projectId_}`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, `delete session ${projectId_} (${projectName})`, true);\n    }\n    async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name }) {\n        const url = `${this.apiUrl}/datasets/upload`;\n        const formData = new FormData();\n        formData.append(\"file\", csvFile, fileName);\n        inputKeys.forEach((key)=>{\n            formData.append(\"input_keys\", key);\n        });\n        outputKeys.forEach((key)=>{\n            formData.append(\"output_keys\", key);\n        });\n        if (description) {\n            formData.append(\"description\", description);\n        }\n        if (dataType) {\n            formData.append(\"data_type\", dataType);\n        }\n        if (name) {\n            formData.append(\"name\", name);\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), url, {\n            method: \"POST\",\n            headers: this.headers,\n            body: formData,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"upload CSV\");\n        const result = await response.json();\n        return result;\n    }\n    async createDataset(name, { description, dataType, inputsSchema, outputsSchema, metadata } = {}) {\n        const body = {\n            name,\n            description,\n            extra: metadata ? {\n                metadata\n            } : undefined\n        };\n        if (dataType) {\n            body.data_type = dataType;\n        }\n        if (inputsSchema) {\n            body.inputs_schema_definition = inputsSchema;\n        }\n        if (outputsSchema) {\n            body.outputs_schema_definition = outputsSchema;\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/datasets`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"create dataset\");\n        const result = await response.json();\n        return result;\n    }\n    async readDataset({ datasetId, datasetName }) {\n        let path = \"/datasets\";\n        // limit to 1 result\n        const params = new URLSearchParams({\n            limit: \"1\"\n        });\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId !== undefined) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId);\n            path += `/${datasetId}`;\n        } else if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        } else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);\n            }\n            result = response[0];\n        } else {\n            result = response;\n        }\n        return result;\n    }\n    async hasDataset({ datasetId, datasetName }) {\n        try {\n            await this.readDataset({\n                datasetId,\n                datasetName\n            });\n            return true;\n        } catch (e) {\n            if (// eslint-disable-next-line no-instanceof/no-instanceof\n            e instanceof Error && e.message.toLocaleLowerCase().includes(\"not found\")) {\n                return false;\n            }\n            throw e;\n        }\n    }\n    async diffDatasetVersions({ datasetId, datasetName, fromVersion, toVersion }) {\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        } else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        }\n        const urlParams = new URLSearchParams({\n            from_version: typeof fromVersion === \"string\" ? fromVersion : fromVersion.toISOString(),\n            to_version: typeof toVersion === \"string\" ? toVersion : toVersion.toISOString()\n        });\n        const response = await this._get(`/datasets/${datasetId_}/versions/diff`, urlParams);\n        return response;\n    }\n    async readDatasetOpenaiFinetuning({ datasetId, datasetName }) {\n        const path = \"/datasets\";\n        if (datasetId !== undefined) {\n        // do nothing\n        } else if (datasetName !== undefined) {\n            datasetId = (await this.readDataset({\n                datasetName\n            })).id;\n        } else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);\n        const datasetText = await response.text();\n        const dataset = datasetText.trim().split(\"\\n\").map((line)=>JSON.parse(line));\n        return dataset;\n    }\n    async *listDatasets({ limit = 100, offset = 0, datasetIds, datasetName, datasetNameContains, metadata } = {}) {\n        const path = \"/datasets\";\n        const params = new URLSearchParams({\n            limit: limit.toString(),\n            offset: offset.toString()\n        });\n        if (datasetIds !== undefined) {\n            for (const id_ of datasetIds){\n                params.append(\"id\", id_);\n            }\n        }\n        if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        }\n        if (datasetNameContains !== undefined) {\n            params.append(\"name_contains\", datasetNameContains);\n        }\n        if (metadata !== undefined) {\n            params.append(\"metadata\", JSON.stringify(metadata));\n        }\n        for await (const datasets of this._getPaginated(path, params)){\n            yield* datasets;\n        }\n    }\n    /**\n     * Update a dataset\n     * @param props The dataset details to update\n     * @returns The updated dataset\n     */ async updateDataset(props) {\n        const { datasetId, datasetName, ...update } = props;\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const _datasetId = datasetId ?? (await this.readDataset({\n            datasetName\n        })).id;\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(_datasetId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/datasets/${_datasetId}`, {\n            method: \"PATCH\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(update),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"update dataset\");\n        return await response.json();\n    }\n    async deleteDataset({ datasetId, datasetName }) {\n        let path = \"/datasets\";\n        let datasetId_ = datasetId;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        }\n        if (datasetId_ !== undefined) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId_);\n            path += `/${datasetId_}`;\n        } else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, `delete ${path}`);\n        await response.json();\n    }\n    async indexDataset({ datasetId, datasetName, tag }) {\n        let datasetId_ = datasetId;\n        if (!datasetId_ && !datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        } else if (datasetId_ && datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (!datasetId_) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId_);\n        const data = {\n            tag: tag\n        };\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/datasets/${datasetId_}/index`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"index dataset\");\n        await response.json();\n    }\n    /**\n     * Lets you run a similarity search query on a dataset.\n     *\n     * Requires the dataset to be indexed. Please see the `indexDataset` method to set up indexing.\n     *\n     * @param inputs      The input on which to run the similarity search. Must have the\n     *                    same schema as the dataset.\n     *\n     * @param datasetId   The dataset to search for similar examples.\n     *\n     * @param limit       The maximum number of examples to return. Will return the top `limit` most\n     *                    similar examples in order of most similar to least similar. If no similar\n     *                    examples are found, random examples will be returned.\n     *\n     * @param filter      A filter string to apply to the search. Only examples will be returned that\n     *                    match the filter string. Some examples of filters\n     *\n     *                    - eq(metadata.mykey, \"value\")\n     *                    - and(neq(metadata.my.nested.key, \"value\"), neq(metadata.mykey, \"value\"))\n     *                    - or(eq(metadata.mykey, \"value\"), eq(metadata.mykey, \"othervalue\"))\n     *\n     * @returns           A list of similar examples.\n     *\n     *\n     * @example\n     * dataset_id = \"123e4567-e89b-12d3-a456-426614174000\"\n     * inputs = {\"text\": \"How many people live in Berlin?\"}\n     * limit = 5\n     * examples = await client.similarExamples(inputs, dataset_id, limit)\n     */ async similarExamples(inputs, datasetId, limit, { filter } = {}) {\n        const data = {\n            limit: limit,\n            inputs: inputs\n        };\n        if (filter !== undefined) {\n            data[\"filter\"] = filter;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/datasets/${datasetId}/search`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"fetch similar examples\");\n        const result = await response.json();\n        return result[\"examples\"];\n    }\n    async createExample(inputs, outputs, { datasetId, datasetName, createdAt, exampleId, metadata, split, sourceRunId }) {\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        } else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        }\n        const createdAt_ = createdAt || new Date();\n        const data = {\n            dataset_id: datasetId_,\n            inputs,\n            outputs,\n            created_at: createdAt_?.toISOString(),\n            id: exampleId,\n            metadata,\n            split,\n            source_run_id: sourceRunId\n        };\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/examples`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"create example\");\n        const result = await response.json();\n        return result;\n    }\n    async createExamples(props) {\n        const { inputs, outputs, metadata, sourceRunIds, exampleIds, datasetId, datasetName } = props;\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        } else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        }\n        const formattedExamples = inputs.map((input, idx)=>{\n            return {\n                dataset_id: datasetId_,\n                inputs: input,\n                outputs: outputs ? outputs[idx] : undefined,\n                metadata: metadata ? metadata[idx] : undefined,\n                split: props.splits ? props.splits[idx] : undefined,\n                id: exampleIds ? exampleIds[idx] : undefined,\n                source_run_id: sourceRunIds ? sourceRunIds[idx] : undefined\n            };\n        });\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/examples/bulk`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(formattedExamples),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"create examples\");\n        const result = await response.json();\n        return result;\n    }\n    async createLLMExample(input, generation, options) {\n        return this.createExample({\n            input\n        }, {\n            output: generation\n        }, options);\n    }\n    async createChatExample(input, generations, options) {\n        const finalInput = input.map((message)=>{\n            if ((0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.isLangChainMessage)(message)) {\n                return (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.convertLangChainMessageToExample)(message);\n            }\n            return message;\n        });\n        const finalOutput = (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.isLangChainMessage)(generations) ? (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_1__.convertLangChainMessageToExample)(generations) : generations;\n        return this.createExample({\n            input: finalInput\n        }, {\n            output: finalOutput\n        }, options);\n    }\n    async readExample(exampleId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(exampleId);\n        const path = `/examples/${exampleId}`;\n        return await this._get(path);\n    }\n    async *listExamples({ datasetId, datasetName, exampleIds, asOf, splits, inlineS3Urls, metadata, limit, offset, filter } = {}) {\n        let datasetId_;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId !== undefined) {\n            datasetId_ = datasetId;\n        } else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        } else {\n            throw new Error(\"Must provide a datasetName or datasetId\");\n        }\n        const params = new URLSearchParams({\n            dataset: datasetId_\n        });\n        const dataset_version = asOf ? typeof asOf === \"string\" ? asOf : asOf?.toISOString() : undefined;\n        if (dataset_version) {\n            params.append(\"as_of\", dataset_version);\n        }\n        const inlineS3Urls_ = inlineS3Urls ?? true;\n        params.append(\"inline_s3_urls\", inlineS3Urls_.toString());\n        if (exampleIds !== undefined) {\n            for (const id_ of exampleIds){\n                params.append(\"id\", id_);\n            }\n        }\n        if (splits !== undefined) {\n            for (const split of splits){\n                params.append(\"splits\", split);\n            }\n        }\n        if (metadata !== undefined) {\n            const serializedMetadata = JSON.stringify(metadata);\n            params.append(\"metadata\", serializedMetadata);\n        }\n        if (limit !== undefined) {\n            params.append(\"limit\", limit.toString());\n        }\n        if (offset !== undefined) {\n            params.append(\"offset\", offset.toString());\n        }\n        if (filter !== undefined) {\n            params.append(\"filter\", filter);\n        }\n        let i = 0;\n        for await (const examples of this._getPaginated(\"/examples\", params)){\n            for (const example of examples){\n                yield example;\n                i++;\n            }\n            if (limit !== undefined && i >= limit) {\n                break;\n            }\n        }\n    }\n    async deleteExample(exampleId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(exampleId);\n        const path = `/examples/${exampleId}`;\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, `delete ${path}`);\n        await response.json();\n    }\n    async updateExample(exampleId, update) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(exampleId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/examples/${exampleId}`, {\n            method: \"PATCH\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(update),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"update example\");\n        const result = await response.json();\n        return result;\n    }\n    async updateExamples(update) {\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/examples/bulk`, {\n            method: \"PATCH\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(update),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"update examples\");\n        const result = await response.json();\n        return result;\n    }\n    async listDatasetSplits({ datasetId, datasetName, asOf }) {\n        let datasetId_;\n        if (datasetId === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide dataset name or ID\");\n        } else if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId === undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        } else {\n            datasetId_ = datasetId;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId_);\n        const params = new URLSearchParams();\n        const dataset_version = asOf ? typeof asOf === \"string\" ? asOf : asOf?.toISOString() : undefined;\n        if (dataset_version) {\n            params.append(\"as_of\", dataset_version);\n        }\n        const response = await this._get(`/datasets/${datasetId_}/splits`, params);\n        return response;\n    }\n    async updateDatasetSplits({ datasetId, datasetName, splitName, exampleIds, remove = false }) {\n        let datasetId_;\n        if (datasetId === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide dataset name or ID\");\n        } else if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId === undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        } else {\n            datasetId_ = datasetId;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(datasetId_);\n        const data = {\n            split_name: splitName,\n            examples: exampleIds.map((id)=>{\n                (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(id);\n                return id;\n            }),\n            remove\n        };\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/datasets/${datasetId_}/splits`, {\n            method: \"PUT\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"update dataset splits\", true);\n    }\n    /**\n     * @deprecated This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.\n     */ async evaluateRun(run, evaluator, { sourceInfo, loadChildRuns, referenceExample } = {\n        loadChildRuns: false\n    }) {\n        (0,_utils_warn_js__WEBPACK_IMPORTED_MODULE_5__.warnOnce)(\"This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.\");\n        let run_;\n        if (typeof run === \"string\") {\n            run_ = await this.readRun(run, {\n                loadChildRuns\n            });\n        } else if (typeof run === \"object\" && \"id\" in run) {\n            run_ = run;\n        } else {\n            throw new Error(`Invalid run type: ${typeof run}`);\n        }\n        if (run_.reference_example_id !== null && run_.reference_example_id !== undefined) {\n            referenceExample = await this.readExample(run_.reference_example_id);\n        }\n        const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);\n        const [_, feedbacks] = await this._logEvaluationFeedback(feedbackResult, run_, sourceInfo);\n        return feedbacks[0];\n    }\n    async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = \"api\", sourceRunId, feedbackId, feedbackConfig, projectId, comparativeExperimentId }) {\n        if (!runId && !projectId) {\n            throw new Error(\"One of runId or projectId must be provided\");\n        }\n        if (runId && projectId) {\n            throw new Error(\"Only one of runId or projectId can be provided\");\n        }\n        const feedback_source = {\n            type: feedbackSourceType ?? \"api\",\n            metadata: sourceInfo ?? {}\n        };\n        if (sourceRunId !== undefined && feedback_source?.metadata !== undefined && !feedback_source.metadata[\"__run\"]) {\n            feedback_source.metadata[\"__run\"] = {\n                run_id: sourceRunId\n            };\n        }\n        if (feedback_source?.metadata !== undefined && feedback_source.metadata[\"__run\"]?.run_id !== undefined) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(feedback_source.metadata[\"__run\"].run_id);\n        }\n        const feedback = {\n            id: feedbackId ?? uuid__WEBPACK_IMPORTED_MODULE_10__[\"default\"](),\n            run_id: runId,\n            key,\n            score,\n            value,\n            correction,\n            comment,\n            feedback_source: feedback_source,\n            comparative_experiment_id: comparativeExperimentId,\n            feedbackConfig,\n            session_id: projectId\n        };\n        const url = `${this.apiUrl}/feedback`;\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), url, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(feedback),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"create feedback\", true);\n        return feedback;\n    }\n    async updateFeedback(feedbackId, { score, value, correction, comment }) {\n        const feedbackUpdate = {};\n        if (score !== undefined && score !== null) {\n            feedbackUpdate[\"score\"] = score;\n        }\n        if (value !== undefined && value !== null) {\n            feedbackUpdate[\"value\"] = value;\n        }\n        if (correction !== undefined && correction !== null) {\n            feedbackUpdate[\"correction\"] = correction;\n        }\n        if (comment !== undefined && comment !== null) {\n            feedbackUpdate[\"comment\"] = comment;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(feedbackId);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/feedback/${feedbackId}`, {\n            method: \"PATCH\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(feedbackUpdate),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"update feedback\", true);\n    }\n    async readFeedback(feedbackId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this._get(path);\n        return response;\n    }\n    async deleteFeedback(feedbackId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, `delete ${path}`);\n        await response.json();\n    }\n    async *listFeedback({ runIds, feedbackKeys, feedbackSourceTypes } = {}) {\n        const queryParams = new URLSearchParams();\n        if (runIds) {\n            queryParams.append(\"run\", runIds.join(\",\"));\n        }\n        if (feedbackKeys) {\n            for (const key of feedbackKeys){\n                queryParams.append(\"key\", key);\n            }\n        }\n        if (feedbackSourceTypes) {\n            for (const type of feedbackSourceTypes){\n                queryParams.append(\"source\", type);\n            }\n        }\n        for await (const feedbacks of this._getPaginated(\"/feedback\", queryParams)){\n            yield* feedbacks;\n        }\n    }\n    /**\n     * Creates a presigned feedback token and URL.\n     *\n     * The token can be used to authorize feedback metrics without\n     * needing an API key. This is useful for giving browser-based\n     * applications the ability to submit feedback without needing\n     * to expose an API key.\n     *\n     * @param runId - The ID of the run.\n     * @param feedbackKey - The feedback key.\n     * @param options - Additional options for the token.\n     * @param options.expiration - The expiration time for the token.\n     *\n     * @returns A promise that resolves to a FeedbackIngestToken.\n     */ async createPresignedFeedbackToken(runId, feedbackKey, { expiration, feedbackConfig } = {}) {\n        const body = {\n            run_id: runId,\n            feedback_key: feedbackKey,\n            feedback_config: feedbackConfig\n        };\n        if (expiration) {\n            if (typeof expiration === \"string\") {\n                body[\"expires_at\"] = expiration;\n            } else if (expiration?.hours || expiration?.minutes || expiration?.days) {\n                body[\"expires_in\"] = expiration;\n            }\n        } else {\n            body[\"expires_in\"] = {\n                hours: 3\n            };\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/feedback/tokens`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        const result = await response.json();\n        return result;\n    }\n    async createComparativeExperiment({ name, experimentIds, referenceDatasetId, createdAt, description, metadata, id }) {\n        if (experimentIds.length === 0) {\n            throw new Error(\"At least one experiment is required\");\n        }\n        if (!referenceDatasetId) {\n            referenceDatasetId = (await this.readProject({\n                projectId: experimentIds[0]\n            })).reference_dataset_id;\n        }\n        if (!referenceDatasetId == null) {\n            throw new Error(\"A reference dataset is required\");\n        }\n        const body = {\n            id,\n            name,\n            experiment_ids: experimentIds,\n            reference_dataset_id: referenceDatasetId,\n            description,\n            created_at: (createdAt ?? new Date())?.toISOString(),\n            extra: {}\n        };\n        if (metadata) body.extra[\"metadata\"] = metadata;\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/datasets/comparative`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        return await response.json();\n    }\n    /**\n     * Retrieves a list of presigned feedback tokens for a given run ID.\n     * @param runId The ID of the run.\n     * @returns An async iterable of FeedbackIngestToken objects.\n     */ async *listPresignedFeedbackTokens(runId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(runId);\n        const params = new URLSearchParams({\n            run_id: runId\n        });\n        for await (const tokens of this._getPaginated(\"/feedback/tokens\", params)){\n            yield* tokens;\n        }\n    }\n    _selectEvalResults(results) {\n        let results_;\n        if (\"results\" in results) {\n            results_ = results.results;\n        } else {\n            results_ = [\n                results\n            ];\n        }\n        return results_;\n    }\n    async _logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {\n        const evalResults = this._selectEvalResults(evaluatorResponse);\n        const feedbacks = [];\n        for (const res of evalResults){\n            let sourceInfo_ = sourceInfo || {};\n            if (res.evaluatorInfo) {\n                sourceInfo_ = {\n                    ...res.evaluatorInfo,\n                    ...sourceInfo_\n                };\n            }\n            let runId_ = null;\n            if (res.targetRunId) {\n                runId_ = res.targetRunId;\n            } else if (run) {\n                runId_ = run.id;\n            }\n            feedbacks.push(await this.createFeedback(runId_, res.key, {\n                score: res.score,\n                value: res.value,\n                comment: res.comment,\n                correction: res.correction,\n                sourceInfo: sourceInfo_,\n                sourceRunId: res.sourceRunId,\n                feedbackConfig: res.feedbackConfig,\n                feedbackSourceType: \"model\"\n            }));\n        }\n        return [\n            evalResults,\n            feedbacks\n        ];\n    }\n    async logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {\n        const [results] = await this._logEvaluationFeedback(evaluatorResponse, run, sourceInfo);\n        return results;\n    }\n    /**\n     * API for managing annotation queues\n     */ /**\n     * List the annotation queues on the LangSmith API.\n     * @param options - The options for listing annotation queues\n     * @param options.queueIds - The IDs of the queues to filter by\n     * @param options.name - The name of the queue to filter by\n     * @param options.nameContains - The substring that the queue name should contain\n     * @param options.limit - The maximum number of queues to return\n     * @returns An iterator of AnnotationQueue objects\n     */ async *listAnnotationQueues(options = {}) {\n        const { queueIds, name, nameContains, limit } = options;\n        const params = new URLSearchParams();\n        if (queueIds) {\n            queueIds.forEach((id, i)=>{\n                (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(id, `queueIds[${i}]`);\n                params.append(\"ids\", id);\n            });\n        }\n        if (name) params.append(\"name\", name);\n        if (nameContains) params.append(\"name_contains\", nameContains);\n        params.append(\"limit\", (limit !== undefined ? Math.min(limit, 100) : 100).toString());\n        let count = 0;\n        for await (const queues of this._getPaginated(\"/annotation-queues\", params)){\n            yield* queues;\n            count++;\n            if (limit !== undefined && count >= limit) break;\n        }\n    }\n    /**\n     * Create an annotation queue on the LangSmith API.\n     * @param options - The options for creating an annotation queue\n     * @param options.name - The name of the annotation queue\n     * @param options.description - The description of the annotation queue\n     * @param options.queueId - The ID of the annotation queue\n     * @returns The created AnnotationQueue object\n     */ async createAnnotationQueue(options) {\n        const { name, description, queueId } = options;\n        const body = {\n            name,\n            description,\n            id: queueId || uuid__WEBPACK_IMPORTED_MODULE_10__[\"default\"]()\n        };\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/annotation-queues`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(Object.fromEntries(Object.entries(body).filter(([_, v])=>v !== undefined))),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"create annotation queue\");\n        const data = await response.json();\n        return data;\n    }\n    /**\n     * Read an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue to read\n     * @returns The AnnotationQueue object\n     */ async readAnnotationQueue(queueId) {\n        // TODO: Replace when actual endpoint is added\n        const queueIteratorResult = await this.listAnnotationQueues({\n            queueIds: [\n                queueId\n            ]\n        }).next();\n        if (queueIteratorResult.done) {\n            throw new Error(`Annotation queue with ID ${queueId} not found`);\n        }\n        return queueIteratorResult.value;\n    }\n    /**\n     * Update an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue to update\n     * @param options - The options for updating the annotation queue\n     * @param options.name - The new name for the annotation queue\n     * @param options.description - The new description for the annotation queue\n     */ async updateAnnotationQueue(queueId, options) {\n        const { name, description } = options;\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(queueId, \"queueId\")}`, {\n            method: \"PATCH\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                name,\n                description\n            }),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"update annotation queue\");\n    }\n    /**\n     * Delete an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue to delete\n     */ async deleteAnnotationQueue(queueId) {\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(queueId, \"queueId\")}`, {\n            method: \"DELETE\",\n            headers: {\n                ...this.headers,\n                Accept: \"application/json\"\n            },\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"delete annotation queue\");\n    }\n    /**\n     * Add runs to an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue\n     * @param runIds - The IDs of the runs to be added to the annotation queue\n     */ async addRunsToAnnotationQueue(queueId, runIds) {\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(queueId, \"queueId\")}/runs`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(runIds.map((id, i)=>(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(id, `runIds[${i}]`).toString())),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"add runs to annotation queue\");\n    }\n    /**\n     * Get a run from an annotation queue at the specified index.\n     * @param queueId - The ID of the annotation queue\n     * @param index - The index of the run to retrieve\n     * @returns A Promise that resolves to a RunWithAnnotationQueueInfo object\n     * @throws {Error} If the run is not found at the given index or for other API-related errors\n     */ async getRunFromAnnotationQueue(queueId, index) {\n        const baseUrl = `/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(queueId, \"queueId\")}/run`;\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}${baseUrl}/${index}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"get run from annotation queue\");\n        return await response.json();\n    }\n    async _currentTenantIsOwner(owner) {\n        const settings = await this._getSettings();\n        return owner == \"-\" || settings.tenant_handle === owner;\n    }\n    async _ownerConflictError(action, owner) {\n        const settings = await this._getSettings();\n        return new Error(`Cannot ${action} for another tenant.\\n\n      Current tenant: ${settings.tenant_handle}\\n\n      Requested tenant: ${owner}`);\n    }\n    async _getLatestCommitHash(promptOwnerAndName) {\n        const res = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/commits/${promptOwnerAndName}/?limit=${1}&offset=${0}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        const json = await res.json();\n        if (!res.ok) {\n            const detail = typeof json.detail === \"string\" ? json.detail : JSON.stringify(json.detail);\n            const error = new Error(`Error ${res.status}: ${res.statusText}\\n${detail}`);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            error.statusCode = res.status;\n            throw error;\n        }\n        if (json.commits.length === 0) {\n            return undefined;\n        }\n        return json.commits[0].commit_hash;\n    }\n    async _likeOrUnlikePrompt(promptIdentifier, like) {\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/likes/${owner}/${promptName}`, {\n            method: \"POST\",\n            body: JSON.stringify({\n                like: like\n            }),\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, `${like ? \"like\" : \"unlike\"} prompt`);\n        return await response.json();\n    }\n    async _getPromptUrl(promptIdentifier) {\n        const [owner, promptName, commitHash] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier);\n        if (!await this._currentTenantIsOwner(owner)) {\n            if (commitHash !== \"latest\") {\n                return `${this.getHostUrl()}/hub/${owner}/${promptName}/${commitHash.substring(0, 8)}`;\n            } else {\n                return `${this.getHostUrl()}/hub/${owner}/${promptName}`;\n            }\n        } else {\n            const settings = await this._getSettings();\n            if (commitHash !== \"latest\") {\n                return `${this.getHostUrl()}/prompts/${promptName}/${commitHash.substring(0, 8)}?organizationId=${settings.id}`;\n            } else {\n                return `${this.getHostUrl()}/prompts/${promptName}?organizationId=${settings.id}`;\n            }\n        }\n    }\n    async promptExists(promptIdentifier) {\n        const prompt = await this.getPrompt(promptIdentifier);\n        return !!prompt;\n    }\n    async likePrompt(promptIdentifier) {\n        return this._likeOrUnlikePrompt(promptIdentifier, true);\n    }\n    async unlikePrompt(promptIdentifier) {\n        return this._likeOrUnlikePrompt(promptIdentifier, false);\n    }\n    async *listCommits(promptOwnerAndName) {\n        for await (const commits of this._getPaginated(`/commits/${promptOwnerAndName}/`, new URLSearchParams(), (res)=>res.commits)){\n            yield* commits;\n        }\n    }\n    async *listPrompts(options) {\n        const params = new URLSearchParams();\n        params.append(\"sort_field\", options?.sortField ?? \"updated_at\");\n        params.append(\"sort_direction\", \"desc\");\n        params.append(\"is_archived\", (!!options?.isArchived).toString());\n        if (options?.isPublic !== undefined) {\n            params.append(\"is_public\", options.isPublic.toString());\n        }\n        if (options?.query) {\n            params.append(\"query\", options.query);\n        }\n        for await (const prompts of this._getPaginated(\"/repos\", params, (res)=>res.repos)){\n            yield* prompts;\n        }\n    }\n    async getPrompt(promptIdentifier) {\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier);\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/repos/${owner}/${promptName}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        if (response.status === 404) {\n            return null;\n        }\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"get prompt\");\n        const result = await response.json();\n        if (result.repo) {\n            return result.repo;\n        } else {\n            return null;\n        }\n    }\n    async createPrompt(promptIdentifier, options) {\n        const settings = await this._getSettings();\n        if (options?.isPublic && !settings.tenant_handle) {\n            throw new Error(`Cannot create a public prompt without first\\n\n        creating a LangChain Hub handle. \n        You can add a handle by creating a public prompt at:\\n\n        https://smith.langchain.com/prompts`);\n        }\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier);\n        if (!await this._currentTenantIsOwner(owner)) {\n            throw await this._ownerConflictError(\"create a prompt\", owner);\n        }\n        const data = {\n            repo_handle: promptName,\n            ...options?.description && {\n                description: options.description\n            },\n            ...options?.readme && {\n                readme: options.readme\n            },\n            ...options?.tags && {\n                tags: options.tags\n            },\n            is_public: !!options?.isPublic\n        };\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/repos/`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"create prompt\");\n        const { repo } = await response.json();\n        return repo;\n    }\n    async createCommit(promptIdentifier, object, options) {\n        if (!await this.promptExists(promptIdentifier)) {\n            throw new Error(\"Prompt does not exist, you must create it first.\");\n        }\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier);\n        const resolvedParentCommitHash = options?.parentCommitHash === \"latest\" || !options?.parentCommitHash ? await this._getLatestCommitHash(`${owner}/${promptName}`) : options?.parentCommitHash;\n        const payload = {\n            manifest: JSON.parse(JSON.stringify(object)),\n            parent_commit: resolvedParentCommitHash\n        };\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/commits/${owner}/${promptName}`, {\n            method: \"POST\",\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(payload),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"create commit\");\n        const result = await response.json();\n        return this._getPromptUrl(`${owner}/${promptName}${result.commit_hash ? `:${result.commit_hash}` : \"\"}`);\n    }\n    async updatePrompt(promptIdentifier, options) {\n        if (!await this.promptExists(promptIdentifier)) {\n            throw new Error(\"Prompt does not exist, you must create it first.\");\n        }\n        const [owner, promptName] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier);\n        if (!await this._currentTenantIsOwner(owner)) {\n            throw await this._ownerConflictError(\"update a prompt\", owner);\n        }\n        const payload = {};\n        if (options?.description !== undefined) payload.description = options.description;\n        if (options?.readme !== undefined) payload.readme = options.readme;\n        if (options?.tags !== undefined) payload.tags = options.tags;\n        if (options?.isPublic !== undefined) payload.is_public = options.isPublic;\n        if (options?.isArchived !== undefined) payload.is_archived = options.isArchived;\n        // Check if payload is empty\n        if (Object.keys(payload).length === 0) {\n            throw new Error(\"No valid update options provided\");\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/repos/${owner}/${promptName}`, {\n            method: \"PATCH\",\n            body: JSON.stringify(payload),\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\"\n            },\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"update prompt\");\n        return response.json();\n    }\n    async deletePrompt(promptIdentifier) {\n        if (!await this.promptExists(promptIdentifier)) {\n            throw new Error(\"Prompt does not exist, you must create it first.\");\n        }\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier);\n        if (!await this._currentTenantIsOwner(owner)) {\n            throw await this._ownerConflictError(\"delete a prompt\", owner);\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/repos/${owner}/${promptName}`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        return await response.json();\n    }\n    async pullPromptCommit(promptIdentifier, options) {\n        const [owner, promptName, commitHash] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.parsePromptIdentifier)(promptIdentifier);\n        const serverInfo = await this._getServerInfo();\n        const useOptimization = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_6__.isVersionGreaterOrEqual)(serverInfo.version, \"0.5.23\");\n        let passedCommitHash = commitHash;\n        if (!useOptimization && commitHash === \"latest\") {\n            const latestCommitHash = await this._getLatestCommitHash(`${owner}/${promptName}`);\n            if (!latestCommitHash) {\n                throw new Error(\"No commits found\");\n            } else {\n                passedCommitHash = latestCommitHash;\n            }\n        }\n        const response = await this.caller.call((0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_8__._getFetchImplementation)(), `${this.apiUrl}/commits/${owner}/${promptName}/${passedCommitHash}${options?.includeModel ? \"?include_model=true\" : \"\"}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions\n        });\n        await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_7__.raiseForStatus)(response, \"pull prompt commit\");\n        const result = await response.json();\n        return {\n            owner,\n            repo: promptName,\n            commit_hash: result.commit_hash,\n            manifest: result.manifest,\n            examples: result.examples\n        };\n    }\n    /**\n     * This method should not be used directly, use `import { pull } from \"langchain/hub\"` instead.\n     * Using this method directly returns the JSON string of the prompt rather than a LangChain object.\n     * @private\n     */ async _pullPrompt(promptIdentifier, options) {\n        const promptObject = await this.pullPromptCommit(promptIdentifier, {\n            includeModel: options?.includeModel\n        });\n        const prompt = JSON.stringify(promptObject.manifest);\n        return prompt;\n    }\n    async pushPrompt(promptIdentifier, options) {\n        // Create or update prompt metadata\n        if (await this.promptExists(promptIdentifier)) {\n            if (options && Object.keys(options).some((key)=>key !== \"object\")) {\n                await this.updatePrompt(promptIdentifier, {\n                    description: options?.description,\n                    readme: options?.readme,\n                    tags: options?.tags,\n                    isPublic: options?.isPublic\n                });\n            }\n        } else {\n            await this.createPrompt(promptIdentifier, {\n                description: options?.description,\n                readme: options?.readme,\n                tags: options?.tags,\n                isPublic: options?.isPublic\n            });\n        }\n        if (!options?.object) {\n            return await this._getPromptUrl(promptIdentifier);\n        }\n        // Create a commit with the new manifest\n        const url = await this.createCommit(promptIdentifier, options?.object, {\n            parentCommitHash: options?.parentCommitHash\n        });\n        return url;\n    }\n    /**\n     * Clone a public dataset to your own langsmith tenant.\n     * This operation is idempotent. If you already have a dataset with the given name,\n     * this function will do nothing.\n  \n     * @param {string} tokenOrUrl The token of the public dataset to clone.\n     * @param {Object} [options] Additional options for cloning the dataset.\n     * @param {string} [options.sourceApiUrl] The URL of the langsmith server where the data is hosted. Defaults to the API URL of your current client.\n     * @param {string} [options.datasetName] The name of the dataset to create in your tenant. Defaults to the name of the public dataset.\n     * @returns {Promise<void>}\n     */ async clonePublicDataset(tokenOrUrl, options = {}) {\n        const { sourceApiUrl = this.apiUrl, datasetName } = options;\n        const [parsedApiUrl, tokenUuid] = this.parseTokenOrUrl(tokenOrUrl, sourceApiUrl);\n        const sourceClient = new Client({\n            apiUrl: parsedApiUrl,\n            // Placeholder API key not needed anymore in most cases, but\n            // some private deployments may have API key-based rate limiting\n            // that would cause this to fail if we provide no value.\n            apiKey: \"placeholder\"\n        });\n        const ds = await sourceClient.readSharedDataset(tokenUuid);\n        const finalDatasetName = datasetName || ds.name;\n        try {\n            if (await this.hasDataset({\n                datasetId: finalDatasetName\n            })) {\n                console.log(`Dataset ${finalDatasetName} already exists in your tenant. Skipping.`);\n                return;\n            }\n        } catch (_) {\n        // `.hasDataset` will throw an error if the dataset does not exist.\n        // no-op in that case\n        }\n        // Fetch examples first, then create the dataset\n        const examples = await sourceClient.listSharedExamples(tokenUuid);\n        const dataset = await this.createDataset(finalDatasetName, {\n            description: ds.description,\n            dataType: ds.data_type || \"kv\",\n            inputsSchema: ds.inputs_schema_definition ?? undefined,\n            outputsSchema: ds.outputs_schema_definition ?? undefined\n        });\n        try {\n            await this.createExamples({\n                inputs: examples.map((e)=>e.inputs),\n                outputs: examples.flatMap((e)=>e.outputs ? [\n                        e.outputs\n                    ] : []),\n                datasetId: dataset.id\n            });\n        } catch (e) {\n            console.error(`An error occurred while creating dataset ${finalDatasetName}. ` + \"You should delete it manually.\");\n            throw e;\n        }\n    }\n    parseTokenOrUrl(urlOrToken, apiUrl, numParts = 2, kind = \"dataset\") {\n        // Try parsing as UUID\n        try {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_4__.assertUuid)(urlOrToken); // Will throw if it's not a UUID.\n            return [\n                apiUrl,\n                urlOrToken\n            ];\n        } catch (_) {\n        // no-op if it's not a uuid\n        }\n        // Parse as URL\n        try {\n            const parsedUrl = new URL(urlOrToken);\n            const pathParts = parsedUrl.pathname.split(\"/\").filter((part)=>part !== \"\");\n            if (pathParts.length >= numParts) {\n                const tokenUuid = pathParts[pathParts.length - numParts];\n                return [\n                    apiUrl,\n                    tokenUuid\n                ];\n            } else {\n                throw new Error(`Invalid public ${kind} URL: ${urlOrToken}`);\n            }\n        } catch (error) {\n            throw new Error(`Invalid public ${kind} URL or token: ${urlOrToken}`);\n        }\n    }\n    /**\n     * Awaits all pending trace batches. Useful for environments where\n     * you need to be sure that all tracing requests finish before execution ends,\n     * such as serverless environments.\n     *\n     * @example\n     * ```\n     * import { Client } from \"langsmith\";\n     *\n     * const client = new Client();\n     *\n     * try {\n     *   // Tracing happens here\n     *   ...\n     * } finally {\n     *   await client.awaitPendingTraceBatches();\n     * }\n     * ```\n     *\n     * @returns A promise that resolves once all currently pending traces have sent.\n     */ awaitPendingTraceBatches() {\n        return Promise.all(this.autoBatchQueue.items.map(({ itemPromise })=>itemPromise));\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2QjtBQUN5QjtBQUNzQztBQUMwQjtBQUM3RTtBQUNLO0FBQ0g7QUFDMEM7QUFDbkM7QUFDYztBQUN3QjtBQUNqRixTQUFTZ0IsNkJBQTZCQyxHQUFHO0lBQzVDLE1BQU1DLGFBQWFaLG9FQUFxQkE7SUFDeEMsTUFBTWEsVUFBVWYsMEVBQTJCQTtJQUMzQyxNQUFNZ0IsUUFBUUgsSUFBSUcsS0FBSyxJQUFJLENBQUM7SUFDNUIsTUFBTUMsV0FBV0QsTUFBTUMsUUFBUTtJQUMvQkosSUFBSUcsS0FBSyxHQUFHO1FBQ1IsR0FBR0EsS0FBSztRQUNSRSxTQUFTO1lBQ0wsR0FBR0osVUFBVTtZQUNiLEdBQUdFLE9BQU9FLE9BQU87UUFDckI7UUFDQUQsVUFBVTtZQUNOLEdBQUdGLE9BQU87WUFDVixHQUFJQSxRQUFRSSxXQUFXLElBQUlOLElBQUlNLFdBQVcsR0FDcEM7Z0JBQUVBLGFBQWFOLElBQUlNLFdBQVcsSUFBSUosUUFBUUksV0FBVztZQUFDLElBQ3RELENBQUMsQ0FBQztZQUNSLEdBQUdGLFFBQVE7UUFDZjtJQUNKO0lBQ0EsT0FBT0o7QUFDWDtBQUNBLE1BQU1PLHlCQUF5QjtJQUMzQixNQUFNQyxrQkFBa0JwQiw4RUFBK0JBLENBQUM7SUFDeEQsSUFBSW9CLG9CQUFvQkMsV0FBVztRQUMvQixPQUFPQTtJQUNYO0lBQ0EsTUFBTUMsZUFBZUMsV0FBV0g7SUFDaEMsSUFBSUUsZUFBZSxLQUFLQSxlQUFlLEdBQUc7UUFDdEMsTUFBTSxJQUFJRSxNQUFNLENBQUMscUVBQXFFLEVBQUVGLGFBQWEsQ0FBQztJQUMxRztJQUNBLE9BQU9BO0FBQ1g7QUFDQSxvQkFBb0I7QUFDcEIsTUFBTUcsY0FBYyxDQUFDQztJQUNqQixNQUFNQyxjQUFjRCxJQUFJRSxPQUFPLENBQUMsV0FBVyxJQUFJQSxPQUFPLENBQUMsWUFBWTtJQUNu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akIsYUFBYSxpQ0FBaUM7WUFDekQsT0FBTztnQkFBQzFlO2dCQUFRMGU7YUFBVztRQUMvQixFQUNBLE9BQU85UCxHQUFHO1FBQ04sMkJBQTJCO1FBQy9CO1FBQ0EsZUFBZTtRQUNmLElBQUk7WUFDQSxNQUFNaVEsWUFBWSxJQUFJQyxJQUFJSjtZQUMxQixNQUFNSyxZQUFZRixVQUFVRyxRQUFRLENBQy9CcGlCLEtBQUssQ0FBQyxLQUNOa0ksTUFBTSxDQUFDLENBQUNvRixPQUFTQSxTQUFTO1lBQy9CLElBQUk2VSxVQUFVbmdCLE1BQU0sSUFBSStmLFVBQVU7Z0JBQzlCLE1BQU1SLFlBQVlZLFNBQVMsQ0FBQ0EsVUFBVW5nQixNQUFNLEdBQUcrZixTQUFTO2dCQUN4RCxPQUFPO29CQUFDM2U7b0JBQVFtZTtpQkFBVTtZQUM5QixPQUNLO2dCQUNELE1BQU0sSUFBSTdoQixNQUFNLENBQUMsZUFBZSxFQUFFc2lCLEtBQUssTUFBTSxFQUFFRixXQUFXLENBQUM7WUFDL0Q7UUFDSixFQUNBLE9BQU8vWSxPQUFPO1lBQ1YsTUFBTSxJQUFJckosTUFBTSxDQUFDLGVBQWUsRUFBRXNpQixLQUFLLGVBQWUsRUFBRUYsV0FBVyxDQUFDO1FBQ3hFO0lBQ0o7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FvQkMsR0FDRE8sMkJBQTJCO1FBQ3ZCLE9BQU9yaEIsUUFBUTBQLEdBQUcsQ0FBQyxJQUFJLENBQUM3SSxjQUFjLENBQUNqRyxLQUFLLENBQUNhLEdBQUcsQ0FBQyxDQUFDLEVBQUVYLFdBQVcsRUFBRSxHQUFLQTtJQUMxRTtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGFyZHdhcmUtZG9jLWNoYXRib3QvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvY2xpZW50LmpzP2VkMTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdXVpZCBmcm9tIFwidXVpZFwiO1xuaW1wb3J0IHsgQXN5bmNDYWxsZXIgfSBmcm9tIFwiLi91dGlscy9hc3luY19jYWxsZXIuanNcIjtcbmltcG9ydCB7IGNvbnZlcnRMYW5nQ2hhaW5NZXNzYWdlVG9FeGFtcGxlLCBpc0xhbmdDaGFpbk1lc3NhZ2UsIH0gZnJvbSBcIi4vdXRpbHMvbWVzc2FnZXMuanNcIjtcbmltcG9ydCB7IGdldExhbmdDaGFpbkVudlZhcnNNZXRhZGF0YSwgZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZSwgZ2V0UnVudGltZUVudmlyb25tZW50LCB9IGZyb20gXCIuL3V0aWxzL2Vudi5qc1wiO1xuaW1wb3J0IHsgX192ZXJzaW9uX18gfSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHsgYXNzZXJ0VXVpZCB9IGZyb20gXCIuL3V0aWxzL191dWlkLmpzXCI7XG5pbXBvcnQgeyB3YXJuT25jZSB9IGZyb20gXCIuL3V0aWxzL3dhcm4uanNcIjtcbmltcG9ydCB7IGlzVmVyc2lvbkdyZWF0ZXJPckVxdWFsLCBwYXJzZVByb21wdElkZW50aWZpZXIsIH0gZnJvbSBcIi4vdXRpbHMvcHJvbXB0cy5qc1wiO1xuaW1wb3J0IHsgcmFpc2VGb3JTdGF0dXMgfSBmcm9tIFwiLi91dGlscy9lcnJvci5qc1wiO1xuaW1wb3J0IHsgX2dldEZldGNoSW1wbGVtZW50YXRpb24gfSBmcm9tIFwiLi9zaW5nbGV0b25zL2ZldGNoLmpzXCI7XG5pbXBvcnQgeyBzdHJpbmdpZnkgYXMgc3RyaW5naWZ5Rm9yVHJhY2luZyB9IGZyb20gXCIuL3V0aWxzL2Zhc3Qtc2FmZS1zdHJpbmdpZnkvaW5kZXguanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZVJ1bnRpbWVFbnZJbnRvUnVuQ3JlYXRlKHJ1bikge1xuICAgIGNvbnN0IHJ1bnRpbWVFbnYgPSBnZXRSdW50aW1lRW52aXJvbm1lbnQoKTtcbiAgICBjb25zdCBlbnZWYXJzID0gZ2V0TGFuZ0NoYWluRW52VmFyc01ldGFkYXRhKCk7XG4gICAgY29uc3QgZXh0cmEgPSBydW4uZXh0cmEgPz8ge307XG4gICAgY29uc3QgbWV0YWRhdGEgPSBleHRyYS5tZXRhZGF0YTtcbiAgICBydW4uZXh0cmEgPSB7XG4gICAgICAgIC4uLmV4dHJhLFxuICAgICAgICBydW50aW1lOiB7XG4gICAgICAgICAgICAuLi5ydW50aW1lRW52LFxuICAgICAgICAgICAgLi4uZXh0cmE/LnJ1bnRpbWUsXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAuLi5lbnZWYXJzLFxuICAgICAgICAgICAgLi4uKGVudlZhcnMucmV2aXNpb25faWQgfHwgcnVuLnJldmlzaW9uX2lkXG4gICAgICAgICAgICAgICAgPyB7IHJldmlzaW9uX2lkOiBydW4ucmV2aXNpb25faWQgPz8gZW52VmFycy5yZXZpc2lvbl9pZCB9XG4gICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICAuLi5tZXRhZGF0YSxcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBydW47XG59XG5jb25zdCBnZXRUcmFjaW5nU2FtcGxpbmdSYXRlID0gKCkgPT4ge1xuICAgIGNvbnN0IHNhbXBsaW5nUmF0ZVN0ciA9IGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUoXCJUUkFDSU5HX1NBTVBMSU5HX1JBVEVcIik7XG4gICAgaWYgKHNhbXBsaW5nUmF0ZVN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHNhbXBsaW5nUmF0ZSA9IHBhcnNlRmxvYXQoc2FtcGxpbmdSYXRlU3RyKTtcbiAgICBpZiAoc2FtcGxpbmdSYXRlIDwgMCB8fCBzYW1wbGluZ1JhdGUgPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTEFOR1NNSVRIX1RSQUNJTkdfU0FNUExJTkdfUkFURSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMSBpZiBzZXQuIEdvdDogJHtzYW1wbGluZ1JhdGV9YCk7XG4gICAgfVxuICAgIHJldHVybiBzYW1wbGluZ1JhdGU7XG59O1xuLy8gdXRpbGl0eSBmdW5jdGlvbnNcbmNvbnN0IGlzTG9jYWxob3N0ID0gKHVybCkgPT4ge1xuICAgIGNvbnN0IHN0cmlwcGVkVXJsID0gdXJsLnJlcGxhY2UoXCJodHRwOi8vXCIsIFwiXCIpLnJlcGxhY2UoXCJodHRwczovL1wiLCBcIlwiKTtcbiAgICBjb25zdCBob3N0bmFtZSA9IHN0cmlwcGVkVXJsLnNwbGl0KFwiL1wiKVswXS5zcGxpdChcIjpcIilbMF07XG4gICAgcmV0dXJuIChob3N0bmFtZSA9PT0gXCJsb2NhbGhvc3RcIiB8fCBob3N0bmFtZSA9PT0gXCIxMjcuMC4wLjFcIiB8fCBob3N0bmFtZSA9PT0gXCI6OjFcIik7XG59O1xuYXN5bmMgZnVuY3Rpb24gdG9BcnJheShpdGVyYWJsZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciBhd2FpdCAoY29uc3QgaXRlbSBvZiBpdGVyYWJsZSkge1xuICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRyaW1RdW90ZXMoc3RyKSB7XG4gICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBzdHJcbiAgICAgICAgLnRyaW0oKVxuICAgICAgICAucmVwbGFjZSgvXlwiKC4qKVwiJC8sIFwiJDFcIilcbiAgICAgICAgLnJlcGxhY2UoL14nKC4qKSckLywgXCIkMVwiKTtcbn1cbmNvbnN0IGhhbmRsZTQyOSA9IGFzeW5jIChyZXNwb25zZSkgPT4ge1xuICAgIGlmIChyZXNwb25zZT8uc3RhdHVzID09PSA0MjkpIHtcbiAgICAgICAgY29uc3QgcmV0cnlBZnRlciA9IHBhcnNlSW50KHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwicmV0cnktYWZ0ZXJcIikgPz8gXCIzMFwiLCAxMCkgKiAxMDAwO1xuICAgICAgICBpZiAocmV0cnlBZnRlciA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHJldHJ5QWZ0ZXIpKTtcbiAgICAgICAgICAgIC8vIFJldHVybiBkaXJlY3RseSBhZnRlciBjYWxsaW5nIHRoaXMgY2hlY2tcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEZhbGwgYmFjayB0byBleGlzdGluZyBzdGF0dXMgY2hlY2tzXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmV4cG9ydCBjbGFzcyBRdWV1ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIml0ZW1zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2l6ZUJ5dGVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwZWVrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtc1swXTtcbiAgICB9XG4gICAgcHVzaChpdGVtKSB7XG4gICAgICAgIGxldCBpdGVtUHJvbWlzZVJlc29sdmU7XG4gICAgICAgIGNvbnN0IGl0ZW1Qcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIC8vIFNldHRpbmcgaXRlbVByb21pc2VSZXNvbHZlIGlzIHN5bmNocm9ub3VzIHdpdGggcHJvbWlzZSBjcmVhdGlvbjpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1Byb21pc2UvUHJvbWlzZVxuICAgICAgICAgICAgaXRlbVByb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNpemUgPSBzdHJpbmdpZnlGb3JUcmFjaW5nKGl0ZW0uaXRlbSkubGVuZ3RoO1xuICAgICAgICB0aGlzLml0ZW1zLnB1c2goe1xuICAgICAgICAgICAgYWN0aW9uOiBpdGVtLmFjdGlvbixcbiAgICAgICAgICAgIHBheWxvYWQ6IGl0ZW0uaXRlbSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICBpdGVtUHJvbWlzZVJlc29sdmU6IGl0ZW1Qcm9taXNlUmVzb2x2ZSxcbiAgICAgICAgICAgIGl0ZW1Qcm9taXNlLFxuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2l6ZUJ5dGVzICs9IHNpemU7XG4gICAgICAgIHJldHVybiBpdGVtUHJvbWlzZTtcbiAgICB9XG4gICAgcG9wKHVwVG9TaXplQnl0ZXMpIHtcbiAgICAgICAgaWYgKHVwVG9TaXplQnl0ZXMgPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgb2YgYnl0ZXMgdG8gcG9wIG9mZiBtYXkgbm90IGJlIGxlc3MgdGhhbiAxLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3BwZWQgPSBbXTtcbiAgICAgICAgbGV0IHBvcHBlZFNpemVCeXRlcyA9IDA7XG4gICAgICAgIC8vIFBvcCBpdGVtcyB1bnRpbCB3ZSByZWFjaCBvciBleGNlZWQgdGhlIHNpemUgbGltaXRcbiAgICAgICAgd2hpbGUgKHBvcHBlZFNpemVCeXRlcyArICh0aGlzLnBlZWsoKT8uc2l6ZSA/PyAwKSA8IHVwVG9TaXplQnl0ZXMgJiZcbiAgICAgICAgICAgIHRoaXMuaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuaXRlbXMuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcG9wcGVkLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgcG9wcGVkU2l6ZUJ5dGVzICs9IGl0ZW0uc2l6ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNpemVCeXRlcyAtPSBpdGVtLnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gaXRlbSBvbiB0aGUgcXVldWUgd2Ugd2VyZSB1bmFibGUgdG8gcG9wLFxuICAgICAgICAvLyBqdXN0IHJldHVybiBpdCBhcyBhIHNpbmdsZSBiYXRjaC5cbiAgICAgICAgaWYgKHBvcHBlZC5sZW5ndGggPT09IDAgJiYgdGhpcy5pdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5pdGVtcy5zaGlmdCgpO1xuICAgICAgICAgICAgcG9wcGVkLnB1c2goaXRlbSk7XG4gICAgICAgICAgICBwb3BwZWRTaXplQnl0ZXMgKz0gaXRlbS5zaXplO1xuICAgICAgICAgICAgdGhpcy5zaXplQnl0ZXMgLT0gaXRlbS5zaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBwb3BwZWQubWFwKChpdCkgPT4gKHsgYWN0aW9uOiBpdC5hY3Rpb24sIGl0ZW06IGl0LnBheWxvYWQgfSkpLFxuICAgICAgICAgICAgKCkgPT4gcG9wcGVkLmZvckVhY2goKGl0KSA9PiBpdC5pdGVtUHJvbWlzZVJlc29sdmUoKSksXG4gICAgICAgIF07XG4gICAgfVxufVxuLy8gMjAgTUJcbmV4cG9ydCBjb25zdCBERUZBVUxUX0JBVENIX1NJWkVfTElNSVRfQllURVMgPSAyMF85NzFfNTIwO1xuY29uc3QgU0VSVkVSX0lORk9fUkVRVUVTVF9USU1FT1VUID0gMTAwMDtcbmV4cG9ydCBjbGFzcyBDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFwaUtleVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcGlVcmxcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwid2ViVXJsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhbGxlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJiYXRjaEluZ2VzdENhbGxlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0aW1lb3V0X21zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90ZW5hbnRJZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaGlkZUlucHV0c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJoaWRlT3V0cHV0c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFjaW5nU2FtcGxlUmF0ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmaWx0ZXJlZFBvc3RVdWlkc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IFNldCgpXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhdXRvQmF0Y2hUcmFjaW5nXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhdXRvQmF0Y2hRdWV1ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IFF1ZXVlKClcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF1dG9CYXRjaFRpbWVvdXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXV0b0JhdGNoSW5pdGlhbERlbGF5TXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDI1MFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXV0b0JhdGNoQWdncmVnYXRpb25EZWxheU1zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiA1MFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYmF0Y2hTaXplQnl0ZXNMaW1pdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmZXRjaE9wdGlvbnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2V0dGluZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYmxvY2tPblJvb3RSdW5GaW5hbGl6YXRpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zZXJ2ZXJJbmZvXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9nZXRTZXJ2ZXJJbmZvUHJvbWlzZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkZWZhdWx0Q29uZmlnID0gQ2xpZW50LmdldERlZmF1bHRDbGllbnRDb25maWcoKTtcbiAgICAgICAgdGhpcy50cmFjaW5nU2FtcGxlUmF0ZSA9IGdldFRyYWNpbmdTYW1wbGluZ1JhdGUoKTtcbiAgICAgICAgdGhpcy5hcGlVcmwgPSB0cmltUXVvdGVzKGNvbmZpZy5hcGlVcmwgPz8gZGVmYXVsdENvbmZpZy5hcGlVcmwpID8/IFwiXCI7XG4gICAgICAgIGlmICh0aGlzLmFwaVVybC5lbmRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgICAgIHRoaXMuYXBpVXJsID0gdGhpcy5hcGlVcmwuc2xpY2UoMCwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXBpS2V5ID0gdHJpbVF1b3Rlcyhjb25maWcuYXBpS2V5ID8/IGRlZmF1bHRDb25maWcuYXBpS2V5KTtcbiAgICAgICAgdGhpcy53ZWJVcmwgPSB0cmltUXVvdGVzKGNvbmZpZy53ZWJVcmwgPz8gZGVmYXVsdENvbmZpZy53ZWJVcmwpO1xuICAgICAgICBpZiAodGhpcy53ZWJVcmw/LmVuZHNXaXRoKFwiL1wiKSkge1xuICAgICAgICAgICAgdGhpcy53ZWJVcmwgPSB0aGlzLndlYlVybC5zbGljZSgwLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aW1lb3V0X21zID0gY29uZmlnLnRpbWVvdXRfbXMgPz8gMTJfMDAwO1xuICAgICAgICB0aGlzLmNhbGxlciA9IG5ldyBBc3luY0NhbGxlcihjb25maWcuY2FsbGVyT3B0aW9ucyA/PyB7fSk7XG4gICAgICAgIHRoaXMuYmF0Y2hJbmdlc3RDYWxsZXIgPSBuZXcgQXN5bmNDYWxsZXIoe1xuICAgICAgICAgICAgLi4uKGNvbmZpZy5jYWxsZXJPcHRpb25zID8/IHt9KSxcbiAgICAgICAgICAgIG9uRmFpbGVkUmVzcG9uc2VIb29rOiBoYW5kbGU0MjksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhpZGVJbnB1dHMgPVxuICAgICAgICAgICAgY29uZmlnLmhpZGVJbnB1dHMgPz8gY29uZmlnLmFub255bWl6ZXIgPz8gZGVmYXVsdENvbmZpZy5oaWRlSW5wdXRzO1xuICAgICAgICB0aGlzLmhpZGVPdXRwdXRzID1cbiAgICAgICAgICAgIGNvbmZpZy5oaWRlT3V0cHV0cyA/PyBjb25maWcuYW5vbnltaXplciA/PyBkZWZhdWx0Q29uZmlnLmhpZGVPdXRwdXRzO1xuICAgICAgICB0aGlzLmF1dG9CYXRjaFRyYWNpbmcgPSBjb25maWcuYXV0b0JhdGNoVHJhY2luZyA/PyB0aGlzLmF1dG9CYXRjaFRyYWNpbmc7XG4gICAgICAgIHRoaXMuYmxvY2tPblJvb3RSdW5GaW5hbGl6YXRpb24gPVxuICAgICAgICAgICAgY29uZmlnLmJsb2NrT25Sb290UnVuRmluYWxpemF0aW9uID8/IHRoaXMuYmxvY2tPblJvb3RSdW5GaW5hbGl6YXRpb247XG4gICAgICAgIHRoaXMuYmF0Y2hTaXplQnl0ZXNMaW1pdCA9IGNvbmZpZy5iYXRjaFNpemVCeXRlc0xpbWl0O1xuICAgICAgICB0aGlzLmZldGNoT3B0aW9ucyA9IGNvbmZpZy5mZXRjaE9wdGlvbnMgfHwge307XG4gICAgfVxuICAgIHN0YXRpYyBnZXREZWZhdWx0Q2xpZW50Q29uZmlnKCkge1xuICAgICAgICBjb25zdCBhcGlLZXkgPSBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKFwiQVBJX0tFWVwiKTtcbiAgICAgICAgY29uc3QgYXBpVXJsID0gZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIkVORFBPSU5UXCIpID8/XG4gICAgICAgICAgICBcImh0dHBzOi8vYXBpLnNtaXRoLmxhbmdjaGFpbi5jb21cIjtcbiAgICAgICAgY29uc3QgaGlkZUlucHV0cyA9IGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUoXCJISURFX0lOUFVUU1wiKSA9PT0gXCJ0cnVlXCI7XG4gICAgICAgIGNvbnN0IGhpZGVPdXRwdXRzID0gZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIkhJREVfT1VUUFVUU1wiKSA9PT0gXCJ0cnVlXCI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhcGlVcmw6IGFwaVVybCxcbiAgICAgICAgICAgIGFwaUtleTogYXBpS2V5LFxuICAgICAgICAgICAgd2ViVXJsOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBoaWRlSW5wdXRzOiBoaWRlSW5wdXRzLFxuICAgICAgICAgICAgaGlkZU91dHB1dHM6IGhpZGVPdXRwdXRzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRIb3N0VXJsKCkge1xuICAgICAgICBpZiAodGhpcy53ZWJVcmwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlYlVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0xvY2FsaG9zdCh0aGlzLmFwaVVybCkpIHtcbiAgICAgICAgICAgIHRoaXMud2ViVXJsID0gXCJodHRwOi8vbG9jYWxob3N0OjMwMDBcIjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlYlVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFwaVVybC5pbmNsdWRlcyhcIi9hcGlcIikgJiZcbiAgICAgICAgICAgICF0aGlzLmFwaVVybC5zcGxpdChcIi5cIiwgMSlbMF0uZW5kc1dpdGgoXCJhcGlcIikpIHtcbiAgICAgICAgICAgIHRoaXMud2ViVXJsID0gdGhpcy5hcGlVcmwucmVwbGFjZShcIi9hcGlcIiwgXCJcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53ZWJVcmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hcGlVcmwuc3BsaXQoXCIuXCIsIDEpWzBdLmluY2x1ZGVzKFwiZGV2XCIpKSB7XG4gICAgICAgICAgICB0aGlzLndlYlVybCA9IFwiaHR0cHM6Ly9kZXYuc21pdGgubGFuZ2NoYWluLmNvbVwiO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2ViVXJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYXBpVXJsLnNwbGl0KFwiLlwiLCAxKVswXS5pbmNsdWRlcyhcImV1XCIpKSB7XG4gICAgICAgICAgICB0aGlzLndlYlVybCA9IFwiaHR0cHM6Ly9ldS5zbWl0aC5sYW5nY2hhaW4uY29tXCI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53ZWJVcmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndlYlVybCA9IFwiaHR0cHM6Ly9zbWl0aC5sYW5nY2hhaW4uY29tXCI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53ZWJVcmw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGhlYWRlcnMoKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICBcIlVzZXItQWdlbnRcIjogYGxhbmdzbWl0aC1qcy8ke19fdmVyc2lvbl9ffWAsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmFwaUtleSkge1xuICAgICAgICAgICAgaGVhZGVyc1tcIngtYXBpLWtleVwiXSA9IGAke3RoaXMuYXBpS2V5fWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIHByb2Nlc3NJbnB1dHMoaW5wdXRzKSB7XG4gICAgICAgIGlmICh0aGlzLmhpZGVJbnB1dHMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhpZGVJbnB1dHMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaGlkZUlucHV0cyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oaWRlSW5wdXRzKGlucHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0cztcbiAgICB9XG4gICAgcHJvY2Vzc091dHB1dHMob3V0cHV0cykge1xuICAgICAgICBpZiAodGhpcy5oaWRlT3V0cHV0cyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhpZGVPdXRwdXRzID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmhpZGVPdXRwdXRzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhpZGVPdXRwdXRzKG91dHB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXRzO1xuICAgIH1cbiAgICBwcmVwYXJlUnVuQ3JlYXRlT3JVcGRhdGVJbnB1dHMocnVuKSB7XG4gICAgICAgIGNvbnN0IHJ1blBhcmFtcyA9IHsgLi4ucnVuIH07XG4gICAgICAgIGlmIChydW5QYXJhbXMuaW5wdXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJ1blBhcmFtcy5pbnB1dHMgPSB0aGlzLnByb2Nlc3NJbnB1dHMocnVuUGFyYW1zLmlucHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1blBhcmFtcy5vdXRwdXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJ1blBhcmFtcy5vdXRwdXRzID0gdGhpcy5wcm9jZXNzT3V0cHV0cyhydW5QYXJhbXMub3V0cHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1blBhcmFtcztcbiAgICB9XG4gICAgYXN5bmMgX2dldFJlc3BvbnNlKHBhdGgsIHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtc1N0cmluZyA9IHF1ZXJ5UGFyYW1zPy50b1N0cmluZygpID8/IFwiXCI7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYXBpVXJsfSR7cGF0aH0/JHtwYXJhbXNTdHJpbmd9YDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIHVybCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBgRmFpbGVkIHRvIGZldGNoICR7cGF0aH1gKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0KHBhdGgsIHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZ2V0UmVzcG9uc2UocGF0aCwgcXVlcnlQYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBhc3luYyAqX2dldFBhZ2luYXRlZChwYXRoLCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKSwgdHJhbnNmb3JtKSB7XG4gICAgICAgIGxldCBvZmZzZXQgPSBOdW1iZXIocXVlcnlQYXJhbXMuZ2V0KFwib2Zmc2V0XCIpKSB8fCAwO1xuICAgICAgICBjb25zdCBsaW1pdCA9IE51bWJlcihxdWVyeVBhcmFtcy5nZXQoXCJsaW1pdFwiKSkgfHwgMTAwO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMuc2V0KFwib2Zmc2V0XCIsIFN0cmluZyhvZmZzZXQpKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLnNldChcImxpbWl0XCIsIFN0cmluZyhsaW1pdCkpO1xuICAgICAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5hcGlVcmx9JHtwYXRofT8ke3F1ZXJ5UGFyYW1zfWA7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgdXJsLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIGBGYWlsZWQgdG8gZmV0Y2ggJHtwYXRofWApO1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSB0cmFuc2Zvcm1cbiAgICAgICAgICAgICAgICA/IHRyYW5zZm9ybShhd2FpdCByZXNwb25zZS5qc29uKCkpXG4gICAgICAgICAgICAgICAgOiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCBpdGVtcztcbiAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPCBsaW1pdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IGl0ZW1zLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAqX2dldEN1cnNvclBhZ2luYXRlZExpc3QocGF0aCwgYm9keSA9IG51bGwsIHJlcXVlc3RNZXRob2QgPSBcIlBPU1RcIiwgZGF0YUtleSA9IFwicnVuc1wiKSB7XG4gICAgICAgIGNvbnN0IGJvZHlQYXJhbXMgPSBib2R5ID8geyAuLi5ib2R5IH0gOiB7fTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0ke3BhdGh9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogcmVxdWVzdE1ldGhvZCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5UGFyYW1zKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZUJvZHkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzcG9uc2VCb2R5W2RhdGFLZXldKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCByZXNwb25zZUJvZHlbZGF0YUtleV07XG4gICAgICAgICAgICBjb25zdCBjdXJzb3JzID0gcmVzcG9uc2VCb2R5LmN1cnNvcnM7XG4gICAgICAgICAgICBpZiAoIWN1cnNvcnMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY3Vyc29ycy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib2R5UGFyYW1zLmN1cnNvciA9IGN1cnNvcnMubmV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZmlsdGVyRm9yU2FtcGxpbmcocnVucywgcGF0Y2ggPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy50cmFjaW5nU2FtcGxlUmF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcnVucztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZWQgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcnVuIG9mIHJ1bnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZmlsdGVyZWRQb3N0VXVpZHMuaGFzKHJ1bi5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlZC5wdXNoKHJ1bik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcmVkUG9zdFV1aWRzLmRlbGV0ZShydW4uaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2FtcGxlZCA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBydW4gb2YgcnVucykge1xuICAgICAgICAgICAgICAgIGlmICgocnVuLmlkICE9PSBydW4udHJhY2VfaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMuZmlsdGVyZWRQb3N0VXVpZHMuaGFzKHJ1bi50cmFjZV9pZCkpIHx8XG4gICAgICAgICAgICAgICAgICAgIE1hdGgucmFuZG9tKCkgPCB0aGlzLnRyYWNpbmdTYW1wbGVSYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZWQucHVzaChydW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJlZFBvc3RVdWlkcy5hZGQocnVuLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfZ2V0QmF0Y2hTaXplTGltaXRCeXRlcygpIHtcbiAgICAgICAgY29uc3Qgc2VydmVySW5mbyA9IGF3YWl0IHRoaXMuX2Vuc3VyZVNlcnZlckluZm8oKTtcbiAgICAgICAgcmV0dXJuICh0aGlzLmJhdGNoU2l6ZUJ5dGVzTGltaXQgPz9cbiAgICAgICAgICAgIHNlcnZlckluZm8uYmF0Y2hfaW5nZXN0X2NvbmZpZz8uc2l6ZV9saW1pdF9ieXRlcyA/P1xuICAgICAgICAgICAgREVGQVVMVF9CQVRDSF9TSVpFX0xJTUlUX0JZVEVTKTtcbiAgICB9XG4gICAgYXN5bmMgZHJhaW5BdXRvQmF0Y2hRdWV1ZSgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuYXV0b0JhdGNoUXVldWUuaXRlbXMubGVuZ3RoID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IFtiYXRjaCwgZG9uZV0gPSB0aGlzLmF1dG9CYXRjaFF1ZXVlLnBvcChhd2FpdCB0aGlzLl9nZXRCYXRjaFNpemVMaW1pdEJ5dGVzKCkpO1xuICAgICAgICAgICAgaWYgKCFiYXRjaC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmdlc3RQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bkNyZWF0ZXM6IGJhdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChpdGVtKSA9PiBpdGVtLmFjdGlvbiA9PT0gXCJjcmVhdGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKGl0ZW0pID0+IGl0ZW0uaXRlbSksXG4gICAgICAgICAgICAgICAgICAgIHJ1blVwZGF0ZXM6IGJhdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChpdGVtKSA9PiBpdGVtLmFjdGlvbiA9PT0gXCJ1cGRhdGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKGl0ZW0pID0+IGl0ZW0uaXRlbSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJJbmZvID0gYXdhaXQgdGhpcy5fZW5zdXJlU2VydmVySW5mbygpO1xuICAgICAgICAgICAgICAgIGlmIChzZXJ2ZXJJbmZvPy5iYXRjaF9pbmdlc3RfY29uZmlnPy51c2VfbXVsdGlwYXJ0X2VuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMubXVsdGlwYXJ0SW5nZXN0UnVucyhpbmdlc3RQYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5iYXRjaEluZ2VzdFJ1bnMoaW5nZXN0UGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcHJvY2Vzc1J1bk9wZXJhdGlvbihpdGVtLCBpbW1lZGlhdGVseVRyaWdnZXJCYXRjaCkge1xuICAgICAgICBjb25zdCBvbGRUaW1lb3V0ID0gdGhpcy5hdXRvQmF0Y2hUaW1lb3V0O1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5hdXRvQmF0Y2hUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5hdXRvQmF0Y2hUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoaXRlbS5hY3Rpb24gPT09IFwiY3JlYXRlXCIpIHtcbiAgICAgICAgICAgIGl0ZW0uaXRlbSA9IG1lcmdlUnVudGltZUVudkludG9SdW5DcmVhdGUoaXRlbS5pdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpdGVtUHJvbWlzZSA9IHRoaXMuYXV0b0JhdGNoUXVldWUucHVzaChpdGVtKTtcbiAgICAgICAgY29uc3Qgc2l6ZUxpbWl0Qnl0ZXMgPSBhd2FpdCB0aGlzLl9nZXRCYXRjaFNpemVMaW1pdEJ5dGVzKCk7XG4gICAgICAgIGlmIChpbW1lZGlhdGVseVRyaWdnZXJCYXRjaCB8fFxuICAgICAgICAgICAgdGhpcy5hdXRvQmF0Y2hRdWV1ZS5zaXplQnl0ZXMgPiBzaXplTGltaXRCeXRlcykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5kcmFpbkF1dG9CYXRjaFF1ZXVlKCkuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXV0b0JhdGNoUXVldWUuaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5hdXRvQmF0Y2hUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvQmF0Y2hUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgZXJyb3Igd291bGQgaGFwcGVuIGluIHRoZSBiYWNrZ3JvdW5kIGFuZCBpcyB1bmNhdGNoYWJsZVxuICAgICAgICAgICAgICAgIC8vIGZyb20gdGhlIG91dHNpZGUuIFNvIGp1c3QgbG9nIGluc3RlYWQuXG4gICAgICAgICAgICAgICAgdm9pZCB0aGlzLmRyYWluQXV0b0JhdGNoUXVldWUoKS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgICAgIH0sIG9sZFRpbWVvdXRcbiAgICAgICAgICAgICAgICA/IHRoaXMuYXV0b0JhdGNoQWdncmVnYXRpb25EZWxheU1zXG4gICAgICAgICAgICAgICAgOiB0aGlzLmF1dG9CYXRjaEluaXRpYWxEZWxheU1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbVByb21pc2U7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRTZXJ2ZXJJbmZvKCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCkoYCR7dGhpcy5hcGlVcmx9L2luZm9gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dChTRVJWRVJfSU5GT19SRVFVRVNUX1RJTUVPVVQpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJnZXQgc2VydmVyIGluZm9cIik7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jIF9lbnN1cmVTZXJ2ZXJJbmZvKCkge1xuICAgICAgICBpZiAodGhpcy5fZ2V0U2VydmVySW5mb1Byb21pc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fZ2V0U2VydmVySW5mb1Byb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zZXJ2ZXJJbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlcnZlckluZm8gPSBhd2FpdCB0aGlzLl9nZXRTZXJ2ZXJJbmZvKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgW1dBUk5JTkddOiBMYW5nU21pdGggZmFpbGVkIHRvIGZldGNoIGluZm8gb24gc3VwcG9ydGVkIG9wZXJhdGlvbnMuIEZhbGxpbmcgYmFjayB0byBzaW5nbGUgY2FsbHMgYW5kIGRlZmF1bHQgbGltaXRzLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXJ2ZXJJbmZvID8/IHt9O1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U2VydmVySW5mb1Byb21pc2UudGhlbigoc2VydmVySW5mbykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NlcnZlckluZm8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2dldFNlcnZlckluZm9Qcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlcnZlckluZm87XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0U2V0dGluZ3MoKSB7XG4gICAgICAgIGlmICghdGhpcy5zZXR0aW5ncykge1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHRoaXMuX2dldChcIi9zZXR0aW5nc1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXR0aW5ncztcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlUnVuKHJ1bikge1xuICAgICAgICBpZiAoIXRoaXMuX2ZpbHRlckZvclNhbXBsaW5nKFtydW5dKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzID0geyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH07XG4gICAgICAgIGNvbnN0IHNlc3Npb25fbmFtZSA9IHJ1bi5wcm9qZWN0X25hbWU7XG4gICAgICAgIGRlbGV0ZSBydW4ucHJvamVjdF9uYW1lO1xuICAgICAgICBjb25zdCBydW5DcmVhdGUgPSB0aGlzLnByZXBhcmVSdW5DcmVhdGVPclVwZGF0ZUlucHV0cyh7XG4gICAgICAgICAgICBzZXNzaW9uX25hbWUsXG4gICAgICAgICAgICAuLi5ydW4sXG4gICAgICAgICAgICBzdGFydF90aW1lOiBydW4uc3RhcnRfdGltZSA/PyBEYXRlLm5vdygpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0JhdGNoVHJhY2luZyAmJlxuICAgICAgICAgICAgcnVuQ3JlYXRlLnRyYWNlX2lkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHJ1bkNyZWF0ZS5kb3R0ZWRfb3JkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdm9pZCB0aGlzLnByb2Nlc3NSdW5PcGVyYXRpb24oe1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJjcmVhdGVcIixcbiAgICAgICAgICAgICAgICBpdGVtOiBydW5DcmVhdGUsXG4gICAgICAgICAgICB9KS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXJnZWRSdW5DcmVhdGVQYXJhbSA9IG1lcmdlUnVudGltZUVudkludG9SdW5DcmVhdGUocnVuQ3JlYXRlKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9ydW5zYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBzdHJpbmdpZnlGb3JUcmFjaW5nKG1lcmdlZFJ1bkNyZWF0ZVBhcmFtKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJjcmVhdGUgcnVuXCIsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCYXRjaCBpbmdlc3QvdXBzZXJ0IG11bHRpcGxlIHJ1bnMgaW4gdGhlIExhbmdzbWl0aCBzeXN0ZW0uXG4gICAgICogQHBhcmFtIHJ1bnNcbiAgICAgKi9cbiAgICBhc3luYyBiYXRjaEluZ2VzdFJ1bnMoeyBydW5DcmVhdGVzLCBydW5VcGRhdGVzLCB9KSB7XG4gICAgICAgIGlmIChydW5DcmVhdGVzID09PSB1bmRlZmluZWQgJiYgcnVuVXBkYXRlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByZXBhcmVkQ3JlYXRlUGFyYW1zID0gcnVuQ3JlYXRlcz8ubWFwKChjcmVhdGUpID0+IHRoaXMucHJlcGFyZVJ1bkNyZWF0ZU9yVXBkYXRlSW5wdXRzKGNyZWF0ZSkpID8/IFtdO1xuICAgICAgICBsZXQgcHJlcGFyZWRVcGRhdGVQYXJhbXMgPSBydW5VcGRhdGVzPy5tYXAoKHVwZGF0ZSkgPT4gdGhpcy5wcmVwYXJlUnVuQ3JlYXRlT3JVcGRhdGVJbnB1dHModXBkYXRlKSkgPz8gW107XG4gICAgICAgIGlmIChwcmVwYXJlZENyZWF0ZVBhcmFtcy5sZW5ndGggPiAwICYmIHByZXBhcmVkVXBkYXRlUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZUJ5SWQgPSBwcmVwYXJlZENyZWF0ZVBhcmFtcy5yZWR1Y2UoKHBhcmFtcywgcnVuKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFydW4uaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyYW1zW3J1bi5pZF0gPSBydW47XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YW5kYWxvbmVVcGRhdGVzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHVwZGF0ZVBhcmFtIG9mIHByZXBhcmVkVXBkYXRlUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZVBhcmFtLmlkICE9PSB1bmRlZmluZWQgJiYgY3JlYXRlQnlJZFt1cGRhdGVQYXJhbS5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlQnlJZFt1cGRhdGVQYXJhbS5pZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jcmVhdGVCeUlkW3VwZGF0ZVBhcmFtLmlkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnVwZGF0ZVBhcmFtLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhbmRhbG9uZVVwZGF0ZXMucHVzaCh1cGRhdGVQYXJhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlcGFyZWRDcmVhdGVQYXJhbXMgPSBPYmplY3QudmFsdWVzKGNyZWF0ZUJ5SWQpO1xuICAgICAgICAgICAgcHJlcGFyZWRVcGRhdGVQYXJhbXMgPSBzdGFuZGFsb25lVXBkYXRlcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYXdCYXRjaCA9IHtcbiAgICAgICAgICAgIHBvc3Q6IHRoaXMuX2ZpbHRlckZvclNhbXBsaW5nKHByZXBhcmVkQ3JlYXRlUGFyYW1zKSxcbiAgICAgICAgICAgIHBhdGNoOiB0aGlzLl9maWx0ZXJGb3JTYW1wbGluZyhwcmVwYXJlZFVwZGF0ZVBhcmFtcywgdHJ1ZSksXG4gICAgICAgIH07XG4gICAgICAgIGlmICghcmF3QmF0Y2gucG9zdC5sZW5ndGggJiYgIXJhd0JhdGNoLnBhdGNoLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlcnZlckluZm8gPSBhd2FpdCB0aGlzLl9lbnN1cmVTZXJ2ZXJJbmZvKCk7XG4gICAgICAgIGlmIChzZXJ2ZXJJbmZvLnZlcnNpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5hdXRvQmF0Y2hUcmFjaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByZXBhcmVkQ3JlYXRlUGFyYW0gb2YgcmF3QmF0Y2gucG9zdCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY3JlYXRlUnVuKHByZXBhcmVkQ3JlYXRlUGFyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBwcmVwYXJlZFVwZGF0ZVBhcmFtIG9mIHJhd0JhdGNoLnBhdGNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXBhcmVkVXBkYXRlUGFyYW0uaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZVJ1bihwcmVwYXJlZFVwZGF0ZVBhcmFtLmlkLCBwcmVwYXJlZFVwZGF0ZVBhcmFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmF0Y2hDaHVua3MgPSB7XG4gICAgICAgICAgICBwb3N0OiBbXSxcbiAgICAgICAgICAgIHBhdGNoOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChjb25zdCBrIG9mIFtcInBvc3RcIiwgXCJwYXRjaFwiXSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gaztcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoSXRlbXMgPSByYXdCYXRjaFtrZXldLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGxldCBiYXRjaEl0ZW0gPSBiYXRjaEl0ZW1zLnBvcCgpO1xuICAgICAgICAgICAgd2hpbGUgKGJhdGNoSXRlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYmF0Y2hDaHVua3Nba2V5XS5wdXNoKGJhdGNoSXRlbSk7XG4gICAgICAgICAgICAgICAgYmF0Y2hJdGVtID0gYmF0Y2hJdGVtcy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmF0Y2hDaHVua3MucG9zdC5sZW5ndGggPiAwIHx8IGJhdGNoQ2h1bmtzLnBhdGNoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3Bvc3RCYXRjaEluZ2VzdFJ1bnMoc3RyaW5naWZ5Rm9yVHJhY2luZyhiYXRjaENodW5rcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9wb3N0QmF0Y2hJbmdlc3RSdW5zKGJvZHkpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmJhdGNoSW5nZXN0Q2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L3J1bnMvYmF0Y2hgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiYmF0Y2ggY3JlYXRlIHJ1blwiLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmF0Y2ggaW5nZXN0L3Vwc2VydCBtdWx0aXBsZSBydW5zIGluIHRoZSBMYW5nc21pdGggc3lzdGVtLlxuICAgICAqIEBwYXJhbSBydW5zXG4gICAgICovXG4gICAgYXN5bmMgbXVsdGlwYXJ0SW5nZXN0UnVucyh7IHJ1bkNyZWF0ZXMsIHJ1blVwZGF0ZXMsIH0pIHtcbiAgICAgICAgaWYgKHJ1bkNyZWF0ZXMgPT09IHVuZGVmaW5lZCAmJiBydW5VcGRhdGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB0cmFuc2Zvcm0gYW5kIGNvbnZlcnQgdG8gZGljdHNcbiAgICAgICAgY29uc3QgYWxsQXR0YWNobWVudHMgPSB7fTtcbiAgICAgICAgbGV0IHByZXBhcmVkQ3JlYXRlUGFyYW1zID0gW107XG4gICAgICAgIGZvciAoY29uc3QgY3JlYXRlIG9mIHJ1bkNyZWF0ZXMgPz8gW10pIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXBhcmVkQ3JlYXRlID0gdGhpcy5wcmVwYXJlUnVuQ3JlYXRlT3JVcGRhdGVJbnB1dHMoY3JlYXRlKTtcbiAgICAgICAgICAgIGlmIChwcmVwYXJlZENyZWF0ZS5pZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgcHJlcGFyZWRDcmVhdGUuYXR0YWNobWVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGFsbEF0dGFjaG1lbnRzW3ByZXBhcmVkQ3JlYXRlLmlkXSA9IHByZXBhcmVkQ3JlYXRlLmF0dGFjaG1lbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIHByZXBhcmVkQ3JlYXRlLmF0dGFjaG1lbnRzO1xuICAgICAgICAgICAgcHJlcGFyZWRDcmVhdGVQYXJhbXMucHVzaChwcmVwYXJlZENyZWF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByZXBhcmVkVXBkYXRlUGFyYW1zID0gW107XG4gICAgICAgIGZvciAoY29uc3QgdXBkYXRlIG9mIHJ1blVwZGF0ZXMgPz8gW10pIHtcbiAgICAgICAgICAgIHByZXBhcmVkVXBkYXRlUGFyYW1zLnB1c2godGhpcy5wcmVwYXJlUnVuQ3JlYXRlT3JVcGRhdGVJbnB1dHModXBkYXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVxdWlyZSB0cmFjZV9pZCBhbmQgZG90dGVkX29yZGVyXG4gICAgICAgIGNvbnN0IGludmFsaWRSdW5DcmVhdGUgPSBwcmVwYXJlZENyZWF0ZVBhcmFtcy5maW5kKChydW5DcmVhdGUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAocnVuQ3JlYXRlLnRyYWNlX2lkID09PSB1bmRlZmluZWQgfHwgcnVuQ3JlYXRlLmRvdHRlZF9vcmRlciA9PT0gdW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpbnZhbGlkUnVuQ3JlYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTXVsdGlwYXJ0IGluZ2VzdCByZXF1aXJlcyBcInRyYWNlX2lkXCIgYW5kIFwiZG90dGVkX29yZGVyXCIgdG8gYmUgc2V0IHdoZW4gY3JlYXRpbmcgYSBydW5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnZhbGlkUnVuVXBkYXRlID0gcHJlcGFyZWRVcGRhdGVQYXJhbXMuZmluZCgocnVuVXBkYXRlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKHJ1blVwZGF0ZS50cmFjZV9pZCA9PT0gdW5kZWZpbmVkIHx8IHJ1blVwZGF0ZS5kb3R0ZWRfb3JkZXIgPT09IHVuZGVmaW5lZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaW52YWxpZFJ1blVwZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE11bHRpcGFydCBpbmdlc3QgcmVxdWlyZXMgXCJ0cmFjZV9pZFwiIGFuZCBcImRvdHRlZF9vcmRlclwiIHRvIGJlIHNldCB3aGVuIHVwZGF0aW5nIGEgcnVuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29tYmluZSBwb3N0IGFuZCBwYXRjaCBkaWN0cyB3aGVyZSBwb3NzaWJsZVxuICAgICAgICBpZiAocHJlcGFyZWRDcmVhdGVQYXJhbXMubGVuZ3RoID4gMCAmJiBwcmVwYXJlZFVwZGF0ZVBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjcmVhdGVCeUlkID0gcHJlcGFyZWRDcmVhdGVQYXJhbXMucmVkdWNlKChwYXJhbXMsIHJ1bikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcnVuLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmFtc1tydW4uaWRdID0gcnVuO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICBjb25zdCBzdGFuZGFsb25lVXBkYXRlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCB1cGRhdGVQYXJhbSBvZiBwcmVwYXJlZFVwZGF0ZVBhcmFtcykge1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVQYXJhbS5pZCAhPT0gdW5kZWZpbmVkICYmIGNyZWF0ZUJ5SWRbdXBkYXRlUGFyYW0uaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUJ5SWRbdXBkYXRlUGFyYW0uaWRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3JlYXRlQnlJZFt1cGRhdGVQYXJhbS5pZF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi51cGRhdGVQYXJhbSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YW5kYWxvbmVVcGRhdGVzLnB1c2godXBkYXRlUGFyYW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXBhcmVkQ3JlYXRlUGFyYW1zID0gT2JqZWN0LnZhbHVlcyhjcmVhdGVCeUlkKTtcbiAgICAgICAgICAgIHByZXBhcmVkVXBkYXRlUGFyYW1zID0gc3RhbmRhbG9uZVVwZGF0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXBhcmVkQ3JlYXRlUGFyYW1zLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgcHJlcGFyZWRVcGRhdGVQYXJhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2VuZCB0aGUgcnVucyBpbiBtdWx0aXBhcnQgcmVxdWVzdHNcbiAgICAgICAgY29uc3QgYWNjdW11bGF0ZWRDb250ZXh0ID0gW107XG4gICAgICAgIGNvbnN0IGFjY3VtdWxhdGVkUGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBbbWV0aG9kLCBwYXlsb2Fkc10gb2YgW1xuICAgICAgICAgICAgW1wicG9zdFwiLCBwcmVwYXJlZENyZWF0ZVBhcmFtc10sXG4gICAgICAgICAgICBbXCJwYXRjaFwiLCBwcmVwYXJlZFVwZGF0ZVBhcmFtc10sXG4gICAgICAgIF0pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3JpZ2luYWxQYXlsb2FkIG9mIHBheWxvYWRzKSB7XG4gICAgICAgICAgICAgICAgLy8gY29sbGVjdCBmaWVsZHMgdG8gYmUgc2VudCBhcyBzZXBhcmF0ZSBwYXJ0c1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaW5wdXRzLCBvdXRwdXRzLCBldmVudHMsIC4uLnBheWxvYWQgfSA9IG9yaWdpbmFsUGF5bG9hZDtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZHMgPSB7IGlucHV0cywgb3V0cHV0cywgZXZlbnRzIH07XG4gICAgICAgICAgICAgICAgLy8gZW5jb2RlIHRoZSBtYWluIHJ1biBwYXlsb2FkXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRQYXlsb2FkID0gc3RyaW5naWZ5Rm9yVHJhY2luZyhwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRlZFBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBgJHttZXRob2R9LiR7cGF5bG9hZC5pZH1gLFxuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBuZXcgQmxvYihbc3RyaW5naWZpZWRQYXlsb2FkXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYGFwcGxpY2F0aW9uL2pzb247IGxlbmd0aD0ke3N0cmluZ2lmaWVkUGF5bG9hZC5sZW5ndGh9YCwgLy8gZW5jb2Rpbmc9Z3ppcFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBlbmNvZGUgdGhlIGZpZWxkcyB3ZSBjb2xsZWN0ZWRcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmaWVsZHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdpZmllZFZhbHVlID0gc3RyaW5naWZ5Rm9yVHJhY2luZyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkUGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBgJHttZXRob2R9LiR7cGF5bG9hZC5pZH0uJHtrZXl9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IG5ldyBCbG9iKFtzdHJpbmdpZmllZFZhbHVlXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGBhcHBsaWNhdGlvbi9qc29uOyBsZW5ndGg9JHtzdHJpbmdpZmllZFZhbHVlLmxlbmd0aH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlbmNvZGUgdGhlIGF0dGFjaG1lbnRzXG4gICAgICAgICAgICAgICAgaWYgKHBheWxvYWQuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRhY2htZW50cyA9IGFsbEF0dGFjaG1lbnRzW3BheWxvYWQuaWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0YWNobWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhbGxBdHRhY2htZW50c1twYXlsb2FkLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIFtjb250ZW50VHlwZSwgY29udGVudF1dIG9mIE9iamVjdC5lbnRyaWVzKGF0dGFjaG1lbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkUGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGBhdHRhY2htZW50LiR7cGF5bG9hZC5pZH0uJHtuYW1lfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IG5ldyBCbG9iKFtjb250ZW50XSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYCR7Y29udGVudFR5cGV9OyBsZW5ndGg9JHtjb250ZW50Lmxlbmd0aH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjb21wdXRlIGNvbnRleHRcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRlZENvbnRleHQucHVzaChgdHJhY2U9JHtwYXlsb2FkLnRyYWNlX2lkfSxpZD0ke3BheWxvYWQuaWR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5fc2VuZE11bHRpcGFydFJlcXVlc3QoYWNjdW11bGF0ZWRQYXJ0cywgYWNjdW11bGF0ZWRDb250ZXh0LmpvaW4oXCI7IFwiKSk7XG4gICAgfVxuICAgIGFzeW5jIF9zZW5kTXVsdGlwYXJ0UmVxdWVzdChwYXJ0cywgY29udGV4dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChwYXJ0Lm5hbWUsIHBhcnQucGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmJhdGNoSW5nZXN0Q2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L3J1bnMvbXVsdGlwYXJ0YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAuLi50aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gXCJGYWlsZWQgdG8gbXVsdGlwYXJ0IGluZ2VzdCBydW5zXCI7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9IGA6ICR7ZS5zdGFjayB8fCBlLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPSBgOiAke1N0cmluZyhlKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS53YXJuKGAke2Vycm9yTWVzc2FnZS50cmltKCl9XFxuXFxuQ29udGV4dDogJHtjb250ZXh0fWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZVJ1bihydW5JZCwgcnVuKSB7XG4gICAgICAgIGFzc2VydFV1aWQocnVuSWQpO1xuICAgICAgICBpZiAocnVuLmlucHV0cykge1xuICAgICAgICAgICAgcnVuLmlucHV0cyA9IHRoaXMucHJvY2Vzc0lucHV0cyhydW4uaW5wdXRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVuLm91dHB1dHMpIHtcbiAgICAgICAgICAgIHJ1bi5vdXRwdXRzID0gdGhpcy5wcm9jZXNzT3V0cHV0cyhydW4ub3V0cHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogVW50YW5nbGUgdHlwZXNcbiAgICAgICAgY29uc3QgZGF0YSA9IHsgLi4ucnVuLCBpZDogcnVuSWQgfTtcbiAgICAgICAgaWYgKCF0aGlzLl9maWx0ZXJGb3JTYW1wbGluZyhbZGF0YV0sIHRydWUpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF1dG9CYXRjaFRyYWNpbmcgJiZcbiAgICAgICAgICAgIGRhdGEudHJhY2VfaWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgZGF0YS5kb3R0ZWRfb3JkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHJ1bi5lbmRfdGltZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgZGF0YS5wYXJlbnRfcnVuX2lkID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmJsb2NrT25Sb290UnVuRmluYWxpemF0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJpZ2dlciBhIGJhdGNoIGFzIHNvb24gYXMgYSByb290IHRyYWNlIGVuZHMgYW5kIGJsb2NrIHRvIGVuc3VyZSB0cmFjZSBmaW5pc2hlc1xuICAgICAgICAgICAgICAgIC8vIGluIHNlcnZlcmxlc3MgZW52aXJvbm1lbnRzLlxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc1J1bk9wZXJhdGlvbih7IGFjdGlvbjogXCJ1cGRhdGVcIiwgaXRlbTogZGF0YSB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2b2lkIHRoaXMucHJvY2Vzc1J1bk9wZXJhdGlvbih7IGFjdGlvbjogXCJ1cGRhdGVcIiwgaXRlbTogZGF0YSB9KS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzID0geyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vcnVucy8ke3J1bklkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IHN0cmluZ2lmeUZvclRyYWNpbmcocnVuKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJ1cGRhdGUgcnVuXCIsIHRydWUpO1xuICAgIH1cbiAgICBhc3luYyByZWFkUnVuKHJ1bklkLCB7IGxvYWRDaGlsZFJ1bnMgfSA9IHsgbG9hZENoaWxkUnVuczogZmFsc2UgfSkge1xuICAgICAgICBhc3NlcnRVdWlkKHJ1bklkKTtcbiAgICAgICAgbGV0IHJ1biA9IGF3YWl0IHRoaXMuX2dldChgL3J1bnMvJHtydW5JZH1gKTtcbiAgICAgICAgaWYgKGxvYWRDaGlsZFJ1bnMgJiYgcnVuLmNoaWxkX3J1bl9pZHMpIHtcbiAgICAgICAgICAgIHJ1biA9IGF3YWl0IHRoaXMuX2xvYWRDaGlsZFJ1bnMocnVuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBhc3luYyBnZXRSdW5VcmwoeyBydW5JZCwgcnVuLCBwcm9qZWN0T3B0cywgfSkge1xuICAgICAgICBpZiAocnVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBzZXNzaW9uSWQ7XG4gICAgICAgICAgICBpZiAocnVuLnNlc3Npb25faWQpIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQgPSBydW4uc2Vzc2lvbl9pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb2plY3RPcHRzPy5wcm9qZWN0TmFtZSkge1xuICAgICAgICAgICAgICAgIHNlc3Npb25JZCA9IChhd2FpdCB0aGlzLnJlYWRQcm9qZWN0KHsgcHJvamVjdE5hbWU6IHByb2plY3RPcHRzPy5wcm9qZWN0TmFtZSB9KSkuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9qZWN0T3B0cz8ucHJvamVjdElkKSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkID0gcHJvamVjdE9wdHM/LnByb2plY3RJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb2plY3QgPSBhd2FpdCB0aGlzLnJlYWRQcm9qZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgcHJvamVjdE5hbWU6IGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUoXCJQUk9KRUNUXCIpIHx8IFwiZGVmYXVsdFwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNlc3Npb25JZCA9IHByb2plY3QuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0ZW5hbnRJZCA9IGF3YWl0IHRoaXMuX2dldFRlbmFudElkKCk7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L28vJHt0ZW5hbnRJZH0vcHJvamVjdHMvcC8ke3Nlc3Npb25JZH0vci8ke3J1bi5pZH0/cG9sbD10cnVlYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChydW5JZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBydW5fID0gYXdhaXQgdGhpcy5yZWFkUnVuKHJ1bklkKTtcbiAgICAgICAgICAgIGlmICghcnVuXy5hcHBfcGF0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUnVuICR7cnVuSWR9IGhhcyBubyBhcHBfcGF0aGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYmFzZVVybCA9IHRoaXMuZ2V0SG9zdFVybCgpO1xuICAgICAgICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9JHtydW5fLmFwcF9wYXRofWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHJ1bklkIG9yIHJ1blwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfbG9hZENoaWxkUnVucyhydW4pIHtcbiAgICAgICAgY29uc3QgY2hpbGRSdW5zID0gYXdhaXQgdG9BcnJheSh0aGlzLmxpc3RSdW5zKHsgaWQ6IHJ1bi5jaGlsZF9ydW5faWRzIH0pKTtcbiAgICAgICAgY29uc3QgdHJlZW1hcCA9IHt9O1xuICAgICAgICBjb25zdCBydW5zID0ge307XG4gICAgICAgIC8vIFRPRE86IG1ha2UgZG90dGVkIG9yZGVyIHJlcXVpcmVkIHdoZW4gdGhlIG1pZ3JhdGlvbiBmaW5pc2hlc1xuICAgICAgICBjaGlsZFJ1bnMuc29ydCgoYSwgYikgPT4gKGE/LmRvdHRlZF9vcmRlciA/PyBcIlwiKS5sb2NhbGVDb21wYXJlKGI/LmRvdHRlZF9vcmRlciA/PyBcIlwiKSk7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGRSdW4gb2YgY2hpbGRSdW5zKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRSdW4ucGFyZW50X3J1bl9pZCA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIGNoaWxkUnVuLnBhcmVudF9ydW5faWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2hpbGQgcnVuICR7Y2hpbGRSdW4uaWR9IGhhcyBubyBwYXJlbnRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKGNoaWxkUnVuLnBhcmVudF9ydW5faWQgaW4gdHJlZW1hcCkpIHtcbiAgICAgICAgICAgICAgICB0cmVlbWFwW2NoaWxkUnVuLnBhcmVudF9ydW5faWRdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmVlbWFwW2NoaWxkUnVuLnBhcmVudF9ydW5faWRdLnB1c2goY2hpbGRSdW4pO1xuICAgICAgICAgICAgcnVuc1tjaGlsZFJ1bi5pZF0gPSBjaGlsZFJ1bjtcbiAgICAgICAgfVxuICAgICAgICBydW4uY2hpbGRfcnVucyA9IHRyZWVtYXBbcnVuLmlkXSB8fCBbXTtcbiAgICAgICAgZm9yIChjb25zdCBydW5JZCBpbiB0cmVlbWFwKSB7XG4gICAgICAgICAgICBpZiAocnVuSWQgIT09IHJ1bi5pZCkge1xuICAgICAgICAgICAgICAgIHJ1bnNbcnVuSWRdLmNoaWxkX3J1bnMgPSB0cmVlbWFwW3J1bklkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IHJ1bnMgZnJvbSB0aGUgTGFuZ1NtaXRoIHNlcnZlci5cbiAgICAgKiBAcGFyYW0gcHJvamVjdElkIC0gVGhlIElEIG9mIHRoZSBwcm9qZWN0IHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gcHJvamVjdE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcHJvamVjdCB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIHBhcmVudFJ1bklkIC0gVGhlIElEIG9mIHRoZSBwYXJlbnQgcnVuIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gdHJhY2VJZCAtIFRoZSBJRCBvZiB0aGUgdHJhY2UgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSByZWZlcmVuY2VFeGFtcGxlSWQgLSBUaGUgSUQgb2YgdGhlIHJlZmVyZW5jZSBleGFtcGxlIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gc3RhcnRUaW1lIC0gVGhlIHN0YXJ0IHRpbWUgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSBpc1Jvb3QgLSBJbmRpY2F0ZXMgd2hldGhlciB0byBvbmx5IHJldHVybiByb290IHJ1bnMuXG4gICAgICogQHBhcmFtIHJ1blR5cGUgLSBUaGUgcnVuIHR5cGUgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSBlcnJvciAtIEluZGljYXRlcyB3aGV0aGVyIHRvIGZpbHRlciBieSBlcnJvciBydW5zLlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBJRCBvZiB0aGUgcnVuIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gcXVlcnkgLSBUaGUgcXVlcnkgc3RyaW5nIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gZmlsdGVyIC0gVGhlIGZpbHRlciBzdHJpbmcgdG8gYXBwbHkgdG8gdGhlIHJ1biBzcGFucy5cbiAgICAgKiBAcGFyYW0gdHJhY2VGaWx0ZXIgLSBUaGUgZmlsdGVyIHN0cmluZyB0byBhcHBseSBvbiB0aGUgcm9vdCBydW4gb2YgdGhlIHRyYWNlLlxuICAgICAqIEBwYXJhbSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBydW5zIHRvIHJldHJpZXZlLlxuICAgICAqIEByZXR1cm5zIHtBc3luY0l0ZXJhYmxlPFJ1bj59IC0gVGhlIHJ1bnMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgYWxsIHJ1bnMgaW4gYSBwcm9qZWN0XG4gICAgICogY29uc3QgcHJvamVjdFJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoeyBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IExMTSBhbmQgQ2hhdCBydW5zIGluIHRoZSBsYXN0IDI0IGhvdXJzXG4gICAgICogY29uc3QgdG9kYXlzTExNUnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgc3RhcnRfdGltZTogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDI0ICogNjAgKiA2MCAqIDEwMDApLFxuICAgICAqICAgcnVuX3R5cGU6IFwibGxtXCIsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgdHJhY2VzIGluIGEgcHJvamVjdFxuICAgICAqIGNvbnN0IHJvb3RSdW5zID0gY2xpZW50Lmxpc3RSdW5zKHtcbiAgICAgKiAgIHByb2plY3ROYW1lOiBcIjx5b3VyX3Byb2plY3Q+XCIsXG4gICAgICogICBleGVjdXRpb25fb3JkZXI6IDEsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgcnVucyB3aXRob3V0IGVycm9yc1xuICAgICAqIGNvbnN0IGNvcnJlY3RSdW5zID0gY2xpZW50Lmxpc3RSdW5zKHtcbiAgICAgKiAgIHByb2plY3ROYW1lOiBcIjx5b3VyX3Byb2plY3Q+XCIsXG4gICAgICogICBlcnJvcjogZmFsc2UsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgcnVucyBieSBydW4gSURcbiAgICAgKiBjb25zdCBydW5JZHMgPSBbXG4gICAgICogICBcImEzNjA5MmQyLTRhZDUtNGZiNC05YzBkLTBkYmE5YTJlZDgzNlwiLFxuICAgICAqICAgXCI5Mzk4ZTZiZS05NjRmLTRhYTQtOGFlOS1hZDc4Y2Q0YjcwNzRcIixcbiAgICAgKiBdO1xuICAgICAqIGNvbnN0IHNlbGVjdGVkUnVucyA9IGNsaWVudC5saXN0UnVucyh7IHJ1bl9pZHM6IHJ1bklkcyB9KTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTGlzdCBhbGwgXCJjaGFpblwiIHR5cGUgcnVucyB0aGF0IHRvb2sgbW9yZSB0aGFuIDEwIHNlY29uZHMgYW5kIGhhZCBgdG90YWxfdG9rZW5zYCBncmVhdGVyIHRoYW4gNTAwMFxuICAgICAqIGNvbnN0IGNoYWluUnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgZmlsdGVyOiAnYW5kKGVxKHJ1bl90eXBlLCBcImNoYWluXCIpLCBndChsYXRlbmN5LCAxMCksIGd0KHRvdGFsX3Rva2VucywgNTAwMCkpJyxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTGlzdCBhbGwgcnVucyBjYWxsZWQgXCJleHRyYWN0b3JcIiB3aG9zZSByb290IG9mIHRoZSB0cmFjZSB3YXMgYXNzaWduZWQgZmVlZGJhY2sgXCJ1c2VyX3Njb3JlXCIgc2NvcmUgb2YgMVxuICAgICAqIGNvbnN0IGdvb2RFeHRyYWN0b3JSdW5zID0gY2xpZW50Lmxpc3RSdW5zKHtcbiAgICAgKiAgIHByb2plY3ROYW1lOiBcIjx5b3VyX3Byb2plY3Q+XCIsXG4gICAgICogICBmaWx0ZXI6ICdlcShuYW1lLCBcImV4dHJhY3RvclwiKScsXG4gICAgICogICB0cmFjZUZpbHRlcjogJ2FuZChlcShmZWVkYmFja19rZXksIFwidXNlcl9zY29yZVwiKSwgZXEoZmVlZGJhY2tfc2NvcmUsIDEpKScsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgYWxsIHJ1bnMgdGhhdCBzdGFydGVkIGFmdGVyIGEgc3BlY2lmaWMgdGltZXN0YW1wIGFuZCBlaXRoZXIgaGF2ZSBcImVycm9yXCIgbm90IGVxdWFsIHRvIG51bGwgb3IgYSBcIkNvcnJlY3RuZXNzXCIgZmVlZGJhY2sgc2NvcmUgZXF1YWwgdG8gMFxuICAgICAqIGNvbnN0IGNvbXBsZXhSdW5zID0gY2xpZW50Lmxpc3RSdW5zKHtcbiAgICAgKiAgIHByb2plY3ROYW1lOiBcIjx5b3VyX3Byb2plY3Q+XCIsXG4gICAgICogICBmaWx0ZXI6ICdhbmQoZ3Qoc3RhcnRfdGltZSwgXCIyMDIzLTA3LTE1VDEyOjM0OjU2WlwiKSwgb3IobmVxKGVycm9yLCBudWxsKSwgYW5kKGVxKGZlZWRiYWNrX2tleSwgXCJDb3JyZWN0bmVzc1wiKSwgZXEoZmVlZGJhY2tfc2NvcmUsIDAuMCkpKSknLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IGFsbCBydW5zIHdoZXJlIGB0YWdzYCBpbmNsdWRlIFwiZXhwZXJpbWVudGFsXCIgb3IgXCJiZXRhXCIgYW5kIGBsYXRlbmN5YCBpcyBncmVhdGVyIHRoYW4gMiBzZWNvbmRzXG4gICAgICogY29uc3QgdGFnZ2VkUnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgZmlsdGVyOiAnYW5kKG9yKGhhcyh0YWdzLCBcImV4cGVyaW1lbnRhbFwiKSwgaGFzKHRhZ3MsIFwiYmV0YVwiKSksIGd0KGxhdGVuY3ksIDIpKScsXG4gICAgICogfSk7XG4gICAgICovXG4gICAgYXN5bmMgKmxpc3RSdW5zKHByb3BzKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvamVjdElkLCBwcm9qZWN0TmFtZSwgcGFyZW50UnVuSWQsIHRyYWNlSWQsIHJlZmVyZW5jZUV4YW1wbGVJZCwgc3RhcnRUaW1lLCBleGVjdXRpb25PcmRlciwgaXNSb290LCBydW5UeXBlLCBlcnJvciwgaWQsIHF1ZXJ5LCBmaWx0ZXIsIHRyYWNlRmlsdGVyLCB0cmVlRmlsdGVyLCBsaW1pdCwgc2VsZWN0LCB9ID0gcHJvcHM7XG4gICAgICAgIGxldCBwcm9qZWN0SWRzID0gW107XG4gICAgICAgIGlmIChwcm9qZWN0SWQpIHtcbiAgICAgICAgICAgIHByb2plY3RJZHMgPSBBcnJheS5pc0FycmF5KHByb2plY3RJZCkgPyBwcm9qZWN0SWQgOiBbcHJvamVjdElkXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvamVjdE5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb2plY3ROYW1lcyA9IEFycmF5LmlzQXJyYXkocHJvamVjdE5hbWUpXG4gICAgICAgICAgICAgICAgPyBwcm9qZWN0TmFtZVxuICAgICAgICAgICAgICAgIDogW3Byb2plY3ROYW1lXTtcbiAgICAgICAgICAgIGNvbnN0IHByb2plY3RJZHNfID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvamVjdE5hbWVzLm1hcCgobmFtZSkgPT4gdGhpcy5yZWFkUHJvamVjdCh7IHByb2plY3ROYW1lOiBuYW1lIH0pLnRoZW4oKHByb2plY3QpID0+IHByb2plY3QuaWQpKSk7XG4gICAgICAgICAgICBwcm9qZWN0SWRzLnB1c2goLi4ucHJvamVjdElkc18pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZmF1bHRfc2VsZWN0ID0gW1xuICAgICAgICAgICAgXCJhcHBfcGF0aFwiLFxuICAgICAgICAgICAgXCJjaGlsZF9ydW5faWRzXCIsXG4gICAgICAgICAgICBcImNvbXBsZXRpb25fY29zdFwiLFxuICAgICAgICAgICAgXCJjb21wbGV0aW9uX3Rva2Vuc1wiLFxuICAgICAgICAgICAgXCJkb3R0ZWRfb3JkZXJcIixcbiAgICAgICAgICAgIFwiZW5kX3RpbWVcIixcbiAgICAgICAgICAgIFwiZXJyb3JcIixcbiAgICAgICAgICAgIFwiZXZlbnRzXCIsXG4gICAgICAgICAgICBcImV4dHJhXCIsXG4gICAgICAgICAgICBcImZlZWRiYWNrX3N0YXRzXCIsXG4gICAgICAgICAgICBcImZpcnN0X3Rva2VuX3RpbWVcIixcbiAgICAgICAgICAgIFwiaWRcIixcbiAgICAgICAgICAgIFwiaW5wdXRzXCIsXG4gICAgICAgICAgICBcIm5hbWVcIixcbiAgICAgICAgICAgIFwib3V0cHV0c1wiLFxuICAgICAgICAgICAgXCJwYXJlbnRfcnVuX2lkXCIsXG4gICAgICAgICAgICBcInBhcmVudF9ydW5faWRzXCIsXG4gICAgICAgICAgICBcInByb21wdF9jb3N0XCIsXG4gICAgICAgICAgICBcInByb21wdF90b2tlbnNcIixcbiAgICAgICAgICAgIFwicmVmZXJlbmNlX2V4YW1wbGVfaWRcIixcbiAgICAgICAgICAgIFwicnVuX3R5cGVcIixcbiAgICAgICAgICAgIFwic2Vzc2lvbl9pZFwiLFxuICAgICAgICAgICAgXCJzdGFydF90aW1lXCIsXG4gICAgICAgICAgICBcInN0YXR1c1wiLFxuICAgICAgICAgICAgXCJ0YWdzXCIsXG4gICAgICAgICAgICBcInRvdGFsX2Nvc3RcIixcbiAgICAgICAgICAgIFwidG90YWxfdG9rZW5zXCIsXG4gICAgICAgICAgICBcInRyYWNlX2lkXCIsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBzZXNzaW9uOiBwcm9qZWN0SWRzLmxlbmd0aCA/IHByb2plY3RJZHMgOiBudWxsLFxuICAgICAgICAgICAgcnVuX3R5cGU6IHJ1blR5cGUsXG4gICAgICAgICAgICByZWZlcmVuY2VfZXhhbXBsZTogcmVmZXJlbmNlRXhhbXBsZUlkLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICB0cmFjZV9maWx0ZXI6IHRyYWNlRmlsdGVyLFxuICAgICAgICAgICAgdHJlZV9maWx0ZXI6IHRyZWVGaWx0ZXIsXG4gICAgICAgICAgICBleGVjdXRpb25fb3JkZXI6IGV4ZWN1dGlvbk9yZGVyLFxuICAgICAgICAgICAgcGFyZW50X3J1bjogcGFyZW50UnVuSWQsXG4gICAgICAgICAgICBzdGFydF90aW1lOiBzdGFydFRpbWUgPyBzdGFydFRpbWUudG9JU09TdHJpbmcoKSA6IG51bGwsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgbGltaXQsXG4gICAgICAgICAgICB0cmFjZTogdHJhY2VJZCxcbiAgICAgICAgICAgIHNlbGVjdDogc2VsZWN0ID8gc2VsZWN0IDogZGVmYXVsdF9zZWxlY3QsXG4gICAgICAgICAgICBpc19yb290OiBpc1Jvb3QsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBydW5zWWllbGRlZCA9IDA7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgcnVucyBvZiB0aGlzLl9nZXRDdXJzb3JQYWdpbmF0ZWRMaXN0KFwiL3J1bnMvcXVlcnlcIiwgYm9keSkpIHtcbiAgICAgICAgICAgIGlmIChsaW1pdCkge1xuICAgICAgICAgICAgICAgIGlmIChydW5zWWllbGRlZCA+PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJ1bnMubGVuZ3RoICsgcnVuc1lpZWxkZWQgPiBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdSdW5zID0gcnVucy5zbGljZSgwLCBsaW1pdCAtIHJ1bnNZaWVsZGVkKTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIG5ld1J1bnM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBydW5zWWllbGRlZCArPSBydW5zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB5aWVsZCogcnVucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHlpZWxkKiBydW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFJ1blN0YXRzKHsgaWQsIHRyYWNlLCBwYXJlbnRSdW4sIHJ1blR5cGUsIHByb2plY3ROYW1lcywgcHJvamVjdElkcywgcmVmZXJlbmNlRXhhbXBsZUlkcywgc3RhcnRUaW1lLCBlbmRUaW1lLCBlcnJvciwgcXVlcnksIGZpbHRlciwgdHJhY2VGaWx0ZXIsIHRyZWVGaWx0ZXIsIGlzUm9vdCwgZGF0YVNvdXJjZVR5cGUsIH0pIHtcbiAgICAgICAgbGV0IHByb2plY3RJZHNfID0gcHJvamVjdElkcyB8fCBbXTtcbiAgICAgICAgaWYgKHByb2plY3ROYW1lcykge1xuICAgICAgICAgICAgcHJvamVjdElkc18gPSBbXG4gICAgICAgICAgICAgICAgLi4uKHByb2plY3RJZHMgfHwgW10pLFxuICAgICAgICAgICAgICAgIC4uLihhd2FpdCBQcm9taXNlLmFsbChwcm9qZWN0TmFtZXMubWFwKChuYW1lKSA9PiB0aGlzLnJlYWRQcm9qZWN0KHsgcHJvamVjdE5hbWU6IG5hbWUgfSkudGhlbigocHJvamVjdCkgPT4gcHJvamVjdC5pZCkpKSksXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHRyYWNlLFxuICAgICAgICAgICAgcGFyZW50X3J1bjogcGFyZW50UnVuLFxuICAgICAgICAgICAgcnVuX3R5cGU6IHJ1blR5cGUsXG4gICAgICAgICAgICBzZXNzaW9uOiBwcm9qZWN0SWRzXyxcbiAgICAgICAgICAgIHJlZmVyZW5jZV9leGFtcGxlOiByZWZlcmVuY2VFeGFtcGxlSWRzLFxuICAgICAgICAgICAgc3RhcnRfdGltZTogc3RhcnRUaW1lLFxuICAgICAgICAgICAgZW5kX3RpbWU6IGVuZFRpbWUsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgdHJhY2VfZmlsdGVyOiB0cmFjZUZpbHRlcixcbiAgICAgICAgICAgIHRyZWVfZmlsdGVyOiB0cmVlRmlsdGVyLFxuICAgICAgICAgICAgaXNfcm9vdDogaXNSb290LFxuICAgICAgICAgICAgZGF0YV9zb3VyY2VfdHlwZTogZGF0YVNvdXJjZVR5cGUsXG4gICAgICAgIH07XG4gICAgICAgIC8vIFJlbW92ZSB1bmRlZmluZWQgdmFsdWVzIGZyb20gdGhlIHBheWxvYWRcbiAgICAgICAgY29uc3QgZmlsdGVyZWRQYXlsb2FkID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHBheWxvYWQpLmZpbHRlcigoW18sIHZhbHVlXSkgPT4gdmFsdWUgIT09IHVuZGVmaW5lZCkpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L3J1bnMvc3RhdHNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZmlsdGVyZWRQYXlsb2FkKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHNoYXJlUnVuKHJ1bklkLCB7IHNoYXJlSWQgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBydW5faWQ6IHJ1bklkLFxuICAgICAgICAgICAgc2hhcmVfdG9rZW46IHNoYXJlSWQgfHwgdXVpZC52NCgpLFxuICAgICAgICB9O1xuICAgICAgICBhc3NlcnRVdWlkKHJ1bklkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9ydW5zLyR7cnVuSWR9L3NoYXJlYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8ICEoXCJzaGFyZV90b2tlblwiIGluIHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVzcG9uc2UgZnJvbSBzZXJ2ZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0SG9zdFVybCgpfS9wdWJsaWMvJHtyZXN1bHRbXCJzaGFyZV90b2tlblwiXX0vcmA7XG4gICAgfVxuICAgIGFzeW5jIHVuc2hhcmVSdW4ocnVuSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChydW5JZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vcnVucy8ke3J1bklkfS9zaGFyZWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJ1bnNoYXJlIHJ1blwiLCB0cnVlKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZFJ1blNoYXJlZExpbmsocnVuSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChydW5JZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vcnVucy8ke3J1bklkfS9zaGFyZWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgIShcInNoYXJlX3Rva2VuXCIgaW4gcmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L3B1YmxpYy8ke3Jlc3VsdFtcInNoYXJlX3Rva2VuXCJdfS9yYDtcbiAgICB9XG4gICAgYXN5bmMgbGlzdFNoYXJlZFJ1bnMoc2hhcmVUb2tlbiwgeyBydW5JZHMsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAgICAgc2hhcmVfdG9rZW46IHNoYXJlVG9rZW4sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocnVuSWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcnVuSWQgb2YgcnVuSWRzKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKFwiaWRcIiwgcnVuSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzc2VydFV1aWQoc2hhcmVUb2tlbik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vcHVibGljLyR7c2hhcmVUb2tlbn0vcnVucyR7cXVlcnlQYXJhbXN9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJ1bnMgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiBydW5zO1xuICAgIH1cbiAgICBhc3luYyByZWFkRGF0YXNldFNoYXJlZFNjaGVtYShkYXRhc2V0SWQsIGRhdGFzZXROYW1lKSB7XG4gICAgICAgIGlmICghZGF0YXNldElkICYmICFkYXRhc2V0TmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWl0aGVyIGRhdGFzZXRJZCBvciBkYXRhc2V0TmFtZSBtdXN0IGJlIGdpdmVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YXNldElkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvJHtkYXRhc2V0SWR9L3NoYXJlYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNoYXJlU2NoZW1hID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBzaGFyZVNjaGVtYS51cmwgPSBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHVibGljLyR7c2hhcmVTY2hlbWEuc2hhcmVfdG9rZW59L2RgO1xuICAgICAgICByZXR1cm4gc2hhcmVTY2hlbWE7XG4gICAgfVxuICAgIGFzeW5jIHNoYXJlRGF0YXNldChkYXRhc2V0SWQsIGRhdGFzZXROYW1lKSB7XG4gICAgICAgIGlmICghZGF0YXNldElkICYmICFkYXRhc2V0TmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWl0aGVyIGRhdGFzZXRJZCBvciBkYXRhc2V0TmFtZSBtdXN0IGJlIGdpdmVuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YXNldElkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgZGF0YXNldF9pZDogZGF0YXNldElkLFxuICAgICAgICB9O1xuICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvJHtkYXRhc2V0SWR9L3NoYXJlYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc2hhcmVTY2hlbWEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHNoYXJlU2NoZW1hLnVybCA9IGAke3RoaXMuZ2V0SG9zdFVybCgpfS9wdWJsaWMvJHtzaGFyZVNjaGVtYS5zaGFyZV90b2tlbn0vZGA7XG4gICAgICAgIHJldHVybiBzaGFyZVNjaGVtYTtcbiAgICB9XG4gICAgYXN5bmMgdW5zaGFyZURhdGFzZXQoZGF0YXNldElkKSB7XG4gICAgICAgIGFzc2VydFV1aWQoZGF0YXNldElkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke2RhdGFzZXRJZH0vc2hhcmVgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwidW5zaGFyZSBkYXRhc2V0XCIsIHRydWUpO1xuICAgIH1cbiAgICBhc3luYyByZWFkU2hhcmVkRGF0YXNldChzaGFyZVRva2VuKSB7XG4gICAgICAgIGFzc2VydFV1aWQoc2hhcmVUb2tlbik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vcHVibGljLyR7c2hhcmVUb2tlbn0vZGF0YXNldHNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBzaGFyZWQgZXhhbXBsZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2hhcmVUb2tlbiBUaGUgc2hhcmUgdG9rZW4gdG8gZ2V0IGV4YW1wbGVzIGZvci4gQSBzaGFyZSB0b2tlbiBpcyB0aGUgVVVJRCAob3IgTGFuZ1NtaXRoIFVSTCwgaW5jbHVkaW5nIFVVSUQpIGdlbmVyYXRlZCB3aGVuIGV4cGxpY2l0bHkgbWFya2luZyBhbiBleGFtcGxlIGFzIHB1YmxpYy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgbGlzdGluZyB0aGUgZXhhbXBsZXMuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXSB8IHVuZGVmaW5lZH0gW29wdGlvbnMuZXhhbXBsZUlkc10gQSBsaXN0IG9mIGV4YW1wbGUgSURzIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFeGFtcGxlW10+fSBUaGUgc2hhcmVkIGV4YW1wbGVzLlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RTaGFyZWRFeGFtcGxlcyhzaGFyZVRva2VuLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAob3B0aW9ucz8uZXhhbXBsZUlkcykge1xuICAgICAgICAgICAgcGFyYW1zLmlkID0gb3B0aW9ucy5leGFtcGxlSWRzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMocGFyYW1zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlLmZvckVhY2goKHYpID0+IHVybFBhcmFtcy5hcHBlbmQoa2V5LCB2KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cmxQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9wdWJsaWMvJHtzaGFyZVRva2VufS9leGFtcGxlcz8ke3VybFBhcmFtcy50b1N0cmluZygpfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGlmIChcImRldGFpbFwiIGluIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxpc3Qgc2hhcmVkIGV4YW1wbGVzLlxcblN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9XFxuTWVzc2FnZTogJHtyZXN1bHQuZGV0YWlsLmpvaW4oXCJcXG5cIil9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsaXN0IHNoYXJlZCBleGFtcGxlczogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0Lm1hcCgoZXhhbXBsZSkgPT4gKHtcbiAgICAgICAgICAgIC4uLmV4YW1wbGUsXG4gICAgICAgICAgICBfaG9zdFVybDogdGhpcy5nZXRIb3N0VXJsKCksXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlUHJvamVjdCh7IHByb2plY3ROYW1lLCBkZXNjcmlwdGlvbiA9IG51bGwsIG1ldGFkYXRhID0gbnVsbCwgdXBzZXJ0ID0gZmFsc2UsIHByb2plY3RFeHRyYSA9IG51bGwsIHJlZmVyZW5jZURhdGFzZXRJZCA9IG51bGwsIH0pIHtcbiAgICAgICAgY29uc3QgdXBzZXJ0XyA9IHVwc2VydCA/IGA/dXBzZXJ0PXRydWVgIDogXCJcIjtcbiAgICAgICAgY29uc3QgZW5kcG9pbnQgPSBgJHt0aGlzLmFwaVVybH0vc2Vzc2lvbnMke3Vwc2VydF99YDtcbiAgICAgICAgY29uc3QgZXh0cmEgPSBwcm9qZWN0RXh0cmEgfHwge307XG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgZXh0cmFbXCJtZXRhZGF0YVwiXSA9IG1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBuYW1lOiBwcm9qZWN0TmFtZSxcbiAgICAgICAgICAgIGV4dHJhLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChyZWZlcmVuY2VEYXRhc2V0SWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGJvZHlbXCJyZWZlcmVuY2VfZGF0YXNldF9pZFwiXSA9IHJlZmVyZW5jZURhdGFzZXRJZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgZW5kcG9pbnQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImNyZWF0ZSBwcm9qZWN0XCIpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZVByb2plY3QocHJvamVjdElkLCB7IG5hbWUgPSBudWxsLCBkZXNjcmlwdGlvbiA9IG51bGwsIG1ldGFkYXRhID0gbnVsbCwgcHJvamVjdEV4dHJhID0gbnVsbCwgZW5kVGltZSA9IG51bGwsIH0pIHtcbiAgICAgICAgY29uc3QgZW5kcG9pbnQgPSBgJHt0aGlzLmFwaVVybH0vc2Vzc2lvbnMvJHtwcm9qZWN0SWR9YDtcbiAgICAgICAgbGV0IGV4dHJhID0gcHJvamVjdEV4dHJhO1xuICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGV4dHJhID0geyAuLi4oZXh0cmEgfHwge30pLCBtZXRhZGF0YSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZXh0cmEsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGVuZF90aW1lOiBlbmRUaW1lID8gbmV3IERhdGUoZW5kVGltZSkudG9JU09TdHJpbmcoKSA6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBlbmRwb2ludCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVwZGF0ZSBwcm9qZWN0XCIpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGhhc1Byb2plY3QoeyBwcm9qZWN0SWQsIHByb2plY3ROYW1lLCB9KSB7XG4gICAgICAgIC8vIFRPRE86IEFkZCBhIGhlYWQgcmVxdWVzdFxuICAgICAgICBsZXQgcGF0aCA9IFwiL3Nlc3Npb25zXCI7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgaWYgKHByb2plY3RJZCAhPT0gdW5kZWZpbmVkICYmIHByb2plY3ROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgcHJvamVjdE5hbWUgb3IgcHJvamVjdElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9qZWN0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXNzZXJ0VXVpZChwcm9qZWN0SWQpO1xuICAgICAgICAgICAgcGF0aCArPSBgLyR7cHJvamVjdElkfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm5hbWVcIiwgcHJvamVjdE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIHByb2plY3ROYW1lIG9yIHByb2plY3RJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9JHtwYXRofT8ke3BhcmFtc31gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gY29uc3VtZSB0aGUgcmVzcG9uc2UgYm9keSB0byByZWxlYXNlIHRoZSBjb25uZWN0aW9uXG4gICAgICAgIC8vIGh0dHBzOi8vdW5kaWNpLm5vZGVqcy5vcmcvIy8/aWQ9Z2FyYmFnZS1jb2xsZWN0aW9uXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgaXQncyBPSyBhbmQgd2UncmUgcXVlcnlpbmcgYnkgbmFtZSwgbmVlZCB0byBjaGVjayB0aGUgbGlzdCBpcyBub3QgZW1wdHlcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA+IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwcm9qZWN0SWQgcXVlcnlpbmdcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmVhZFByb2plY3QoeyBwcm9qZWN0SWQsIHByb2plY3ROYW1lLCBpbmNsdWRlU3RhdHMsIH0pIHtcbiAgICAgICAgbGV0IHBhdGggPSBcIi9zZXNzaW9uc1wiO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGlmIChwcm9qZWN0SWQgIT09IHVuZGVmaW5lZCAmJiBwcm9qZWN0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHByb2plY3ROYW1lIG9yIHByb2plY3RJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQocHJvamVjdElkKTtcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke3Byb2plY3RJZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2plY3ROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIHByb2plY3ROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBwcm9qZWN0TmFtZSBvciBwcm9qZWN0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluY2x1ZGVTdGF0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaW5jbHVkZV9zdGF0c1wiLCBpbmNsdWRlU3RhdHMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXQocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9qZWN0W2lkPSR7cHJvamVjdElkfSwgbmFtZT0ke3Byb2plY3ROYW1lfV0gbm90IGZvdW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSByZXNwb25zZVswXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGdldFByb2plY3RVcmwoeyBwcm9qZWN0SWQsIHByb2plY3ROYW1lLCB9KSB7XG4gICAgICAgIGlmIChwcm9qZWN0SWQgPT09IHVuZGVmaW5lZCAmJiBwcm9qZWN0TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHByb2plY3ROYW1lIG9yIHByb2plY3RJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9qZWN0ID0gYXdhaXQgdGhpcy5yZWFkUHJvamVjdCh7IHByb2plY3RJZCwgcHJvamVjdE5hbWUgfSk7XG4gICAgICAgIGNvbnN0IHRlbmFudElkID0gYXdhaXQgdGhpcy5fZ2V0VGVuYW50SWQoKTtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0SG9zdFVybCgpfS9vLyR7dGVuYW50SWR9L3Byb2plY3RzL3AvJHtwcm9qZWN0LmlkfWA7XG4gICAgfVxuICAgIGFzeW5jIGdldERhdGFzZXRVcmwoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCB9KSB7XG4gICAgICAgIGlmIChkYXRhc2V0SWQgPT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgIGNvbnN0IHRlbmFudElkID0gYXdhaXQgdGhpcy5fZ2V0VGVuYW50SWQoKTtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0SG9zdFVybCgpfS9vLyR7dGVuYW50SWR9L2RhdGFzZXRzLyR7ZGF0YXNldC5pZH1gO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0VGVuYW50SWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl90ZW5hbnRJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RlbmFudElkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7IGxpbWl0OiBcIjFcIiB9KTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBwcm9qZWN0cyBvZiB0aGlzLl9nZXRQYWdpbmF0ZWQoXCIvc2Vzc2lvbnNcIiwgcXVlcnlQYXJhbXMpKSB7XG4gICAgICAgICAgICB0aGlzLl90ZW5hbnRJZCA9IHByb2plY3RzWzBdLnRlbmFudF9pZDtcbiAgICAgICAgICAgIHJldHVybiBwcm9qZWN0c1swXS50ZW5hbnRfaWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcHJvamVjdHMgZm91bmQgdG8gcmVzb2x2ZSB0ZW5hbnQuXCIpO1xuICAgIH1cbiAgICBhc3luYyAqbGlzdFByb2plY3RzKHsgcHJvamVjdElkcywgbmFtZSwgbmFtZUNvbnRhaW5zLCByZWZlcmVuY2VEYXRhc2V0SWQsIHJlZmVyZW5jZURhdGFzZXROYW1lLCByZWZlcmVuY2VGcmVlLCBtZXRhZGF0YSwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgaWYgKHByb2plY3RJZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9qZWN0SWQgb2YgcHJvamVjdElkcykge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJpZFwiLCBwcm9qZWN0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lQ29udGFpbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm5hbWVfY29udGFpbnNcIiwgbmFtZUNvbnRhaW5zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmZXJlbmNlRGF0YXNldElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJyZWZlcmVuY2VfZGF0YXNldFwiLCByZWZlcmVuY2VEYXRhc2V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlZmVyZW5jZURhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0TmFtZTogcmVmZXJlbmNlRGF0YXNldE5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJyZWZlcmVuY2VfZGF0YXNldFwiLCBkYXRhc2V0LmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmZXJlbmNlRnJlZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwicmVmZXJlbmNlX2ZyZWVcIiwgcmVmZXJlbmNlRnJlZS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YWRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm1ldGFkYXRhXCIsIEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBwcm9qZWN0cyBvZiB0aGlzLl9nZXRQYWdpbmF0ZWQoXCIvc2Vzc2lvbnNcIiwgcGFyYW1zKSkge1xuICAgICAgICAgICAgeWllbGQqIHByb2plY3RzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZVByb2plY3QoeyBwcm9qZWN0SWQsIHByb2plY3ROYW1lLCB9KSB7XG4gICAgICAgIGxldCBwcm9qZWN0SWRfO1xuICAgICAgICBpZiAocHJvamVjdElkID09PSB1bmRlZmluZWQgJiYgcHJvamVjdE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIHByb2plY3ROYW1lIG9yIHByb2plY3RJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9qZWN0SWQgIT09IHVuZGVmaW5lZCAmJiBwcm9qZWN0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIHByb2plY3ROYW1lIG9yIHByb2plY3RJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByb2plY3RJZF8gPSAoYXdhaXQgdGhpcy5yZWFkUHJvamVjdCh7IHByb2plY3ROYW1lIH0pKS5pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByb2plY3RJZF8gPSBwcm9qZWN0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChwcm9qZWN0SWRfKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9zZXNzaW9ucy8ke3Byb2plY3RJZF99YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBgZGVsZXRlIHNlc3Npb24gJHtwcm9qZWN0SWRffSAoJHtwcm9qZWN0TmFtZX0pYCwgdHJ1ZSk7XG4gICAgfVxuICAgIGFzeW5jIHVwbG9hZENzdih7IGNzdkZpbGUsIGZpbGVOYW1lLCBpbnB1dEtleXMsIG91dHB1dEtleXMsIGRlc2NyaXB0aW9uLCBkYXRhVHlwZSwgbmFtZSwgfSkge1xuICAgICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvdXBsb2FkYDtcbiAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBjc3ZGaWxlLCBmaWxlTmFtZSk7XG4gICAgICAgIGlucHV0S2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImlucHV0X2tleXNcIiwga2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dHB1dEtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJvdXRwdXRfa2V5c1wiLCBrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJkZXNjcmlwdGlvblwiLCBkZXNjcmlwdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFUeXBlKSB7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJkYXRhX3R5cGVcIiwgZGF0YVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCB1cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJ1cGxvYWQgQ1NWXCIpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZURhdGFzZXQobmFtZSwgeyBkZXNjcmlwdGlvbiwgZGF0YVR5cGUsIGlucHV0c1NjaGVtYSwgb3V0cHV0c1NjaGVtYSwgbWV0YWRhdGEsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgZXh0cmE6IG1ldGFkYXRhID8geyBtZXRhZGF0YSB9IDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZGF0YVR5cGUpIHtcbiAgICAgICAgICAgIGJvZHkuZGF0YV90eXBlID0gZGF0YVR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0c1NjaGVtYSkge1xuICAgICAgICAgICAgYm9keS5pbnB1dHNfc2NoZW1hX2RlZmluaXRpb24gPSBpbnB1dHNTY2hlbWE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG91dHB1dHNTY2hlbWEpIHtcbiAgICAgICAgICAgIGJvZHkub3V0cHV0c19zY2hlbWFfZGVmaW5pdGlvbiA9IG91dHB1dHNTY2hlbWE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0c2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImNyZWF0ZSBkYXRhc2V0XCIpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHJlYWREYXRhc2V0KHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgfSkge1xuICAgICAgICBsZXQgcGF0aCA9IFwiL2RhdGFzZXRzXCI7XG4gICAgICAgIC8vIGxpbWl0IHRvIDEgcmVzdWx0XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBsaW1pdDogXCIxXCIgfSk7XG4gICAgICAgIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQoZGF0YXNldElkKTtcbiAgICAgICAgICAgIHBhdGggKz0gYC8ke2RhdGFzZXRJZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIGRhdGFzZXROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXQocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhc2V0W2lkPSR7ZGF0YXNldElkfSwgbmFtZT0ke2RhdGFzZXROYW1lfV0gbm90IGZvdW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSByZXNwb25zZVswXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGhhc0RhdGFzZXQoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCB9KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICAgICBlIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UudG9Mb2NhbGVMb3dlckNhc2UoKS5pbmNsdWRlcyhcIm5vdCBmb3VuZFwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGlmZkRhdGFzZXRWZXJzaW9ucyh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIGZyb21WZXJzaW9uLCB0b1ZlcnNpb24sIH0pIHtcbiAgICAgICAgbGV0IGRhdGFzZXRJZF8gPSBkYXRhc2V0SWQ7XG4gICAgICAgIGlmIChkYXRhc2V0SWRfID09PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWRfID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgICAgIGZyb21fdmVyc2lvbjogdHlwZW9mIGZyb21WZXJzaW9uID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgPyBmcm9tVmVyc2lvblxuICAgICAgICAgICAgICAgIDogZnJvbVZlcnNpb24udG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIHRvX3ZlcnNpb246IHR5cGVvZiB0b1ZlcnNpb24gPT09IFwic3RyaW5nXCIgPyB0b1ZlcnNpb24gOiB0b1ZlcnNpb24udG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZ2V0KGAvZGF0YXNldHMvJHtkYXRhc2V0SWRffS92ZXJzaW9ucy9kaWZmYCwgdXJsUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBhc3luYyByZWFkRGF0YXNldE9wZW5haUZpbmV0dW5pbmcoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCB9KSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBcIi9kYXRhc2V0c1wiO1xuICAgICAgICBpZiAoZGF0YXNldElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0SWQgPSAoYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pKS5pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXRSZXNwb25zZShgJHtwYXRofS8ke2RhdGFzZXRJZH0vb3BlbmFpX2Z0YCk7XG4gICAgICAgIGNvbnN0IGRhdGFzZXRUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICBjb25zdCBkYXRhc2V0ID0gZGF0YXNldFRleHRcbiAgICAgICAgICAgIC50cmltKClcbiAgICAgICAgICAgIC5zcGxpdChcIlxcblwiKVxuICAgICAgICAgICAgLm1hcCgobGluZSkgPT4gSlNPTi5wYXJzZShsaW5lKSk7XG4gICAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgICBhc3luYyAqbGlzdERhdGFzZXRzKHsgbGltaXQgPSAxMDAsIG9mZnNldCA9IDAsIGRhdGFzZXRJZHMsIGRhdGFzZXROYW1lLCBkYXRhc2V0TmFtZUNvbnRhaW5zLCBtZXRhZGF0YSwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBcIi9kYXRhc2V0c1wiO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgICAgIGxpbWl0OiBsaW1pdC50b1N0cmluZygpLFxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQudG9TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkYXRhc2V0SWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaWRfIG9mIGRhdGFzZXRJZHMpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaWRcIiwgaWRfKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm5hbWVcIiwgZGF0YXNldE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhc2V0TmFtZUNvbnRhaW5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lX2NvbnRhaW5zXCIsIGRhdGFzZXROYW1lQ29udGFpbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibWV0YWRhdGFcIiwgSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGRhdGFzZXRzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChwYXRoLCBwYXJhbXMpKSB7XG4gICAgICAgICAgICB5aWVsZCogZGF0YXNldHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGEgZGF0YXNldFxuICAgICAqIEBwYXJhbSBwcm9wcyBUaGUgZGF0YXNldCBkZXRhaWxzIHRvIHVwZGF0ZVxuICAgICAqIEByZXR1cm5zIFRoZSB1cGRhdGVkIGRhdGFzZXRcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVEYXRhc2V0KHByb3BzKSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgLi4udXBkYXRlIH0gPSBwcm9wcztcbiAgICAgICAgaWYgKCFkYXRhc2V0SWQgJiYgIWRhdGFzZXROYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBfZGF0YXNldElkID0gZGF0YXNldElkID8/IChhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSkpLmlkO1xuICAgICAgICBhc3NlcnRVdWlkKF9kYXRhc2V0SWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzLyR7X2RhdGFzZXRJZH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodXBkYXRlKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJ1cGRhdGUgZGF0YXNldFwiKTtcbiAgICAgICAgcmV0dXJuIChhd2FpdCByZXNwb25zZS5qc29uKCkpO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVEYXRhc2V0KHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgfSkge1xuICAgICAgICBsZXQgcGF0aCA9IFwiL2RhdGFzZXRzXCI7XG4gICAgICAgIGxldCBkYXRhc2V0SWRfID0gZGF0YXNldElkO1xuICAgICAgICBpZiAoZGF0YXNldElkICE9PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YXNldElkXyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZF8pO1xuICAgICAgICAgICAgcGF0aCArPSBgLyR7ZGF0YXNldElkX31gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgdGhpcy5hcGlVcmwgKyBwYXRoLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIGBkZWxldGUgJHtwYXRofWApO1xuICAgICAgICBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jIGluZGV4RGF0YXNldCh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIHRhZywgfSkge1xuICAgICAgICBsZXQgZGF0YXNldElkXyA9IGRhdGFzZXRJZDtcbiAgICAgICAgaWYgKCFkYXRhc2V0SWRfICYmICFkYXRhc2V0TmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyAmJiBkYXRhc2V0TmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFkYXRhc2V0SWRfKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWRfKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIHRhZzogdGFnLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzLyR7ZGF0YXNldElkX30vaW5kZXhgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJpbmRleCBkYXRhc2V0XCIpO1xuICAgICAgICBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExldHMgeW91IHJ1biBhIHNpbWlsYXJpdHkgc2VhcmNoIHF1ZXJ5IG9uIGEgZGF0YXNldC5cbiAgICAgKlxuICAgICAqIFJlcXVpcmVzIHRoZSBkYXRhc2V0IHRvIGJlIGluZGV4ZWQuIFBsZWFzZSBzZWUgdGhlIGBpbmRleERhdGFzZXRgIG1ldGhvZCB0byBzZXQgdXAgaW5kZXhpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXRzICAgICAgVGhlIGlucHV0IG9uIHdoaWNoIHRvIHJ1biB0aGUgc2ltaWxhcml0eSBzZWFyY2guIE11c3QgaGF2ZSB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgc2FtZSBzY2hlbWEgYXMgdGhlIGRhdGFzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YXNldElkICAgVGhlIGRhdGFzZXQgdG8gc2VhcmNoIGZvciBzaW1pbGFyIGV4YW1wbGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxpbWl0ICAgICAgIFRoZSBtYXhpbXVtIG51bWJlciBvZiBleGFtcGxlcyB0byByZXR1cm4uIFdpbGwgcmV0dXJuIHRoZSB0b3AgYGxpbWl0YCBtb3N0XG4gICAgICogICAgICAgICAgICAgICAgICAgIHNpbWlsYXIgZXhhbXBsZXMgaW4gb3JkZXIgb2YgbW9zdCBzaW1pbGFyIHRvIGxlYXN0IHNpbWlsYXIuIElmIG5vIHNpbWlsYXJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgZXhhbXBsZXMgYXJlIGZvdW5kLCByYW5kb20gZXhhbXBsZXMgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWx0ZXIgICAgICBBIGZpbHRlciBzdHJpbmcgdG8gYXBwbHkgdG8gdGhlIHNlYXJjaC4gT25seSBleGFtcGxlcyB3aWxsIGJlIHJldHVybmVkIHRoYXRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggdGhlIGZpbHRlciBzdHJpbmcuIFNvbWUgZXhhbXBsZXMgb2YgZmlsdGVyc1xuICAgICAqXG4gICAgICogICAgICAgICAgICAgICAgICAgIC0gZXEobWV0YWRhdGEubXlrZXksIFwidmFsdWVcIilcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgLSBhbmQobmVxKG1ldGFkYXRhLm15Lm5lc3RlZC5rZXksIFwidmFsdWVcIiksIG5lcShtZXRhZGF0YS5teWtleSwgXCJ2YWx1ZVwiKSlcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgLSBvcihlcShtZXRhZGF0YS5teWtleSwgXCJ2YWx1ZVwiKSwgZXEobWV0YWRhdGEubXlrZXksIFwib3RoZXJ2YWx1ZVwiKSlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zICAgICAgICAgICBBIGxpc3Qgb2Ygc2ltaWxhciBleGFtcGxlcy5cbiAgICAgKlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBkYXRhc2V0X2lkID0gXCIxMjNlNDU2Ny1lODliLTEyZDMtYTQ1Ni00MjY2MTQxNzQwMDBcIlxuICAgICAqIGlucHV0cyA9IHtcInRleHRcIjogXCJIb3cgbWFueSBwZW9wbGUgbGl2ZSBpbiBCZXJsaW4/XCJ9XG4gICAgICogbGltaXQgPSA1XG4gICAgICogZXhhbXBsZXMgPSBhd2FpdCBjbGllbnQuc2ltaWxhckV4YW1wbGVzKGlucHV0cywgZGF0YXNldF9pZCwgbGltaXQpXG4gICAgICovXG4gICAgYXN5bmMgc2ltaWxhckV4YW1wbGVzKGlucHV0cywgZGF0YXNldElkLCBsaW1pdCwgeyBmaWx0ZXIsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgbGltaXQ6IGxpbWl0LFxuICAgICAgICAgICAgaW5wdXRzOiBpbnB1dHMsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChmaWx0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YVtcImZpbHRlclwiXSA9IGZpbHRlcjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvJHtkYXRhc2V0SWR9L3NlYXJjaGAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImZldGNoIHNpbWlsYXIgZXhhbXBsZXNcIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFtcImV4YW1wbGVzXCJdO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVFeGFtcGxlKGlucHV0cywgb3V0cHV0cywgeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCBjcmVhdGVkQXQsIGV4YW1wbGVJZCwgbWV0YWRhdGEsIHNwbGl0LCBzb3VyY2VSdW5JZCwgfSkge1xuICAgICAgICBsZXQgZGF0YXNldElkXyA9IGRhdGFzZXRJZDtcbiAgICAgICAgaWYgKGRhdGFzZXRJZF8gPT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWRfICE9PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZF8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0LmlkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNyZWF0ZWRBdF8gPSBjcmVhdGVkQXQgfHwgbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIGRhdGFzZXRfaWQ6IGRhdGFzZXRJZF8sXG4gICAgICAgICAgICBpbnB1dHMsXG4gICAgICAgICAgICBvdXRwdXRzLFxuICAgICAgICAgICAgY3JlYXRlZF9hdDogY3JlYXRlZEF0Xz8udG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGlkOiBleGFtcGxlSWQsXG4gICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgIHNwbGl0LFxuICAgICAgICAgICAgc291cmNlX3J1bl9pZDogc291cmNlUnVuSWQsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vZXhhbXBsZXNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJjcmVhdGUgZXhhbXBsZVwiKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVFeGFtcGxlcyhwcm9wcykge1xuICAgICAgICBjb25zdCB7IGlucHV0cywgb3V0cHV0cywgbWV0YWRhdGEsIHNvdXJjZVJ1bklkcywgZXhhbXBsZUlkcywgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgfSA9IHByb3BzO1xuICAgICAgICBsZXQgZGF0YXNldElkXyA9IGRhdGFzZXRJZDtcbiAgICAgICAgaWYgKGRhdGFzZXRJZF8gPT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWRfICE9PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZF8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0LmlkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZEV4YW1wbGVzID0gaW5wdXRzLm1hcCgoaW5wdXQsIGlkeCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0X2lkOiBkYXRhc2V0SWRfLFxuICAgICAgICAgICAgICAgIGlucHV0czogaW5wdXQsXG4gICAgICAgICAgICAgICAgb3V0cHV0czogb3V0cHV0cyA/IG91dHB1dHNbaWR4XSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogbWV0YWRhdGEgPyBtZXRhZGF0YVtpZHhdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHNwbGl0OiBwcm9wcy5zcGxpdHMgPyBwcm9wcy5zcGxpdHNbaWR4XSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBpZDogZXhhbXBsZUlkcyA/IGV4YW1wbGVJZHNbaWR4XSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBzb3VyY2VfcnVuX2lkOiBzb3VyY2VSdW5JZHMgPyBzb3VyY2VSdW5JZHNbaWR4XSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L2V4YW1wbGVzL2J1bGtgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShmb3JtYXR0ZWRFeGFtcGxlcyksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiY3JlYXRlIGV4YW1wbGVzXCIpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUxMTUV4YW1wbGUoaW5wdXQsIGdlbmVyYXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXhhbXBsZSh7IGlucHV0IH0sIHsgb3V0cHV0OiBnZW5lcmF0aW9uIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVDaGF0RXhhbXBsZShpbnB1dCwgZ2VuZXJhdGlvbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZmluYWxJbnB1dCA9IGlucHV0Lm1hcCgobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzTGFuZ0NoYWluTWVzc2FnZShtZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0TGFuZ0NoYWluTWVzc2FnZVRvRXhhbXBsZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZmluYWxPdXRwdXQgPSBpc0xhbmdDaGFpbk1lc3NhZ2UoZ2VuZXJhdGlvbnMpXG4gICAgICAgICAgICA/IGNvbnZlcnRMYW5nQ2hhaW5NZXNzYWdlVG9FeGFtcGxlKGdlbmVyYXRpb25zKVxuICAgICAgICAgICAgOiBnZW5lcmF0aW9ucztcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXhhbXBsZSh7IGlucHV0OiBmaW5hbElucHV0IH0sIHsgb3V0cHV0OiBmaW5hbE91dHB1dCB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZEV4YW1wbGUoZXhhbXBsZUlkKSB7XG4gICAgICAgIGFzc2VydFV1aWQoZXhhbXBsZUlkKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvZXhhbXBsZXMvJHtleGFtcGxlSWR9YDtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2dldChwYXRoKTtcbiAgICB9XG4gICAgYXN5bmMgKmxpc3RFeGFtcGxlcyh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIGV4YW1wbGVJZHMsIGFzT2YsIHNwbGl0cywgaW5saW5lUzNVcmxzLCBtZXRhZGF0YSwgbGltaXQsIG9mZnNldCwgZmlsdGVyLCB9ID0ge30pIHtcbiAgICAgICAgbGV0IGRhdGFzZXRJZF87XG4gICAgICAgIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0LmlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGEgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBkYXRhc2V0OiBkYXRhc2V0SWRfIH0pO1xuICAgICAgICBjb25zdCBkYXRhc2V0X3ZlcnNpb24gPSBhc09mXG4gICAgICAgICAgICA/IHR5cGVvZiBhc09mID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgPyBhc09mXG4gICAgICAgICAgICAgICAgOiBhc09mPy50b0lTT1N0cmluZygpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGRhdGFzZXRfdmVyc2lvbikge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImFzX29mXCIsIGRhdGFzZXRfdmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5saW5lUzNVcmxzXyA9IGlubGluZVMzVXJscyA/PyB0cnVlO1xuICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaW5saW5lX3MzX3VybHNcIiwgaW5saW5lUzNVcmxzXy50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKGV4YW1wbGVJZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpZF8gb2YgZXhhbXBsZUlkcykge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJpZFwiLCBpZF8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzcGxpdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzcGxpdCBvZiBzcGxpdHMpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwic3BsaXRzXCIsIHNwbGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YWRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZE1ldGFkYXRhID0gSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpO1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm1ldGFkYXRhXCIsIHNlcmlhbGl6ZWRNZXRhZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJsaW1pdFwiLCBsaW1pdC50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJvZmZzZXRcIiwgb2Zmc2V0LnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWx0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImZpbHRlclwiLCBmaWx0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBleGFtcGxlcyBvZiB0aGlzLl9nZXRQYWdpbmF0ZWQoXCIvZXhhbXBsZXNcIiwgcGFyYW1zKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBleGFtcGxlIG9mIGV4YW1wbGVzKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgZXhhbXBsZTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCAmJiBpID49IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlRXhhbXBsZShleGFtcGxlSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChleGFtcGxlSWQpO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9leGFtcGxlcy8ke2V4YW1wbGVJZH1gO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgdGhpcy5hcGlVcmwgKyBwYXRoLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIGBkZWxldGUgJHtwYXRofWApO1xuICAgICAgICBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUV4YW1wbGUoZXhhbXBsZUlkLCB1cGRhdGUpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChleGFtcGxlSWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L2V4YW1wbGVzLyR7ZXhhbXBsZUlkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGUpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVwZGF0ZSBleGFtcGxlXCIpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUV4YW1wbGVzKHVwZGF0ZSkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L2V4YW1wbGVzL2J1bGtgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodXBkYXRlKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJ1cGRhdGUgZXhhbXBsZXNcIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgbGlzdERhdGFzZXRTcGxpdHMoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCBhc09mLCB9KSB7XG4gICAgICAgIGxldCBkYXRhc2V0SWRfO1xuICAgICAgICBpZiAoZGF0YXNldElkID09PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGRhdGFzZXQgbmFtZSBvciBJRFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWRfKTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBjb25zdCBkYXRhc2V0X3ZlcnNpb24gPSBhc09mXG4gICAgICAgICAgICA/IHR5cGVvZiBhc09mID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgPyBhc09mXG4gICAgICAgICAgICAgICAgOiBhc09mPy50b0lTT1N0cmluZygpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGRhdGFzZXRfdmVyc2lvbikge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImFzX29mXCIsIGRhdGFzZXRfdmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXQoYC9kYXRhc2V0cy8ke2RhdGFzZXRJZF99L3NwbGl0c2AsIHBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlRGF0YXNldFNwbGl0cyh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIHNwbGl0TmFtZSwgZXhhbXBsZUlkcywgcmVtb3ZlID0gZmFsc2UsIH0pIHtcbiAgICAgICAgbGV0IGRhdGFzZXRJZF87XG4gICAgICAgIGlmIChkYXRhc2V0SWQgPT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZGF0YXNldCBuYW1lIG9yIElEXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZCAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0LmlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXRJZDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZF8pO1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgc3BsaXRfbmFtZTogc3BsaXROYW1lLFxuICAgICAgICAgICAgZXhhbXBsZXM6IGV4YW1wbGVJZHMubWFwKChpZCkgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydFV1aWQoaWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcmVtb3ZlLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzLyR7ZGF0YXNldElkX30vc3BsaXRzYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJ1cGRhdGUgZGF0YXNldCBzcGxpdHNcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgTGFuZ1NtaXRoIHZlcnNpb25zLCB1c2UgYGV2YWx1YXRlYCBmcm9tIGBsYW5nc21pdGgvZXZhbHVhdGlvbmAgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBhc3luYyBldmFsdWF0ZVJ1bihydW4sIGV2YWx1YXRvciwgeyBzb3VyY2VJbmZvLCBsb2FkQ2hpbGRSdW5zLCByZWZlcmVuY2VFeGFtcGxlLCB9ID0geyBsb2FkQ2hpbGRSdW5zOiBmYWxzZSB9KSB7XG4gICAgICAgIHdhcm5PbmNlKFwiVGhpcyBtZXRob2QgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSBMYW5nU21pdGggdmVyc2lvbnMsIHVzZSBgZXZhbHVhdGVgIGZyb20gYGxhbmdzbWl0aC9ldmFsdWF0aW9uYCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgbGV0IHJ1bl87XG4gICAgICAgIGlmICh0eXBlb2YgcnVuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBydW5fID0gYXdhaXQgdGhpcy5yZWFkUnVuKHJ1biwgeyBsb2FkQ2hpbGRSdW5zIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBydW4gPT09IFwib2JqZWN0XCIgJiYgXCJpZFwiIGluIHJ1bikge1xuICAgICAgICAgICAgcnVuXyA9IHJ1bjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBydW4gdHlwZTogJHt0eXBlb2YgcnVufWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW5fLnJlZmVyZW5jZV9leGFtcGxlX2lkICE9PSBudWxsICYmXG4gICAgICAgICAgICBydW5fLnJlZmVyZW5jZV9leGFtcGxlX2lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZUV4YW1wbGUgPSBhd2FpdCB0aGlzLnJlYWRFeGFtcGxlKHJ1bl8ucmVmZXJlbmNlX2V4YW1wbGVfaWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZlZWRiYWNrUmVzdWx0ID0gYXdhaXQgZXZhbHVhdG9yLmV2YWx1YXRlUnVuKHJ1bl8sIHJlZmVyZW5jZUV4YW1wbGUpO1xuICAgICAgICBjb25zdCBbXywgZmVlZGJhY2tzXSA9IGF3YWl0IHRoaXMuX2xvZ0V2YWx1YXRpb25GZWVkYmFjayhmZWVkYmFja1Jlc3VsdCwgcnVuXywgc291cmNlSW5mbyk7XG4gICAgICAgIHJldHVybiBmZWVkYmFja3NbMF07XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUZlZWRiYWNrKHJ1bklkLCBrZXksIHsgc2NvcmUsIHZhbHVlLCBjb3JyZWN0aW9uLCBjb21tZW50LCBzb3VyY2VJbmZvLCBmZWVkYmFja1NvdXJjZVR5cGUgPSBcImFwaVwiLCBzb3VyY2VSdW5JZCwgZmVlZGJhY2tJZCwgZmVlZGJhY2tDb25maWcsIHByb2plY3RJZCwgY29tcGFyYXRpdmVFeHBlcmltZW50SWQsIH0pIHtcbiAgICAgICAgaWYgKCFydW5JZCAmJiAhcHJvamVjdElkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmUgb2YgcnVuSWQgb3IgcHJvamVjdElkIG11c3QgYmUgcHJvdmlkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bklkICYmIHByb2plY3RJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBvbmUgb2YgcnVuSWQgb3IgcHJvamVjdElkIGNhbiBiZSBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmZWVkYmFja19zb3VyY2UgPSB7XG4gICAgICAgICAgICB0eXBlOiBmZWVkYmFja1NvdXJjZVR5cGUgPz8gXCJhcGlcIixcbiAgICAgICAgICAgIG1ldGFkYXRhOiBzb3VyY2VJbmZvID8/IHt9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc291cmNlUnVuSWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgZmVlZGJhY2tfc291cmNlPy5tZXRhZGF0YSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAhZmVlZGJhY2tfc291cmNlLm1ldGFkYXRhW1wiX19ydW5cIl0pIHtcbiAgICAgICAgICAgIGZlZWRiYWNrX3NvdXJjZS5tZXRhZGF0YVtcIl9fcnVuXCJdID0geyBydW5faWQ6IHNvdXJjZVJ1bklkIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZlZWRiYWNrX3NvdXJjZT8ubWV0YWRhdGEgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgZmVlZGJhY2tfc291cmNlLm1ldGFkYXRhW1wiX19ydW5cIl0/LnJ1bl9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhc3NlcnRVdWlkKGZlZWRiYWNrX3NvdXJjZS5tZXRhZGF0YVtcIl9fcnVuXCJdLnJ1bl9pZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmVlZGJhY2sgPSB7XG4gICAgICAgICAgICBpZDogZmVlZGJhY2tJZCA/PyB1dWlkLnY0KCksXG4gICAgICAgICAgICBydW5faWQ6IHJ1bklkLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgc2NvcmUsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGNvcnJlY3Rpb24sXG4gICAgICAgICAgICBjb21tZW50LFxuICAgICAgICAgICAgZmVlZGJhY2tfc291cmNlOiBmZWVkYmFja19zb3VyY2UsXG4gICAgICAgICAgICBjb21wYXJhdGl2ZV9leHBlcmltZW50X2lkOiBjb21wYXJhdGl2ZUV4cGVyaW1lbnRJZCxcbiAgICAgICAgICAgIGZlZWRiYWNrQ29uZmlnLFxuICAgICAgICAgICAgc2Vzc2lvbl9pZDogcHJvamVjdElkLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmFwaVVybH0vZmVlZGJhY2tgO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgdXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShmZWVkYmFjayksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiY3JlYXRlIGZlZWRiYWNrXCIsIHRydWUpO1xuICAgICAgICByZXR1cm4gZmVlZGJhY2s7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUZlZWRiYWNrKGZlZWRiYWNrSWQsIHsgc2NvcmUsIHZhbHVlLCBjb3JyZWN0aW9uLCBjb21tZW50LCB9KSB7XG4gICAgICAgIGNvbnN0IGZlZWRiYWNrVXBkYXRlID0ge307XG4gICAgICAgIGlmIChzY29yZSAhPT0gdW5kZWZpbmVkICYmIHNjb3JlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmZWVkYmFja1VwZGF0ZVtcInNjb3JlXCJdID0gc2NvcmU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZlZWRiYWNrVXBkYXRlW1widmFsdWVcIl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ycmVjdGlvbiAhPT0gdW5kZWZpbmVkICYmIGNvcnJlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZlZWRiYWNrVXBkYXRlW1wiY29ycmVjdGlvblwiXSA9IGNvcnJlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1lbnQgIT09IHVuZGVmaW5lZCAmJiBjb21tZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmZWVkYmFja1VwZGF0ZVtcImNvbW1lbnRcIl0gPSBjb21tZW50O1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFV1aWQoZmVlZGJhY2tJZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vZmVlZGJhY2svJHtmZWVkYmFja0lkfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShmZWVkYmFja1VwZGF0ZSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwidXBkYXRlIGZlZWRiYWNrXCIsIHRydWUpO1xuICAgIH1cbiAgICBhc3luYyByZWFkRmVlZGJhY2soZmVlZGJhY2tJZCkge1xuICAgICAgICBhc3NlcnRVdWlkKGZlZWRiYWNrSWQpO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9mZWVkYmFjay8ke2ZlZWRiYWNrSWR9YDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXQocGF0aCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlRmVlZGJhY2soZmVlZGJhY2tJZCkge1xuICAgICAgICBhc3NlcnRVdWlkKGZlZWRiYWNrSWQpO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9mZWVkYmFjay8ke2ZlZWRiYWNrSWR9YDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIHRoaXMuYXBpVXJsICsgcGF0aCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBgZGVsZXRlICR7cGF0aH1gKTtcbiAgICAgICAgYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBhc3luYyAqbGlzdEZlZWRiYWNrKHsgcnVuSWRzLCBmZWVkYmFja0tleXMsIGZlZWRiYWNrU291cmNlVHlwZXMsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgaWYgKHJ1bklkcykge1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKFwicnVuXCIsIHJ1bklkcy5qb2luKFwiLFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZlZWRiYWNrS2V5cykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZmVlZGJhY2tLZXlzKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKFwia2V5XCIsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZlZWRiYWNrU291cmNlVHlwZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBmZWVkYmFja1NvdXJjZVR5cGVzKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKFwic291cmNlXCIsIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgZmVlZGJhY2tzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9mZWVkYmFja1wiLCBxdWVyeVBhcmFtcykpIHtcbiAgICAgICAgICAgIHlpZWxkKiBmZWVkYmFja3M7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHByZXNpZ25lZCBmZWVkYmFjayB0b2tlbiBhbmQgVVJMLlxuICAgICAqXG4gICAgICogVGhlIHRva2VuIGNhbiBiZSB1c2VkIHRvIGF1dGhvcml6ZSBmZWVkYmFjayBtZXRyaWNzIHdpdGhvdXRcbiAgICAgKiBuZWVkaW5nIGFuIEFQSSBrZXkuIFRoaXMgaXMgdXNlZnVsIGZvciBnaXZpbmcgYnJvd3Nlci1iYXNlZFxuICAgICAqIGFwcGxpY2F0aW9ucyB0aGUgYWJpbGl0eSB0byBzdWJtaXQgZmVlZGJhY2sgd2l0aG91dCBuZWVkaW5nXG4gICAgICogdG8gZXhwb3NlIGFuIEFQSSBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcnVuSWQgLSBUaGUgSUQgb2YgdGhlIHJ1bi5cbiAgICAgKiBAcGFyYW0gZmVlZGJhY2tLZXkgLSBUaGUgZmVlZGJhY2sga2V5LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgdG9rZW4uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZXhwaXJhdGlvbiAtIFRoZSBleHBpcmF0aW9uIHRpbWUgZm9yIHRoZSB0b2tlbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgRmVlZGJhY2tJbmdlc3RUb2tlbi5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVQcmVzaWduZWRGZWVkYmFja1Rva2VuKHJ1bklkLCBmZWVkYmFja0tleSwgeyBleHBpcmF0aW9uLCBmZWVkYmFja0NvbmZpZywgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBydW5faWQ6IHJ1bklkLFxuICAgICAgICAgICAgZmVlZGJhY2tfa2V5OiBmZWVkYmFja0tleSxcbiAgICAgICAgICAgIGZlZWRiYWNrX2NvbmZpZzogZmVlZGJhY2tDb25maWcsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChleHBpcmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4cGlyYXRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBib2R5W1wiZXhwaXJlc19hdFwiXSA9IGV4cGlyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChleHBpcmF0aW9uPy5ob3VycyB8fCBleHBpcmF0aW9uPy5taW51dGVzIHx8IGV4cGlyYXRpb24/LmRheXMpIHtcbiAgICAgICAgICAgICAgICBib2R5W1wiZXhwaXJlc19pblwiXSA9IGV4cGlyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5W1wiZXhwaXJlc19pblwiXSA9IHtcbiAgICAgICAgICAgICAgICBob3VyczogMyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9mZWVkYmFjay90b2tlbnNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUNvbXBhcmF0aXZlRXhwZXJpbWVudCh7IG5hbWUsIGV4cGVyaW1lbnRJZHMsIHJlZmVyZW5jZURhdGFzZXRJZCwgY3JlYXRlZEF0LCBkZXNjcmlwdGlvbiwgbWV0YWRhdGEsIGlkLCB9KSB7XG4gICAgICAgIGlmIChleHBlcmltZW50SWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXQgbGVhc3Qgb25lIGV4cGVyaW1lbnQgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZWZlcmVuY2VEYXRhc2V0SWQpIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZURhdGFzZXRJZCA9IChhd2FpdCB0aGlzLnJlYWRQcm9qZWN0KHtcbiAgICAgICAgICAgICAgICBwcm9qZWN0SWQ6IGV4cGVyaW1lbnRJZHNbMF0sXG4gICAgICAgICAgICB9KSkucmVmZXJlbmNlX2RhdGFzZXRfaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZWZlcmVuY2VEYXRhc2V0SWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSByZWZlcmVuY2UgZGF0YXNldCBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZXhwZXJpbWVudF9pZHM6IGV4cGVyaW1lbnRJZHMsXG4gICAgICAgICAgICByZWZlcmVuY2VfZGF0YXNldF9pZDogcmVmZXJlbmNlRGF0YXNldElkLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBjcmVhdGVkX2F0OiAoY3JlYXRlZEF0ID8/IG5ldyBEYXRlKCkpPy50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgZXh0cmE6IHt9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAobWV0YWRhdGEpXG4gICAgICAgICAgICBib2R5LmV4dHJhW1wibWV0YWRhdGFcIl0gPSBtZXRhZGF0YTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy9jb21wYXJhdGl2ZWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIGxpc3Qgb2YgcHJlc2lnbmVkIGZlZWRiYWNrIHRva2VucyBmb3IgYSBnaXZlbiBydW4gSUQuXG4gICAgICogQHBhcmFtIHJ1bklkIFRoZSBJRCBvZiB0aGUgcnVuLlxuICAgICAqIEByZXR1cm5zIEFuIGFzeW5jIGl0ZXJhYmxlIG9mIEZlZWRiYWNrSW5nZXN0VG9rZW4gb2JqZWN0cy5cbiAgICAgKi9cbiAgICBhc3luYyAqbGlzdFByZXNpZ25lZEZlZWRiYWNrVG9rZW5zKHJ1bklkKSB7XG4gICAgICAgIGFzc2VydFV1aWQocnVuSWQpO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgcnVuX2lkOiBydW5JZCB9KTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCB0b2tlbnMgb2YgdGhpcy5fZ2V0UGFnaW5hdGVkKFwiL2ZlZWRiYWNrL3Rva2Vuc1wiLCBwYXJhbXMpKSB7XG4gICAgICAgICAgICB5aWVsZCogdG9rZW5zO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9zZWxlY3RFdmFsUmVzdWx0cyhyZXN1bHRzKSB7XG4gICAgICAgIGxldCByZXN1bHRzXztcbiAgICAgICAgaWYgKFwicmVzdWx0c1wiIGluIHJlc3VsdHMpIHtcbiAgICAgICAgICAgIHJlc3VsdHNfID0gcmVzdWx0cy5yZXN1bHRzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0c18gPSBbcmVzdWx0c107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHNfO1xuICAgIH1cbiAgICBhc3luYyBfbG9nRXZhbHVhdGlvbkZlZWRiYWNrKGV2YWx1YXRvclJlc3BvbnNlLCBydW4sIHNvdXJjZUluZm8pIHtcbiAgICAgICAgY29uc3QgZXZhbFJlc3VsdHMgPSB0aGlzLl9zZWxlY3RFdmFsUmVzdWx0cyhldmFsdWF0b3JSZXNwb25zZSk7XG4gICAgICAgIGNvbnN0IGZlZWRiYWNrcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHJlcyBvZiBldmFsUmVzdWx0cykge1xuICAgICAgICAgICAgbGV0IHNvdXJjZUluZm9fID0gc291cmNlSW5mbyB8fCB7fTtcbiAgICAgICAgICAgIGlmIChyZXMuZXZhbHVhdG9ySW5mbykge1xuICAgICAgICAgICAgICAgIHNvdXJjZUluZm9fID0geyAuLi5yZXMuZXZhbHVhdG9ySW5mbywgLi4uc291cmNlSW5mb18gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBydW5JZF8gPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlcy50YXJnZXRSdW5JZCkge1xuICAgICAgICAgICAgICAgIHJ1bklkXyA9IHJlcy50YXJnZXRSdW5JZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJ1bikge1xuICAgICAgICAgICAgICAgIHJ1bklkXyA9IHJ1bi5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZlZWRiYWNrcy5wdXNoKGF3YWl0IHRoaXMuY3JlYXRlRmVlZGJhY2socnVuSWRfLCByZXMua2V5LCB7XG4gICAgICAgICAgICAgICAgc2NvcmU6IHJlcy5zY29yZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmVzLnZhbHVlLFxuICAgICAgICAgICAgICAgIGNvbW1lbnQ6IHJlcy5jb21tZW50LFxuICAgICAgICAgICAgICAgIGNvcnJlY3Rpb246IHJlcy5jb3JyZWN0aW9uLFxuICAgICAgICAgICAgICAgIHNvdXJjZUluZm86IHNvdXJjZUluZm9fLFxuICAgICAgICAgICAgICAgIHNvdXJjZVJ1bklkOiByZXMuc291cmNlUnVuSWQsXG4gICAgICAgICAgICAgICAgZmVlZGJhY2tDb25maWc6IHJlcy5mZWVkYmFja0NvbmZpZyxcbiAgICAgICAgICAgICAgICBmZWVkYmFja1NvdXJjZVR5cGU6IFwibW9kZWxcIixcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2V2YWxSZXN1bHRzLCBmZWVkYmFja3NdO1xuICAgIH1cbiAgICBhc3luYyBsb2dFdmFsdWF0aW9uRmVlZGJhY2soZXZhbHVhdG9yUmVzcG9uc2UsIHJ1biwgc291cmNlSW5mbykge1xuICAgICAgICBjb25zdCBbcmVzdWx0c10gPSBhd2FpdCB0aGlzLl9sb2dFdmFsdWF0aW9uRmVlZGJhY2soZXZhbHVhdG9yUmVzcG9uc2UsIHJ1biwgc291cmNlSW5mbyk7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBUEkgZm9yIG1hbmFnaW5nIGFubm90YXRpb24gcXVldWVzXG4gICAgICovXG4gICAgLyoqXG4gICAgICogTGlzdCB0aGUgYW5ub3RhdGlvbiBxdWV1ZXMgb24gdGhlIExhbmdTbWl0aCBBUEkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgbGlzdGluZyBhbm5vdGF0aW9uIHF1ZXVlc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLnF1ZXVlSWRzIC0gVGhlIElEcyBvZiB0aGUgcXVldWVzIHRvIGZpbHRlciBieVxuICAgICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcXVldWUgdG8gZmlsdGVyIGJ5XG4gICAgICogQHBhcmFtIG9wdGlvbnMubmFtZUNvbnRhaW5zIC0gVGhlIHN1YnN0cmluZyB0aGF0IHRoZSBxdWV1ZSBuYW1lIHNob3VsZCBjb250YWluXG4gICAgICogQHBhcmFtIG9wdGlvbnMubGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgcXVldWVzIHRvIHJldHVyblxuICAgICAqIEByZXR1cm5zIEFuIGl0ZXJhdG9yIG9mIEFubm90YXRpb25RdWV1ZSBvYmplY3RzXG4gICAgICovXG4gICAgYXN5bmMgKmxpc3RBbm5vdGF0aW9uUXVldWVzKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IHF1ZXVlSWRzLCBuYW1lLCBuYW1lQ29udGFpbnMsIGxpbWl0IH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGlmIChxdWV1ZUlkcykge1xuICAgICAgICAgICAgcXVldWVJZHMuZm9yRWFjaCgoaWQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBhc3NlcnRVdWlkKGlkLCBgcXVldWVJZHNbJHtpfV1gKTtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaWRzXCIsIGlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lKVxuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIGlmIChuYW1lQ29udGFpbnMpXG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibmFtZV9jb250YWluc1wiLCBuYW1lQ29udGFpbnMpO1xuICAgICAgICBwYXJhbXMuYXBwZW5kKFwibGltaXRcIiwgKGxpbWl0ICE9PSB1bmRlZmluZWQgPyBNYXRoLm1pbihsaW1pdCwgMTAwKSA6IDEwMCkudG9TdHJpbmcoKSk7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgcXVldWVzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9hbm5vdGF0aW9uLXF1ZXVlc1wiLCBwYXJhbXMpKSB7XG4gICAgICAgICAgICB5aWVsZCogcXVldWVzO1xuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkICYmIGNvdW50ID49IGxpbWl0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBhbm5vdGF0aW9uIHF1ZXVlIG9uIHRoZSBMYW5nU21pdGggQVBJLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIGFuIGFubm90YXRpb24gcXVldWVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGFubm90YXRpb24gcXVldWVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kZXNjcmlwdGlvbiAtIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLnF1ZXVlSWQgLSBUaGUgSUQgb2YgdGhlIGFubm90YXRpb24gcXVldWVcbiAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBBbm5vdGF0aW9uUXVldWUgb2JqZWN0XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlQW5ub3RhdGlvblF1ZXVlKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBkZXNjcmlwdGlvbiwgcXVldWVJZCB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGlkOiBxdWV1ZUlkIHx8IHV1aWQudjQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9hbm5vdGF0aW9uLXF1ZXVlc2AsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhib2R5KS5maWx0ZXIoKFtfLCB2XSkgPT4gdiAhPT0gdW5kZWZpbmVkKSkpLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImNyZWF0ZSBhbm5vdGF0aW9uIHF1ZXVlXCIpO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhbiBhbm5vdGF0aW9uIHF1ZXVlIHdpdGggdGhlIHNwZWNpZmllZCBxdWV1ZSBJRC5cbiAgICAgKiBAcGFyYW0gcXVldWVJZCAtIFRoZSBJRCBvZiB0aGUgYW5ub3RhdGlvbiBxdWV1ZSB0byByZWFkXG4gICAgICogQHJldHVybnMgVGhlIEFubm90YXRpb25RdWV1ZSBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyByZWFkQW5ub3RhdGlvblF1ZXVlKHF1ZXVlSWQpIHtcbiAgICAgICAgLy8gVE9ETzogUmVwbGFjZSB3aGVuIGFjdHVhbCBlbmRwb2ludCBpcyBhZGRlZFxuICAgICAgICBjb25zdCBxdWV1ZUl0ZXJhdG9yUmVzdWx0ID0gYXdhaXQgdGhpcy5saXN0QW5ub3RhdGlvblF1ZXVlcyh7XG4gICAgICAgICAgICBxdWV1ZUlkczogW3F1ZXVlSWRdLFxuICAgICAgICB9KS5uZXh0KCk7XG4gICAgICAgIGlmIChxdWV1ZUl0ZXJhdG9yUmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW5ub3RhdGlvbiBxdWV1ZSB3aXRoIElEICR7cXVldWVJZH0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHF1ZXVlSXRlcmF0b3JSZXN1bHQudmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhbiBhbm5vdGF0aW9uIHF1ZXVlIHdpdGggdGhlIHNwZWNpZmllZCBxdWV1ZSBJRC5cbiAgICAgKiBAcGFyYW0gcXVldWVJZCAtIFRoZSBJRCBvZiB0aGUgYW5ub3RhdGlvbiBxdWV1ZSB0byB1cGRhdGVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB1cGRhdGluZyB0aGUgYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBUaGUgbmV3IG5hbWUgZm9yIHRoZSBhbm5vdGF0aW9uIHF1ZXVlXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGVzY3JpcHRpb24gLSBUaGUgbmV3IGRlc2NyaXB0aW9uIGZvciB0aGUgYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZUFubm90YXRpb25RdWV1ZShxdWV1ZUlkLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgZGVzY3JpcHRpb24gfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vYW5ub3RhdGlvbi1xdWV1ZXMvJHthc3NlcnRVdWlkKHF1ZXVlSWQsIFwicXVldWVJZFwiKX1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBuYW1lLCBkZXNjcmlwdGlvbiB9KSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJ1cGRhdGUgYW5ub3RhdGlvbiBxdWV1ZVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGFuIGFubm90YXRpb24gcXVldWUgd2l0aCB0aGUgc3BlY2lmaWVkIHF1ZXVlIElELlxuICAgICAqIEBwYXJhbSBxdWV1ZUlkIC0gVGhlIElEIG9mIHRoZSBhbm5vdGF0aW9uIHF1ZXVlIHRvIGRlbGV0ZVxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZUFubm90YXRpb25RdWV1ZShxdWV1ZUlkKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vYW5ub3RhdGlvbi1xdWV1ZXMvJHthc3NlcnRVdWlkKHF1ZXVlSWQsIFwicXVldWVJZFwiKX1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImRlbGV0ZSBhbm5vdGF0aW9uIHF1ZXVlXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgcnVucyB0byBhbiBhbm5vdGF0aW9uIHF1ZXVlIHdpdGggdGhlIHNwZWNpZmllZCBxdWV1ZSBJRC5cbiAgICAgKiBAcGFyYW0gcXVldWVJZCAtIFRoZSBJRCBvZiB0aGUgYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqIEBwYXJhbSBydW5JZHMgLSBUaGUgSURzIG9mIHRoZSBydW5zIHRvIGJlIGFkZGVkIHRvIHRoZSBhbm5vdGF0aW9uIHF1ZXVlXG4gICAgICovXG4gICAgYXN5bmMgYWRkUnVuc1RvQW5ub3RhdGlvblF1ZXVlKHF1ZXVlSWQsIHJ1bklkcykge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L2Fubm90YXRpb24tcXVldWVzLyR7YXNzZXJ0VXVpZChxdWV1ZUlkLCBcInF1ZXVlSWRcIil9L3J1bnNgLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShydW5JZHMubWFwKChpZCwgaSkgPT4gYXNzZXJ0VXVpZChpZCwgYHJ1bklkc1ske2l9XWApLnRvU3RyaW5nKCkpKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJhZGQgcnVucyB0byBhbm5vdGF0aW9uIHF1ZXVlXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBydW4gZnJvbSBhbiBhbm5vdGF0aW9uIHF1ZXVlIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAgICogQHBhcmFtIHF1ZXVlSWQgLSBUaGUgSUQgb2YgdGhlIGFubm90YXRpb24gcXVldWVcbiAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIHJ1biB0byByZXRyaWV2ZVxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgUnVuV2l0aEFubm90YXRpb25RdWV1ZUluZm8gb2JqZWN0XG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBydW4gaXMgbm90IGZvdW5kIGF0IHRoZSBnaXZlbiBpbmRleCBvciBmb3Igb3RoZXIgQVBJLXJlbGF0ZWQgZXJyb3JzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UnVuRnJvbUFubm90YXRpb25RdWV1ZShxdWV1ZUlkLCBpbmRleCkge1xuICAgICAgICBjb25zdCBiYXNlVXJsID0gYC9hbm5vdGF0aW9uLXF1ZXVlcy8ke2Fzc2VydFV1aWQocXVldWVJZCwgXCJxdWV1ZUlkXCIpfS9ydW5gO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9JHtiYXNlVXJsfS8ke2luZGV4fWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJnZXQgcnVuIGZyb20gYW5ub3RhdGlvbiBxdWV1ZVwiKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgYXN5bmMgX2N1cnJlbnRUZW5hbnRJc093bmVyKG93bmVyKSB7XG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gYXdhaXQgdGhpcy5fZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgcmV0dXJuIG93bmVyID09IFwiLVwiIHx8IHNldHRpbmdzLnRlbmFudF9oYW5kbGUgPT09IG93bmVyO1xuICAgIH1cbiAgICBhc3luYyBfb3duZXJDb25mbGljdEVycm9yKGFjdGlvbiwgb3duZXIpIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBhd2FpdCB0aGlzLl9nZXRTZXR0aW5ncygpO1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKGBDYW5ub3QgJHthY3Rpb259IGZvciBhbm90aGVyIHRlbmFudC5cXG5cbiAgICAgIEN1cnJlbnQgdGVuYW50OiAke3NldHRpbmdzLnRlbmFudF9oYW5kbGV9XFxuXG4gICAgICBSZXF1ZXN0ZWQgdGVuYW50OiAke293bmVyfWApO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0TGF0ZXN0Q29tbWl0SGFzaChwcm9tcHRPd25lckFuZE5hbWUpIHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vY29tbWl0cy8ke3Byb21wdE93bmVyQW5kTmFtZX0vP2xpbWl0PSR7MX0mb2Zmc2V0PSR7MH1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgICAgICBjb25zdCBkZXRhaWwgPSB0eXBlb2YganNvbi5kZXRhaWwgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICA/IGpzb24uZGV0YWlsXG4gICAgICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeShqc29uLmRldGFpbCk7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgRXJyb3IgJHtyZXMuc3RhdHVzfTogJHtyZXMuc3RhdHVzVGV4dH1cXG4ke2RldGFpbH1gKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBlcnJvci5zdGF0dXNDb2RlID0gcmVzLnN0YXR1cztcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqc29uLmNvbW1pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc29uLmNvbW1pdHNbMF0uY29tbWl0X2hhc2g7XG4gICAgfVxuICAgIGFzeW5jIF9saWtlT3JVbmxpa2VQcm9tcHQocHJvbXB0SWRlbnRpZmllciwgbGlrZSkge1xuICAgICAgICBjb25zdCBbb3duZXIsIHByb21wdE5hbWUsIF9dID0gcGFyc2VQcm9tcHRJZGVudGlmaWVyKHByb21wdElkZW50aWZpZXIpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSwgYCR7dGhpcy5hcGlVcmx9L2xpa2VzLyR7b3duZXJ9LyR7cHJvbXB0TmFtZX1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBsaWtlOiBsaWtlIH0pLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIGAke2xpa2UgPyBcImxpa2VcIiA6IFwidW5saWtlXCJ9IHByb21wdGApO1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0UHJvbXB0VXJsKHByb21wdElkZW50aWZpZXIpIHtcbiAgICAgICAgY29uc3QgW293bmVyLCBwcm9tcHROYW1lLCBjb21taXRIYXNoXSA9IHBhcnNlUHJvbXB0SWRlbnRpZmllcihwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5fY3VycmVudFRlbmFudElzT3duZXIob3duZXIpKSkge1xuICAgICAgICAgICAgaWYgKGNvbW1pdEhhc2ggIT09IFwibGF0ZXN0XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L2h1Yi8ke293bmVyfS8ke3Byb21wdE5hbWV9LyR7Y29tbWl0SGFzaC5zdWJzdHJpbmcoMCwgOCl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vaHViLyR7b3duZXJ9LyR7cHJvbXB0TmFtZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBhd2FpdCB0aGlzLl9nZXRTZXR0aW5ncygpO1xuICAgICAgICAgICAgaWYgKGNvbW1pdEhhc2ggIT09IFwibGF0ZXN0XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L3Byb21wdHMvJHtwcm9tcHROYW1lfS8ke2NvbW1pdEhhc2guc3Vic3RyaW5nKDAsIDgpfT9vcmdhbml6YXRpb25JZD0ke3NldHRpbmdzLmlkfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L3Byb21wdHMvJHtwcm9tcHROYW1lfT9vcmdhbml6YXRpb25JZD0ke3NldHRpbmdzLmlkfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcHJvbXB0RXhpc3RzKHByb21wdElkZW50aWZpZXIpIHtcbiAgICAgICAgY29uc3QgcHJvbXB0ID0gYXdhaXQgdGhpcy5nZXRQcm9tcHQocHJvbXB0SWRlbnRpZmllcik7XG4gICAgICAgIHJldHVybiAhIXByb21wdDtcbiAgICB9XG4gICAgYXN5bmMgbGlrZVByb21wdChwcm9tcHRJZGVudGlmaWVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saWtlT3JVbmxpa2VQcm9tcHQocHJvbXB0SWRlbnRpZmllciwgdHJ1ZSk7XG4gICAgfVxuICAgIGFzeW5jIHVubGlrZVByb21wdChwcm9tcHRJZGVudGlmaWVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saWtlT3JVbmxpa2VQcm9tcHQocHJvbXB0SWRlbnRpZmllciwgZmFsc2UpO1xuICAgIH1cbiAgICBhc3luYyAqbGlzdENvbW1pdHMocHJvbXB0T3duZXJBbmROYW1lKSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY29tbWl0cyBvZiB0aGlzLl9nZXRQYWdpbmF0ZWQoYC9jb21taXRzLyR7cHJvbXB0T3duZXJBbmROYW1lfS9gLCBuZXcgVVJMU2VhcmNoUGFyYW1zKCksIChyZXMpID0+IHJlcy5jb21taXRzKSkge1xuICAgICAgICAgICAgeWllbGQqIGNvbW1pdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgKmxpc3RQcm9tcHRzKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBwYXJhbXMuYXBwZW5kKFwic29ydF9maWVsZFwiLCBvcHRpb25zPy5zb3J0RmllbGQgPz8gXCJ1cGRhdGVkX2F0XCIpO1xuICAgICAgICBwYXJhbXMuYXBwZW5kKFwic29ydF9kaXJlY3Rpb25cIiwgXCJkZXNjXCIpO1xuICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaXNfYXJjaGl2ZWRcIiwgKCEhb3B0aW9ucz8uaXNBcmNoaXZlZCkudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmIChvcHRpb25zPy5pc1B1YmxpYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaXNfcHVibGljXCIsIG9wdGlvbnMuaXNQdWJsaWMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnM/LnF1ZXJ5KSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwicXVlcnlcIiwgb3B0aW9ucy5xdWVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBwcm9tcHRzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9yZXBvc1wiLCBwYXJhbXMsIChyZXMpID0+IHJlcy5yZXBvcykpIHtcbiAgICAgICAgICAgIHlpZWxkKiBwcm9tcHRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFByb21wdChwcm9tcHRJZGVudGlmaWVyKSB7XG4gICAgICAgIGNvbnN0IFtvd25lciwgcHJvbXB0TmFtZSwgX10gPSBwYXJzZVByb21wdElkZW50aWZpZXIocHJvbXB0SWRlbnRpZmllcik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vcmVwb3MvJHtvd25lcn0vJHtwcm9tcHROYW1lfWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcImdldCBwcm9tcHRcIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKHJlc3VsdC5yZXBvKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlcG87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjcmVhdGVQcm9tcHQocHJvbXB0SWRlbnRpZmllciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGF3YWl0IHRoaXMuX2dldFNldHRpbmdzKCk7XG4gICAgICAgIGlmIChvcHRpb25zPy5pc1B1YmxpYyAmJiAhc2V0dGluZ3MudGVuYW50X2hhbmRsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY3JlYXRlIGEgcHVibGljIHByb21wdCB3aXRob3V0IGZpcnN0XFxuXG4gICAgICAgIGNyZWF0aW5nIGEgTGFuZ0NoYWluIEh1YiBoYW5kbGUuIFxuICAgICAgICBZb3UgY2FuIGFkZCBhIGhhbmRsZSBieSBjcmVhdGluZyBhIHB1YmxpYyBwcm9tcHQgYXQ6XFxuXG4gICAgICAgIGh0dHBzOi8vc21pdGgubGFuZ2NoYWluLmNvbS9wcm9tcHRzYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW293bmVyLCBwcm9tcHROYW1lLCBfXSA9IHBhcnNlUHJvbXB0SWRlbnRpZmllcihwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5fY3VycmVudFRlbmFudElzT3duZXIob3duZXIpKSkge1xuICAgICAgICAgICAgdGhyb3cgYXdhaXQgdGhpcy5fb3duZXJDb25mbGljdEVycm9yKFwiY3JlYXRlIGEgcHJvbXB0XCIsIG93bmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgcmVwb19oYW5kbGU6IHByb21wdE5hbWUsXG4gICAgICAgICAgICAuLi4ob3B0aW9ucz8uZGVzY3JpcHRpb24gJiYgeyBkZXNjcmlwdGlvbjogb3B0aW9ucy5kZXNjcmlwdGlvbiB9KSxcbiAgICAgICAgICAgIC4uLihvcHRpb25zPy5yZWFkbWUgJiYgeyByZWFkbWU6IG9wdGlvbnMucmVhZG1lIH0pLFxuICAgICAgICAgICAgLi4uKG9wdGlvbnM/LnRhZ3MgJiYgeyB0YWdzOiBvcHRpb25zLnRhZ3MgfSksXG4gICAgICAgICAgICBpc19wdWJsaWM6ICEhb3B0aW9ucz8uaXNQdWJsaWMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbigpLCBgJHt0aGlzLmFwaVVybH0vcmVwb3MvYCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIFwiY3JlYXRlIHByb21wdFwiKTtcbiAgICAgICAgY29uc3QgeyByZXBvIH0gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXBvO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVDb21taXQocHJvbXB0SWRlbnRpZmllciwgb2JqZWN0LCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMucHJvbXB0RXhpc3RzKHByb21wdElkZW50aWZpZXIpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvbXB0IGRvZXMgbm90IGV4aXN0LCB5b3UgbXVzdCBjcmVhdGUgaXQgZmlyc3QuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtvd25lciwgcHJvbXB0TmFtZSwgX10gPSBwYXJzZVByb21wdElkZW50aWZpZXIocHJvbXB0SWRlbnRpZmllcik7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkUGFyZW50Q29tbWl0SGFzaCA9IG9wdGlvbnM/LnBhcmVudENvbW1pdEhhc2ggPT09IFwibGF0ZXN0XCIgfHwgIW9wdGlvbnM/LnBhcmVudENvbW1pdEhhc2hcbiAgICAgICAgICAgID8gYXdhaXQgdGhpcy5fZ2V0TGF0ZXN0Q29tbWl0SGFzaChgJHtvd25lcn0vJHtwcm9tcHROYW1lfWApXG4gICAgICAgICAgICA6IG9wdGlvbnM/LnBhcmVudENvbW1pdEhhc2g7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICBtYW5pZmVzdDogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmplY3QpKSxcbiAgICAgICAgICAgIHBhcmVudF9jb21taXQ6IHJlc29sdmVkUGFyZW50Q29tbWl0SGFzaCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9jb21taXRzLyR7b3duZXJ9LyR7cHJvbXB0TmFtZX1gLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJjcmVhdGUgY29tbWl0XCIpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRQcm9tcHRVcmwoYCR7b3duZXJ9LyR7cHJvbXB0TmFtZX0ke3Jlc3VsdC5jb21taXRfaGFzaCA/IGA6JHtyZXN1bHQuY29tbWl0X2hhc2h9YCA6IFwiXCJ9YCk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZVByb21wdChwcm9tcHRJZGVudGlmaWVyLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMucHJvbXB0RXhpc3RzKHByb21wdElkZW50aWZpZXIpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvbXB0IGRvZXMgbm90IGV4aXN0LCB5b3UgbXVzdCBjcmVhdGUgaXQgZmlyc3QuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtvd25lciwgcHJvbXB0TmFtZV0gPSBwYXJzZVByb21wdElkZW50aWZpZXIocHJvbXB0SWRlbnRpZmllcik7XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMuX2N1cnJlbnRUZW5hbnRJc093bmVyKG93bmVyKSkpIHtcbiAgICAgICAgICAgIHRocm93IGF3YWl0IHRoaXMuX293bmVyQ29uZmxpY3RFcnJvcihcInVwZGF0ZSBhIHByb21wdFwiLCBvd25lcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAob3B0aW9ucz8uZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHBheWxvYWQuZGVzY3JpcHRpb24gPSBvcHRpb25zLmRlc2NyaXB0aW9uO1xuICAgICAgICBpZiAob3B0aW9ucz8ucmVhZG1lICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBwYXlsb2FkLnJlYWRtZSA9IG9wdGlvbnMucmVhZG1lO1xuICAgICAgICBpZiAob3B0aW9ucz8udGFncyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcGF5bG9hZC50YWdzID0gb3B0aW9ucy50YWdzO1xuICAgICAgICBpZiAob3B0aW9ucz8uaXNQdWJsaWMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHBheWxvYWQuaXNfcHVibGljID0gb3B0aW9ucy5pc1B1YmxpYztcbiAgICAgICAgaWYgKG9wdGlvbnM/LmlzQXJjaGl2ZWQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHBheWxvYWQuaXNfYXJjaGl2ZWQgPSBvcHRpb25zLmlzQXJjaGl2ZWQ7XG4gICAgICAgIC8vIENoZWNrIGlmIHBheWxvYWQgaXMgZW1wdHlcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHBheWxvYWQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdmFsaWQgdXBkYXRlIG9wdGlvbnMgcHJvdmlkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9yZXBvcy8ke293bmVyfS8ke3Byb21wdE5hbWV9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBBVENIXCIsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBcInVwZGF0ZSBwcm9tcHRcIik7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZVByb21wdChwcm9tcHRJZGVudGlmaWVyKSB7XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMucHJvbXB0RXhpc3RzKHByb21wdElkZW50aWZpZXIpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvbXB0IGRvZXMgbm90IGV4aXN0LCB5b3UgbXVzdCBjcmVhdGUgaXQgZmlyc3QuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtvd25lciwgcHJvbXB0TmFtZSwgX10gPSBwYXJzZVByb21wdElkZW50aWZpZXIocHJvbXB0SWRlbnRpZmllcik7XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMuX2N1cnJlbnRUZW5hbnRJc093bmVyKG93bmVyKSkpIHtcbiAgICAgICAgICAgIHRocm93IGF3YWl0IHRoaXMuX293bmVyQ29uZmxpY3RFcnJvcihcImRlbGV0ZSBhIHByb21wdFwiLCBvd25lcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9yZXBvcy8ke293bmVyfS8ke3Byb21wdE5hbWV9YCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jIHB1bGxQcm9tcHRDb21taXQocHJvbXB0SWRlbnRpZmllciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBbb3duZXIsIHByb21wdE5hbWUsIGNvbW1pdEhhc2hdID0gcGFyc2VQcm9tcHRJZGVudGlmaWVyKHByb21wdElkZW50aWZpZXIpO1xuICAgICAgICBjb25zdCBzZXJ2ZXJJbmZvID0gYXdhaXQgdGhpcy5fZ2V0U2VydmVySW5mbygpO1xuICAgICAgICBjb25zdCB1c2VPcHRpbWl6YXRpb24gPSBpc1ZlcnNpb25HcmVhdGVyT3JFcXVhbChzZXJ2ZXJJbmZvLnZlcnNpb24sIFwiMC41LjIzXCIpO1xuICAgICAgICBsZXQgcGFzc2VkQ29tbWl0SGFzaCA9IGNvbW1pdEhhc2g7XG4gICAgICAgIGlmICghdXNlT3B0aW1pemF0aW9uICYmIGNvbW1pdEhhc2ggPT09IFwibGF0ZXN0XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhdGVzdENvbW1pdEhhc2ggPSBhd2FpdCB0aGlzLl9nZXRMYXRlc3RDb21taXRIYXNoKGAke293bmVyfS8ke3Byb21wdE5hbWV9YCk7XG4gICAgICAgICAgICBpZiAoIWxhdGVzdENvbW1pdEhhc2gpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjb21taXRzIGZvdW5kXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFzc2VkQ29tbWl0SGFzaCA9IGxhdGVzdENvbW1pdEhhc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKCksIGAke3RoaXMuYXBpVXJsfS9jb21taXRzLyR7b3duZXJ9LyR7cHJvbXB0TmFtZX0vJHtwYXNzZWRDb21taXRIYXNofSR7b3B0aW9ucz8uaW5jbHVkZU1vZGVsID8gXCI/aW5jbHVkZV9tb2RlbD10cnVlXCIgOiBcIlwifWAsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXNwb25zZSwgXCJwdWxsIHByb21wdCBjb21taXRcIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG93bmVyLFxuICAgICAgICAgICAgcmVwbzogcHJvbXB0TmFtZSxcbiAgICAgICAgICAgIGNvbW1pdF9oYXNoOiByZXN1bHQuY29tbWl0X2hhc2gsXG4gICAgICAgICAgICBtYW5pZmVzdDogcmVzdWx0Lm1hbmlmZXN0LFxuICAgICAgICAgICAgZXhhbXBsZXM6IHJlc3VsdC5leGFtcGxlcyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkIGRpcmVjdGx5LCB1c2UgYGltcG9ydCB7IHB1bGwgfSBmcm9tIFwibGFuZ2NoYWluL2h1YlwiYCBpbnN0ZWFkLlxuICAgICAqIFVzaW5nIHRoaXMgbWV0aG9kIGRpcmVjdGx5IHJldHVybnMgdGhlIEpTT04gc3RyaW5nIG9mIHRoZSBwcm9tcHQgcmF0aGVyIHRoYW4gYSBMYW5nQ2hhaW4gb2JqZWN0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgX3B1bGxQcm9tcHQocHJvbXB0SWRlbnRpZmllciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBwcm9tcHRPYmplY3QgPSBhd2FpdCB0aGlzLnB1bGxQcm9tcHRDb21taXQocHJvbXB0SWRlbnRpZmllciwge1xuICAgICAgICAgICAgaW5jbHVkZU1vZGVsOiBvcHRpb25zPy5pbmNsdWRlTW9kZWwsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwcm9tcHQgPSBKU09OLnN0cmluZ2lmeShwcm9tcHRPYmplY3QubWFuaWZlc3QpO1xuICAgICAgICByZXR1cm4gcHJvbXB0O1xuICAgIH1cbiAgICBhc3luYyBwdXNoUHJvbXB0KHByb21wdElkZW50aWZpZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gQ3JlYXRlIG9yIHVwZGF0ZSBwcm9tcHQgbWV0YWRhdGFcbiAgICAgICAgaWYgKGF3YWl0IHRoaXMucHJvbXB0RXhpc3RzKHByb21wdElkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBPYmplY3Qua2V5cyhvcHRpb25zKS5zb21lKChrZXkpID0+IGtleSAhPT0gXCJvYmplY3RcIikpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZVByb21wdChwcm9tcHRJZGVudGlmaWVyLCB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBvcHRpb25zPy5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcmVhZG1lOiBvcHRpb25zPy5yZWFkbWUsXG4gICAgICAgICAgICAgICAgICAgIHRhZ3M6IG9wdGlvbnM/LnRhZ3MsXG4gICAgICAgICAgICAgICAgICAgIGlzUHVibGljOiBvcHRpb25zPy5pc1B1YmxpYyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY3JlYXRlUHJvbXB0KHByb21wdElkZW50aWZpZXIsIHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogb3B0aW9ucz8uZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgcmVhZG1lOiBvcHRpb25zPy5yZWFkbWUsXG4gICAgICAgICAgICAgICAgdGFnczogb3B0aW9ucz8udGFncyxcbiAgICAgICAgICAgICAgICBpc1B1YmxpYzogb3B0aW9ucz8uaXNQdWJsaWMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdGlvbnM/Lm9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2dldFByb21wdFVybChwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSBjb21taXQgd2l0aCB0aGUgbmV3IG1hbmlmZXN0XG4gICAgICAgIGNvbnN0IHVybCA9IGF3YWl0IHRoaXMuY3JlYXRlQ29tbWl0KHByb21wdElkZW50aWZpZXIsIG9wdGlvbnM/Lm9iamVjdCwge1xuICAgICAgICAgICAgcGFyZW50Q29tbWl0SGFzaDogb3B0aW9ucz8ucGFyZW50Q29tbWl0SGFzaCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb25lIGEgcHVibGljIGRhdGFzZXQgdG8geW91ciBvd24gbGFuZ3NtaXRoIHRlbmFudC5cbiAgICAgKiBUaGlzIG9wZXJhdGlvbiBpcyBpZGVtcG90ZW50LiBJZiB5b3UgYWxyZWFkeSBoYXZlIGEgZGF0YXNldCB3aXRoIHRoZSBnaXZlbiBuYW1lLFxuICAgICAqIHRoaXMgZnVuY3Rpb24gd2lsbCBkbyBub3RoaW5nLlxuICBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5PclVybCBUaGUgdG9rZW4gb2YgdGhlIHB1YmxpYyBkYXRhc2V0IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBvcHRpb25zIGZvciBjbG9uaW5nIHRoZSBkYXRhc2V0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zb3VyY2VBcGlVcmxdIFRoZSBVUkwgb2YgdGhlIGxhbmdzbWl0aCBzZXJ2ZXIgd2hlcmUgdGhlIGRhdGEgaXMgaG9zdGVkLiBEZWZhdWx0cyB0byB0aGUgQVBJIFVSTCBvZiB5b3VyIGN1cnJlbnQgY2xpZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5kYXRhc2V0TmFtZV0gVGhlIG5hbWUgb2YgdGhlIGRhdGFzZXQgdG8gY3JlYXRlIGluIHlvdXIgdGVuYW50LiBEZWZhdWx0cyB0byB0aGUgbmFtZSBvZiB0aGUgcHVibGljIGRhdGFzZXQuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgY2xvbmVQdWJsaWNEYXRhc2V0KHRva2VuT3JVcmwsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IHNvdXJjZUFwaVVybCA9IHRoaXMuYXBpVXJsLCBkYXRhc2V0TmFtZSB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgW3BhcnNlZEFwaVVybCwgdG9rZW5VdWlkXSA9IHRoaXMucGFyc2VUb2tlbk9yVXJsKHRva2VuT3JVcmwsIHNvdXJjZUFwaVVybCk7XG4gICAgICAgIGNvbnN0IHNvdXJjZUNsaWVudCA9IG5ldyBDbGllbnQoe1xuICAgICAgICAgICAgYXBpVXJsOiBwYXJzZWRBcGlVcmwsXG4gICAgICAgICAgICAvLyBQbGFjZWhvbGRlciBBUEkga2V5IG5vdCBuZWVkZWQgYW55bW9yZSBpbiBtb3N0IGNhc2VzLCBidXRcbiAgICAgICAgICAgIC8vIHNvbWUgcHJpdmF0ZSBkZXBsb3ltZW50cyBtYXkgaGF2ZSBBUEkga2V5LWJhc2VkIHJhdGUgbGltaXRpbmdcbiAgICAgICAgICAgIC8vIHRoYXQgd291bGQgY2F1c2UgdGhpcyB0byBmYWlsIGlmIHdlIHByb3ZpZGUgbm8gdmFsdWUuXG4gICAgICAgICAgICBhcGlLZXk6IFwicGxhY2Vob2xkZXJcIixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGRzID0gYXdhaXQgc291cmNlQ2xpZW50LnJlYWRTaGFyZWREYXRhc2V0KHRva2VuVXVpZCk7XG4gICAgICAgIGNvbnN0IGZpbmFsRGF0YXNldE5hbWUgPSBkYXRhc2V0TmFtZSB8fCBkcy5uYW1lO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGF3YWl0IHRoaXMuaGFzRGF0YXNldCh7IGRhdGFzZXRJZDogZmluYWxEYXRhc2V0TmFtZSB9KSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBEYXRhc2V0ICR7ZmluYWxEYXRhc2V0TmFtZX0gYWxyZWFkeSBleGlzdHMgaW4geW91ciB0ZW5hbnQuIFNraXBwaW5nLmApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgLy8gYC5oYXNEYXRhc2V0YCB3aWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBkYXRhc2V0IGRvZXMgbm90IGV4aXN0LlxuICAgICAgICAgICAgLy8gbm8tb3AgaW4gdGhhdCBjYXNlXG4gICAgICAgIH1cbiAgICAgICAgLy8gRmV0Y2ggZXhhbXBsZXMgZmlyc3QsIHRoZW4gY3JlYXRlIHRoZSBkYXRhc2V0XG4gICAgICAgIGNvbnN0IGV4YW1wbGVzID0gYXdhaXQgc291cmNlQ2xpZW50Lmxpc3RTaGFyZWRFeGFtcGxlcyh0b2tlblV1aWQpO1xuICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5jcmVhdGVEYXRhc2V0KGZpbmFsRGF0YXNldE5hbWUsIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBkcy5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGRhdGFUeXBlOiBkcy5kYXRhX3R5cGUgfHwgXCJrdlwiLFxuICAgICAgICAgICAgaW5wdXRzU2NoZW1hOiBkcy5pbnB1dHNfc2NoZW1hX2RlZmluaXRpb24gPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgb3V0cHV0c1NjaGVtYTogZHMub3V0cHV0c19zY2hlbWFfZGVmaW5pdGlvbiA/PyB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jcmVhdGVFeGFtcGxlcyh7XG4gICAgICAgICAgICAgICAgaW5wdXRzOiBleGFtcGxlcy5tYXAoKGUpID0+IGUuaW5wdXRzKSxcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiBleGFtcGxlcy5mbGF0TWFwKChlKSA9PiAoZS5vdXRwdXRzID8gW2Uub3V0cHV0c10gOiBbXSkpLFxuICAgICAgICAgICAgICAgIGRhdGFzZXRJZDogZGF0YXNldC5pZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSBjcmVhdGluZyBkYXRhc2V0ICR7ZmluYWxEYXRhc2V0TmFtZX0uIGAgK1xuICAgICAgICAgICAgICAgIFwiWW91IHNob3VsZCBkZWxldGUgaXQgbWFudWFsbHkuXCIpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJzZVRva2VuT3JVcmwodXJsT3JUb2tlbiwgYXBpVXJsLCBudW1QYXJ0cyA9IDIsIGtpbmQgPSBcImRhdGFzZXRcIikge1xuICAgICAgICAvLyBUcnkgcGFyc2luZyBhcyBVVUlEXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhc3NlcnRVdWlkKHVybE9yVG9rZW4pOyAvLyBXaWxsIHRocm93IGlmIGl0J3Mgbm90IGEgVVVJRC5cbiAgICAgICAgICAgIHJldHVybiBbYXBpVXJsLCB1cmxPclRva2VuXTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgLy8gbm8tb3AgaWYgaXQncyBub3QgYSB1dWlkXG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFyc2UgYXMgVVJMXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRVcmwgPSBuZXcgVVJMKHVybE9yVG9rZW4pO1xuICAgICAgICAgICAgY29uc3QgcGF0aFBhcnRzID0gcGFyc2VkVXJsLnBhdGhuYW1lXG4gICAgICAgICAgICAgICAgLnNwbGl0KFwiL1wiKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHBhcnQpID0+IHBhcnQgIT09IFwiXCIpO1xuICAgICAgICAgICAgaWYgKHBhdGhQYXJ0cy5sZW5ndGggPj0gbnVtUGFydHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlblV1aWQgPSBwYXRoUGFydHNbcGF0aFBhcnRzLmxlbmd0aCAtIG51bVBhcnRzXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2FwaVVybCwgdG9rZW5VdWlkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwdWJsaWMgJHtraW5kfSBVUkw6ICR7dXJsT3JUb2tlbn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwdWJsaWMgJHtraW5kfSBVUkwgb3IgdG9rZW46ICR7dXJsT3JUb2tlbn1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBd2FpdHMgYWxsIHBlbmRpbmcgdHJhY2UgYmF0Y2hlcy4gVXNlZnVsIGZvciBlbnZpcm9ubWVudHMgd2hlcmVcbiAgICAgKiB5b3UgbmVlZCB0byBiZSBzdXJlIHRoYXQgYWxsIHRyYWNpbmcgcmVxdWVzdHMgZmluaXNoIGJlZm9yZSBleGVjdXRpb24gZW5kcyxcbiAgICAgKiBzdWNoIGFzIHNlcnZlcmxlc3MgZW52aXJvbm1lbnRzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBcbiAgICAgKiBpbXBvcnQgeyBDbGllbnQgfSBmcm9tIFwibGFuZ3NtaXRoXCI7XG4gICAgICpcbiAgICAgKiBjb25zdCBjbGllbnQgPSBuZXcgQ2xpZW50KCk7XG4gICAgICpcbiAgICAgKiB0cnkge1xuICAgICAqICAgLy8gVHJhY2luZyBoYXBwZW5zIGhlcmVcbiAgICAgKiAgIC4uLlxuICAgICAqIH0gZmluYWxseSB7XG4gICAgICogICBhd2FpdCBjbGllbnQuYXdhaXRQZW5kaW5nVHJhY2VCYXRjaGVzKCk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgb25jZSBhbGwgY3VycmVudGx5IHBlbmRpbmcgdHJhY2VzIGhhdmUgc2VudC5cbiAgICAgKi9cbiAgICBhd2FpdFBlbmRpbmdUcmFjZUJhdGNoZXMoKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLmF1dG9CYXRjaFF1ZXVlLml0ZW1zLm1hcCgoeyBpdGVtUHJvbWlzZSB9KSA9PiBpdGVtUHJvbWlzZSkpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJ1dWlkIiwiQXN5bmNDYWxsZXIiLCJjb252ZXJ0TGFuZ0NoYWluTWVzc2FnZVRvRXhhbXBsZSIsImlzTGFuZ0NoYWluTWVzc2FnZSIsImdldExhbmdDaGFpbkVudlZhcnNNZXRhZGF0YSIsImdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUiLCJnZXRSdW50aW1lRW52aXJvbm1lbnQiLCJfX3ZlcnNpb25fXyIsImFzc2VydFV1aWQiLCJ3YXJuT25jZSIsImlzVmVyc2lvbkdyZWF0ZXJPckVxdWFsIiwicGFyc2VQcm9tcHRJZGVudGlmaWVyIiwicmFpc2VGb3JTdGF0dXMiLCJfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbiIsInN0cmluZ2lmeSIsInN0cmluZ2lmeUZvclRyYWNpbmciLCJtZXJnZVJ1bnRpbWVFbnZJbnRvUnVuQ3JlYXRlIiwicnVuIiwicnVudGltZUVudiIsImVudlZhcnMiLCJleHRyYSIsIm1ldGFkYXRhIiwicnVudGltZSIsInJldmlzaW9uX2lkIiwiZ2V0VHJhY2luZ1NhbXBsaW5nUmF0ZSIsInNhbXBsaW5nUmF0ZVN0ciIsInVuZGVmaW5lZCIsInNhbXBsaW5nUmF0ZSIsInBhcnNlRmxvYXQiLCJFcnJvciIsImlzTG9jYWxob3N0IiwidXJsIiwic3RyaXBwZWRVcmwiLCJyZXBsYWNlIiwiaG9zdG5hbWUiLCJzcGxpdCIsInRvQXJyYXkiLCJpdGVyYWJsZSIsInJlc3VsdCIsIml0ZW0iLCJwdXNoIiwidHJpbVF1b3RlcyIsInN0ciIsInRyaW0iLCJoYW5kbGU0MjkiLCJyZXNwb25zZSIsInN0YXR1cyIsInJldHJ5QWZ0ZXIiLCJwYXJzZUludCIsImhlYWRlcnMiLCJnZXQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJRdWV1ZSIsImNvbnN0cnVjdG9yIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSIsInBlZWsiLCJpdGVtcyIsIml0ZW1Qcm9taXNlUmVzb2x2ZSIsIml0ZW1Qcm9taXNlIiwic2l6ZSIsImxlbmd0aCIsImFjdGlvbiIsInBheWxvYWQiLCJzaXplQnl0ZXMiLCJwb3AiLCJ1cFRvU2l6ZUJ5dGVzIiwicG9wcGVkIiwicG9wcGVkU2l6ZUJ5dGVzIiwic2hpZnQiLCJtYXAiLCJpdCIsImZvckVhY2giLCJERUZBVUxUX0JBVENIX1NJWkVfTElNSVRfQllURVMiLCJTRVJWRVJfSU5GT19SRVFVRVNUX1RJTUVPVVQiLCJDbGllbnQiLCJjb25maWciLCJTZXQiLCJkZWZhdWx0Q29uZmlnIiwiZ2V0RGVmYXVsdENsaWVudENvbmZpZyIsInRyYWNpbmdTYW1wbGVSYXRlIiwiYXBpVXJsIiwiZW5kc1dpdGgiLCJzbGljZSIsImFwaUtleSIsIndlYlVybCIsInRpbWVvdXRfbXMiLCJjYWxsZXIiLCJjYWxsZXJPcHRpb25zIiwiYmF0Y2hJbmdlc3RDYWxsZXIiLCJvbkZhaWxlZFJlc3BvbnNlSG9vayIsImhpZGVJbnB1dHMiLCJhbm9ueW1pemVyIiwiaGlkZU91dHB1dHMiLCJhdXRvQmF0Y2hUcmFjaW5nIiwiYmxvY2tPblJvb3RSdW5GaW5hbGl6YXRpb24iLCJiYXRjaFNpemVCeXRlc0xpbWl0IiwiZmV0Y2hPcHRpb25zIiwiZ2V0SG9zdFVybCIsImluY2x1ZGVzIiwicHJvY2Vzc0lucHV0cyIsImlucHV0cyIsInByb2Nlc3NPdXRwdXRzIiwib3V0cHV0cyIsInByZXBhcmVSdW5DcmVhdGVPclVwZGF0ZUlucHV0cyIsInJ1blBhcmFtcyIsIl9nZXRSZXNwb25zZSIsInBhdGgiLCJxdWVyeVBhcmFtcyIsInBhcmFtc1N0cmluZyIsInRvU3RyaW5nIiwiY2FsbCIsIm1ldGhvZCIsInNpZ25hbCIsIkFib3J0U2lnbmFsIiwidGltZW91dCIsIl9nZXQiLCJqc29uIiwiX2dldFBhZ2luYXRlZCIsIlVSTFNlYXJjaFBhcmFtcyIsInRyYW5zZm9ybSIsIm9mZnNldCIsIk51bWJlciIsImxpbWl0Iiwic2V0IiwiU3RyaW5nIiwiX2dldEN1cnNvclBhZ2luYXRlZExpc3QiLCJib2R5IiwicmVxdWVzdE1ldGhvZCIsImRhdGFLZXkiLCJib2R5UGFyYW1zIiwiSlNPTiIsInJlc3BvbnNlQm9keSIsImN1cnNvcnMiLCJuZXh0IiwiY3Vyc29yIiwiX2ZpbHRlckZvclNhbXBsaW5nIiwicnVucyIsInBhdGNoIiwic2FtcGxlZCIsImZpbHRlcmVkUG9zdFV1aWRzIiwiaGFzIiwiaWQiLCJkZWxldGUiLCJ0cmFjZV9pZCIsIk1hdGgiLCJyYW5kb20iLCJhZGQiLCJfZ2V0QmF0Y2hTaXplTGltaXRCeXRlcyIsInNlcnZlckluZm8iLCJfZW5zdXJlU2VydmVySW5mbyIsImJhdGNoX2luZ2VzdF9jb25maWciLCJzaXplX2xpbWl0X2J5dGVzIiwiZHJhaW5BdXRvQmF0Y2hRdWV1ZSIsImF1dG9CYXRjaFF1ZXVlIiwiYmF0Y2giLCJkb25lIiwiaW5nZXN0UGFyYW1zIiwicnVuQ3JlYXRlcyIsImZpbHRlciIsInJ1blVwZGF0ZXMiLCJ1c2VfbXVsdGlwYXJ0X2VuZHBvaW50IiwibXVsdGlwYXJ0SW5nZXN0UnVucyIsImJhdGNoSW5nZXN0UnVucyIsInByb2Nlc3NSdW5PcGVyYXRpb24iLCJpbW1lZGlhdGVseVRyaWdnZXJCYXRjaCIsIm9sZFRpbWVvdXQiLCJhdXRvQmF0Y2hUaW1lb3V0IiwiY2xlYXJUaW1lb3V0Iiwic2l6ZUxpbWl0Qnl0ZXMiLCJjYXRjaCIsImNvbnNvbGUiLCJlcnJvciIsImF1dG9CYXRjaEFnZ3JlZ2F0aW9uRGVsYXlNcyIsImF1dG9CYXRjaEluaXRpYWxEZWxheU1zIiwiX2dldFNlcnZlckluZm8iLCJBY2NlcHQiLCJfZ2V0U2VydmVySW5mb1Byb21pc2UiLCJfc2VydmVySW5mbyIsImUiLCJ3YXJuIiwidGhlbiIsIl9nZXRTZXR0aW5ncyIsInNldHRpbmdzIiwiY3JlYXRlUnVuIiwic2Vzc2lvbl9uYW1lIiwicHJvamVjdF9uYW1lIiwicnVuQ3JlYXRlIiwic3RhcnRfdGltZSIsIkRhdGUiLCJub3ciLCJkb3R0ZWRfb3JkZXIiLCJtZXJnZWRSdW5DcmVhdGVQYXJhbSIsInByZXBhcmVkQ3JlYXRlUGFyYW1zIiwiY3JlYXRlIiwicHJlcGFyZWRVcGRhdGVQYXJhbXMiLCJ1cGRhdGUiLCJjcmVhdGVCeUlkIiwicmVkdWNlIiwicGFyYW1zIiwic3RhbmRhbG9uZVVwZGF0ZXMiLCJ1cGRhdGVQYXJhbSIsInZhbHVlcyIsInJhd0JhdGNoIiwicG9zdCIsInZlcnNpb24iLCJwcmVwYXJlZENyZWF0ZVBhcmFtIiwicHJlcGFyZWRVcGRhdGVQYXJhbSIsInVwZGF0ZVJ1biIsImJhdGNoQ2h1bmtzIiwiayIsImtleSIsImJhdGNoSXRlbXMiLCJyZXZlcnNlIiwiYmF0Y2hJdGVtIiwiX3Bvc3RCYXRjaEluZ2VzdFJ1bnMiLCJhbGxBdHRhY2htZW50cyIsInByZXBhcmVkQ3JlYXRlIiwiYXR0YWNobWVudHMiLCJpbnZhbGlkUnVuQ3JlYXRlIiwiZmluZCIsImludmFsaWRSdW5VcGRhdGUiLCJydW5VcGRhdGUiLCJhY2N1bXVsYXRlZENvbnRleHQiLCJhY2N1bXVsYXRlZFBhcnRzIiwicGF5bG9hZHMiLCJvcmlnaW5hbFBheWxvYWQiLCJldmVudHMiLCJmaWVsZHMiLCJzdHJpbmdpZmllZFBheWxvYWQiLCJuYW1lIiwiQmxvYiIsInR5cGUiLCJlbnRyaWVzIiwic3RyaW5naWZpZWRWYWx1ZSIsImNvbnRlbnRUeXBlIiwiY29udGVudCIsIl9zZW5kTXVsdGlwYXJ0UmVxdWVzdCIsImpvaW4iLCJwYXJ0cyIsImNvbnRleHQiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwicGFydCIsImFwcGVuZCIsImVycm9yTWVzc2FnZSIsInN0YWNrIiwibWVzc2FnZSIsInJ1bklkIiwiZGF0YSIsImVuZF90aW1lIiwicGFyZW50X3J1bl9pZCIsInJlYWRSdW4iLCJsb2FkQ2hpbGRSdW5zIiwiY2hpbGRfcnVuX2lkcyIsIl9sb2FkQ2hpbGRSdW5zIiwiZ2V0UnVuVXJsIiwicHJvamVjdE9wdHMiLCJzZXNzaW9uSWQiLCJzZXNzaW9uX2lkIiwicHJvamVjdE5hbWUiLCJyZWFkUHJvamVjdCIsInByb2plY3RJZCIsInByb2plY3QiLCJ0ZW5hbnRJZCIsIl9nZXRUZW5hbnRJZCIsInJ1bl8iLCJhcHBfcGF0aCIsImJhc2VVcmwiLCJjaGlsZFJ1bnMiLCJsaXN0UnVucyIsInRyZWVtYXAiLCJzb3J0IiwiYSIsImIiLCJsb2NhbGVDb21wYXJlIiwiY2hpbGRSdW4iLCJjaGlsZF9ydW5zIiwicHJvcHMiLCJwYXJlbnRSdW5JZCIsInRyYWNlSWQiLCJyZWZlcmVuY2VFeGFtcGxlSWQiLCJzdGFydFRpbWUiLCJleGVjdXRpb25PcmRlciIsImlzUm9vdCIsInJ1blR5cGUiLCJxdWVyeSIsInRyYWNlRmlsdGVyIiwidHJlZUZpbHRlciIsInNlbGVjdCIsInByb2plY3RJZHMiLCJBcnJheSIsImlzQXJyYXkiLCJwcm9qZWN0TmFtZXMiLCJwcm9qZWN0SWRzXyIsImFsbCIsImRlZmF1bHRfc2VsZWN0Iiwic2Vzc2lvbiIsInJ1bl90eXBlIiwicmVmZXJlbmNlX2V4YW1wbGUiLCJ0cmFjZV9maWx0ZXIiLCJ0cmVlX2ZpbHRlciIsImV4ZWN1dGlvbl9vcmRlciIsInBhcmVudF9ydW4iLCJ0b0lTT1N0cmluZyIsInRyYWNlIiwiaXNfcm9vdCIsInJ1bnNZaWVsZGVkIiwibmV3UnVucyIsImdldFJ1blN0YXRzIiwicGFyZW50UnVuIiwicmVmZXJlbmNlRXhhbXBsZUlkcyIsImVuZFRpbWUiLCJkYXRhU291cmNlVHlwZSIsImRhdGFfc291cmNlX3R5cGUiLCJmaWx0ZXJlZFBheWxvYWQiLCJmcm9tRW50cmllcyIsIl8iLCJzaGFyZVJ1biIsInNoYXJlSWQiLCJydW5faWQiLCJzaGFyZV90b2tlbiIsInY0IiwidW5zaGFyZVJ1biIsInJlYWRSdW5TaGFyZWRMaW5rIiwibGlzdFNoYXJlZFJ1bnMiLCJzaGFyZVRva2VuIiwicnVuSWRzIiwicmVhZERhdGFzZXRTaGFyZWRTY2hlbWEiLCJkYXRhc2V0SWQiLCJkYXRhc2V0TmFtZSIsImRhdGFzZXQiLCJyZWFkRGF0YXNldCIsInNoYXJlU2NoZW1hIiwic2hhcmVEYXRhc2V0IiwiZGF0YXNldF9pZCIsInVuc2hhcmVEYXRhc2V0IiwicmVhZFNoYXJlZERhdGFzZXQiLCJsaXN0U2hhcmVkRXhhbXBsZXMiLCJvcHRpb25zIiwiZXhhbXBsZUlkcyIsInVybFBhcmFtcyIsInYiLCJvayIsImRldGFpbCIsInN0YXR1c1RleHQiLCJleGFtcGxlIiwiX2hvc3RVcmwiLCJjcmVhdGVQcm9qZWN0IiwiZGVzY3JpcHRpb24iLCJ1cHNlcnQiLCJwcm9qZWN0RXh0cmEiLCJyZWZlcmVuY2VEYXRhc2V0SWQiLCJ1cHNlcnRfIiwiZW5kcG9pbnQiLCJ1cGRhdGVQcm9qZWN0IiwiaGFzUHJvamVjdCIsImluY2x1ZGVTdGF0cyIsImdldFByb2plY3RVcmwiLCJnZXREYXRhc2V0VXJsIiwiX3RlbmFudElkIiwicHJvamVjdHMiLCJ0ZW5hbnRfaWQiLCJsaXN0UHJvamVjdHMiLCJuYW1lQ29udGFpbnMiLCJyZWZlcmVuY2VEYXRhc2V0TmFtZSIsInJlZmVyZW5jZUZyZWUiLCJkZWxldGVQcm9qZWN0IiwicHJvamVjdElkXyIsInVwbG9hZENzdiIsImNzdkZpbGUiLCJmaWxlTmFtZSIsImlucHV0S2V5cyIsIm91dHB1dEtleXMiLCJkYXRhVHlwZSIsImNyZWF0ZURhdGFzZXQiLCJpbnB1dHNTY2hlbWEiLCJvdXRwdXRzU2NoZW1hIiwiZGF0YV90eXBlIiwiaW5wdXRzX3NjaGVtYV9kZWZpbml0aW9uIiwib3V0cHV0c19zY2hlbWFfZGVmaW5pdGlvbiIsImhhc0RhdGFzZXQiLCJ0b0xvY2FsZUxvd2VyQ2FzZSIsImRpZmZEYXRhc2V0VmVyc2lvbnMiLCJmcm9tVmVyc2lvbiIsInRvVmVyc2lvbiIsImRhdGFzZXRJZF8iLCJmcm9tX3ZlcnNpb24iLCJ0b192ZXJzaW9uIiwicmVhZERhdGFzZXRPcGVuYWlGaW5ldHVuaW5nIiwiZGF0YXNldFRleHQiLCJ0ZXh0IiwibGluZSIsInBhcnNlIiwibGlzdERhdGFzZXRzIiwiZGF0YXNldElkcyIsImRhdGFzZXROYW1lQ29udGFpbnMiLCJpZF8iLCJkYXRhc2V0cyIsInVwZGF0ZURhdGFzZXQiLCJfZGF0YXNldElkIiwiZGVsZXRlRGF0YXNldCIsImluZGV4RGF0YXNldCIsInRhZyIsInNpbWlsYXJFeGFtcGxlcyIsImNyZWF0ZUV4YW1wbGUiLCJjcmVhdGVkQXQiLCJleGFtcGxlSWQiLCJzb3VyY2VSdW5JZCIsImNyZWF0ZWRBdF8iLCJjcmVhdGVkX2F0Iiwic291cmNlX3J1bl9pZCIsImNyZWF0ZUV4YW1wbGVzIiwic291cmNlUnVuSWRzIiwiZm9ybWF0dGVkRXhhbXBsZXMiLCJpbnB1dCIsImlkeCIsInNwbGl0cyIsImNyZWF0ZUxMTUV4YW1wbGUiLCJnZW5lcmF0aW9uIiwib3V0cHV0IiwiY3JlYXRlQ2hhdEV4YW1wbGUiLCJnZW5lcmF0aW9ucyIsImZpbmFsSW5wdXQiLCJmaW5hbE91dHB1dCIsInJlYWRFeGFtcGxlIiwibGlzdEV4YW1wbGVzIiwiYXNPZiIsImlubGluZVMzVXJscyIsImRhdGFzZXRfdmVyc2lvbiIsImlubGluZVMzVXJsc18iLCJzZXJpYWxpemVkTWV0YWRhdGEiLCJpIiwiZXhhbXBsZXMiLCJkZWxldGVFeGFtcGxlIiwidXBkYXRlRXhhbXBsZSIsInVwZGF0ZUV4YW1wbGVzIiwibGlzdERhdGFzZXRTcGxpdHMiLCJ1cGRhdGVEYXRhc2V0U3BsaXRzIiwic3BsaXROYW1lIiwicmVtb3ZlIiwic3BsaXRfbmFtZSIsImV2YWx1YXRlUnVuIiwiZXZhbHVhdG9yIiwic291cmNlSW5mbyIsInJlZmVyZW5jZUV4YW1wbGUiLCJyZWZlcmVuY2VfZXhhbXBsZV9pZCIsImZlZWRiYWNrUmVzdWx0IiwiZmVlZGJhY2tzIiwiX2xvZ0V2YWx1YXRpb25GZWVkYmFjayIsImNyZWF0ZUZlZWRiYWNrIiwic2NvcmUiLCJjb3JyZWN0aW9uIiwiY29tbWVudCIsImZlZWRiYWNrU291cmNlVHlwZSIsImZlZWRiYWNrSWQiLCJmZWVkYmFja0NvbmZpZyIsImNvbXBhcmF0aXZlRXhwZXJpbWVudElkIiwiZmVlZGJhY2tfc291cmNlIiwiZmVlZGJhY2siLCJjb21wYXJhdGl2ZV9leHBlcmltZW50X2lkIiwidXBkYXRlRmVlZGJhY2siLCJmZWVkYmFja1VwZGF0ZSIsInJlYWRGZWVkYmFjayIsImRlbGV0ZUZlZWRiYWNrIiwibGlzdEZlZWRiYWNrIiwiZmVlZGJhY2tLZXlzIiwiZmVlZGJhY2tTb3VyY2VUeXBlcyIsImNyZWF0ZVByZXNpZ25lZEZlZWRiYWNrVG9rZW4iLCJmZWVkYmFja0tleSIsImV4cGlyYXRpb24iLCJmZWVkYmFja19rZXkiLCJmZWVkYmFja19jb25maWciLCJob3VycyIsIm1pbnV0ZXMiLCJkYXlzIiwiY3JlYXRlQ29tcGFyYXRpdmVFeHBlcmltZW50IiwiZXhwZXJpbWVudElkcyIsInJlZmVyZW5jZV9kYXRhc2V0X2lkIiwiZXhwZXJpbWVudF9pZHMiLCJsaXN0UHJlc2lnbmVkRmVlZGJhY2tUb2tlbnMiLCJ0b2tlbnMiLCJfc2VsZWN0RXZhbFJlc3VsdHMiLCJyZXN1bHRzIiwicmVzdWx0c18iLCJldmFsdWF0b3JSZXNwb25zZSIsImV2YWxSZXN1bHRzIiwicmVzIiwic291cmNlSW5mb18iLCJldmFsdWF0b3JJbmZvIiwicnVuSWRfIiwidGFyZ2V0UnVuSWQiLCJsb2dFdmFsdWF0aW9uRmVlZGJhY2siLCJsaXN0QW5ub3RhdGlvblF1ZXVlcyIsInF1ZXVlSWRzIiwibWluIiwiY291bnQiLCJxdWV1ZXMiLCJjcmVhdGVBbm5vdGF0aW9uUXVldWUiLCJxdWV1ZUlkIiwicmVhZEFubm90YXRpb25RdWV1ZSIsInF1ZXVlSXRlcmF0b3JSZXN1bHQiLCJ1cGRhdGVBbm5vdGF0aW9uUXVldWUiLCJkZWxldGVBbm5vdGF0aW9uUXVldWUiLCJhZGRSdW5zVG9Bbm5vdGF0aW9uUXVldWUiLCJnZXRSdW5Gcm9tQW5ub3RhdGlvblF1ZXVlIiwiaW5kZXgiLCJfY3VycmVudFRlbmFudElzT3duZXIiLCJvd25lciIsInRlbmFudF9oYW5kbGUiLCJfb3duZXJDb25mbGljdEVycm9yIiwiX2dldExhdGVzdENvbW1pdEhhc2giLCJwcm9tcHRPd25lckFuZE5hbWUiLCJzdGF0dXNDb2RlIiwiY29tbWl0cyIsImNvbW1pdF9oYXNoIiwiX2xpa2VPclVubGlrZVByb21wdCIsInByb21wdElkZW50aWZpZXIiLCJsaWtlIiwicHJvbXB0TmFtZSIsIl9nZXRQcm9tcHRVcmwiLCJjb21taXRIYXNoIiwic3Vic3RyaW5nIiwicHJvbXB0RXhpc3RzIiwicHJvbXB0IiwiZ2V0UHJvbXB0IiwibGlrZVByb21wdCIsInVubGlrZVByb21wdCIsImxpc3RDb21taXRzIiwibGlzdFByb21wdHMiLCJzb3J0RmllbGQiLCJpc0FyY2hpdmVkIiwiaXNQdWJsaWMiLCJwcm9tcHRzIiwicmVwb3MiLCJyZXBvIiwiY3JlYXRlUHJvbXB0IiwicmVwb19oYW5kbGUiLCJyZWFkbWUiLCJ0YWdzIiwiaXNfcHVibGljIiwiY3JlYXRlQ29tbWl0Iiwib2JqZWN0IiwicmVzb2x2ZWRQYXJlbnRDb21taXRIYXNoIiwicGFyZW50Q29tbWl0SGFzaCIsIm1hbmlmZXN0IiwicGFyZW50X2NvbW1pdCIsInVwZGF0ZVByb21wdCIsImlzX2FyY2hpdmVkIiwia2V5cyIsImRlbGV0ZVByb21wdCIsInB1bGxQcm9tcHRDb21taXQiLCJ1c2VPcHRpbWl6YXRpb24iLCJwYXNzZWRDb21taXRIYXNoIiwibGF0ZXN0Q29tbWl0SGFzaCIsImluY2x1ZGVNb2RlbCIsIl9wdWxsUHJvbXB0IiwicHJvbXB0T2JqZWN0IiwicHVzaFByb21wdCIsInNvbWUiLCJjbG9uZVB1YmxpY0RhdGFzZXQiLCJ0b2tlbk9yVXJsIiwic291cmNlQXBpVXJsIiwicGFyc2VkQXBpVXJsIiwidG9rZW5VdWlkIiwicGFyc2VUb2tlbk9yVXJsIiwic291cmNlQ2xpZW50IiwiZHMiLCJmaW5hbERhdGFzZXROYW1lIiwibG9nIiwiZmxhdE1hcCIsInVybE9yVG9rZW4iLCJudW1QYXJ0cyIsImtpbmQiLCJwYXJzZWRVcmwiLCJVUkwiLCJwYXRoUGFydHMiLCJwYXRobmFtZSIsImF3YWl0UGVuZGluZ1RyYWNlQmF0Y2hlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/env.js":
/*!********************************************!*\
  !*** ./node_modules/langsmith/dist/env.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isTracingEnabled: () => (/* binding */ isTracingEnabled)\n/* harmony export */ });\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/env.js */ \"(rsc)/./node_modules/langsmith/dist/utils/env.js\");\n\nconst isTracingEnabled = (tracingEnabled)=>{\n    if (tracingEnabled !== undefined) {\n        return tracingEnabled;\n    }\n    const envVars = [\n        \"TRACING_V2\",\n        \"TRACING\"\n    ];\n    return !!envVars.find((envVar)=>(0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getLangSmithEnvironmentVariable)(envVar) === \"true\");\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvZW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWlFO0FBQzFELE1BQU1DLG1CQUFtQixDQUFDQztJQUM3QixJQUFJQSxtQkFBbUJDLFdBQVc7UUFDOUIsT0FBT0Q7SUFDWDtJQUNBLE1BQU1FLFVBQVU7UUFBQztRQUFjO0tBQVU7SUFDekMsT0FBTyxDQUFDLENBQUNBLFFBQVFDLElBQUksQ0FBQyxDQUFDQyxTQUFXTiw4RUFBK0JBLENBQUNNLFlBQVk7QUFDbEYsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL2hhcmR3YXJlLWRvYy1jaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L2Vudi5qcz9lNTk5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUgfSBmcm9tIFwiLi91dGlscy9lbnYuanNcIjtcbmV4cG9ydCBjb25zdCBpc1RyYWNpbmdFbmFibGVkID0gKHRyYWNpbmdFbmFibGVkKSA9PiB7XG4gICAgaWYgKHRyYWNpbmdFbmFibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRyYWNpbmdFbmFibGVkO1xuICAgIH1cbiAgICBjb25zdCBlbnZWYXJzID0gW1wiVFJBQ0lOR19WMlwiLCBcIlRSQUNJTkdcIl07XG4gICAgcmV0dXJuICEhZW52VmFycy5maW5kKChlbnZWYXIpID0+IGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUoZW52VmFyKSA9PT0gXCJ0cnVlXCIpO1xufTtcbiJdLCJuYW1lcyI6WyJnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlIiwiaXNUcmFjaW5nRW5hYmxlZCIsInRyYWNpbmdFbmFibGVkIiwidW5kZWZpbmVkIiwiZW52VmFycyIsImZpbmQiLCJlbnZWYXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/env.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/langsmith/dist/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_0__.Client),\n/* harmony export */   RunTree: () => (/* reexport safe */ _run_trees_js__WEBPACK_IMPORTED_MODULE_1__.RunTree),\n/* harmony export */   __version__: () => (/* binding */ __version__),\n/* harmony export */   overrideFetchImplementation: () => (/* reexport safe */ _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_2__.overrideFetchImplementation)\n/* harmony export */ });\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client.js */ \"(rsc)/./node_modules/langsmith/dist/client.js\");\n/* harmony import */ var _run_trees_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./run_trees.js */ \"(rsc)/./node_modules/langsmith/dist/run_trees.js\");\n/* harmony import */ var _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./singletons/fetch.js */ \"(rsc)/./node_modules/langsmith/dist/singletons/fetch.js\");\n\n\n\n// Update using yarn bump-version\nconst __version__ = \"0.1.68\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFxQztBQUNJO0FBQzJCO0FBQ3BFLGlDQUFpQztBQUMxQixNQUFNRyxjQUFjLFNBQVMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYXJkd2FyZS1kb2MtY2hhdGJvdC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9pbmRleC5qcz9hYTI4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IENsaWVudCB9IGZyb20gXCIuL2NsaWVudC5qc1wiO1xuZXhwb3J0IHsgUnVuVHJlZSB9IGZyb20gXCIuL3J1bl90cmVlcy5qc1wiO1xuZXhwb3J0IHsgb3ZlcnJpZGVGZXRjaEltcGxlbWVudGF0aW9uIH0gZnJvbSBcIi4vc2luZ2xldG9ucy9mZXRjaC5qc1wiO1xuLy8gVXBkYXRlIHVzaW5nIHlhcm4gYnVtcC12ZXJzaW9uXG5leHBvcnQgY29uc3QgX192ZXJzaW9uX18gPSBcIjAuMS42OFwiO1xuIl0sIm5hbWVzIjpbIkNsaWVudCIsIlJ1blRyZWUiLCJvdmVycmlkZUZldGNoSW1wbGVtZW50YXRpb24iLCJfX3ZlcnNpb25fXyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/run_trees.js":
/*!**************************************************!*\
  !*** ./node_modules/langsmith/dist/run_trees.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RunTree: () => (/* binding */ RunTree),\n/* harmony export */   convertToDottedOrderFormat: () => (/* binding */ convertToDottedOrderFormat),\n/* harmony export */   isRunTree: () => (/* binding */ isRunTree),\n/* harmony export */   isRunnableConfigLike: () => (/* binding */ isRunnableConfigLike)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/env.js */ \"(rsc)/./node_modules/langsmith/dist/utils/env.js\");\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./client.js */ \"(rsc)/./node_modules/langsmith/dist/client.js\");\n/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./env.js */ \"(rsc)/./node_modules/langsmith/dist/env.js\");\n/* harmony import */ var _utils_warn_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/warn.js */ \"(rsc)/./node_modules/langsmith/dist/utils/warn.js\");\n/* harmony import */ var _singletons_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./singletons/constants.js */ \"(rsc)/./node_modules/langsmith/dist/singletons/constants.js\");\n\n\n\n\n\n\nfunction stripNonAlphanumeric(input) {\n    return input.replace(/[-:.]/g, \"\");\n}\nfunction convertToDottedOrderFormat(epoch, runId, executionOrder = 1) {\n    // Date only has millisecond precision, so we use the microseconds to break\n    // possible ties, avoiding incorrect run order\n    const paddedOrder = executionOrder.toFixed(0).slice(0, 3).padStart(3, \"0\");\n    return stripNonAlphanumeric(`${new Date(epoch).toISOString().slice(0, -1)}${paddedOrder}Z`) + runId;\n}\n/**\n * Baggage header information\n */ class Baggage {\n    constructor(metadata, tags){\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.metadata = metadata;\n        this.tags = tags;\n    }\n    static fromHeader(value) {\n        const items = value.split(\",\");\n        let metadata = {};\n        let tags = [];\n        for (const item of items){\n            const [key, uriValue] = item.split(\"=\");\n            const value = decodeURIComponent(uriValue);\n            if (key === \"langsmith-metadata\") {\n                metadata = JSON.parse(value);\n            } else if (key === \"langsmith-tags\") {\n                tags = value.split(\",\");\n            }\n        }\n        return new Baggage(metadata, tags);\n    }\n    toHeader() {\n        const items = [];\n        if (this.metadata && Object.keys(this.metadata).length > 0) {\n            items.push(`langsmith-metadata=${encodeURIComponent(JSON.stringify(this.metadata))}`);\n        }\n        if (this.tags && this.tags.length > 0) {\n            items.push(`langsmith-tags=${encodeURIComponent(this.tags.join(\",\"))}`);\n        }\n        return items.join(\",\");\n    }\n}\nclass RunTree {\n    constructor(originalConfig){\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"run_type\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"project_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"parent_run\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"child_runs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"start_time\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"end_time\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"extra\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"error\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"serialized\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"reference_example_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"events\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"trace_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"dotted_order\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tracingEnabled\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"execution_order\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"child_execution_order\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // If you pass in a run tree directly, return a shallow clone\n        if (isRunTree(originalConfig)) {\n            Object.assign(this, {\n                ...originalConfig\n            });\n            return;\n        }\n        const defaultConfig = RunTree.getDefaultConfig();\n        const { metadata, ...config } = originalConfig;\n        const client = config.client ?? RunTree.getSharedClient();\n        const dedupedMetadata = {\n            ...metadata,\n            ...config?.extra?.metadata\n        };\n        config.extra = {\n            ...config.extra,\n            metadata: dedupedMetadata\n        };\n        Object.assign(this, {\n            ...defaultConfig,\n            ...config,\n            client\n        });\n        if (!this.trace_id) {\n            if (this.parent_run) {\n                this.trace_id = this.parent_run.trace_id ?? this.id;\n            } else {\n                this.trace_id = this.id;\n            }\n        }\n        this.execution_order ??= 1;\n        this.child_execution_order ??= 1;\n        if (!this.dotted_order) {\n            const currentDottedOrder = convertToDottedOrderFormat(this.start_time, this.id, this.execution_order);\n            if (this.parent_run) {\n                this.dotted_order = this.parent_run.dotted_order + \".\" + currentDottedOrder;\n            } else {\n                this.dotted_order = currentDottedOrder;\n            }\n        }\n    }\n    static getDefaultConfig() {\n        return {\n            id: uuid__WEBPACK_IMPORTED_MODULE_5__[\"default\"](),\n            run_type: \"chain\",\n            project_name: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(\"LANGCHAIN_PROJECT\") ?? (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(\"LANGCHAIN_SESSION\") ?? // TODO: Deprecate\n            \"default\",\n            child_runs: [],\n            api_url: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(\"LANGCHAIN_ENDPOINT\") ?? \"http://localhost:1984\",\n            api_key: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(\"LANGCHAIN_API_KEY\"),\n            caller_options: {},\n            start_time: Date.now(),\n            serialized: {},\n            inputs: {},\n            extra: {}\n        };\n    }\n    static getSharedClient() {\n        if (!RunTree.sharedClient) {\n            RunTree.sharedClient = new _client_js__WEBPACK_IMPORTED_MODULE_1__.Client();\n        }\n        return RunTree.sharedClient;\n    }\n    createChild(config) {\n        const child_execution_order = this.child_execution_order + 1;\n        const child = new RunTree({\n            ...config,\n            parent_run: this,\n            project_name: this.project_name,\n            client: this.client,\n            tracingEnabled: this.tracingEnabled,\n            execution_order: child_execution_order,\n            child_execution_order: child_execution_order\n        });\n        // Copy context vars over into the new run tree.\n        if (_singletons_constants_js__WEBPACK_IMPORTED_MODULE_4__._LC_CONTEXT_VARIABLES_KEY in this) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            child[_singletons_constants_js__WEBPACK_IMPORTED_MODULE_4__._LC_CONTEXT_VARIABLES_KEY] = this[_singletons_constants_js__WEBPACK_IMPORTED_MODULE_4__._LC_CONTEXT_VARIABLES_KEY];\n        }\n        const LC_CHILD = Symbol.for(\"lc:child_config\");\n        const presentConfig = config.extra?.[LC_CHILD] ?? this.extra[LC_CHILD];\n        // tracing for LangChain is defined by the _parentRunId and runMap of the tracer\n        if (isRunnableConfigLike(presentConfig)) {\n            const newConfig = {\n                ...presentConfig\n            };\n            const callbacks = isCallbackManagerLike(newConfig.callbacks) ? newConfig.callbacks.copy?.() : undefined;\n            if (callbacks) {\n                // update the parent run id\n                Object.assign(callbacks, {\n                    _parentRunId: child.id\n                });\n                // only populate if we're in a newer LC.JS version\n                callbacks.handlers?.find(isLangChainTracerLike)?.updateFromRunTree?.(child);\n                newConfig.callbacks = callbacks;\n            }\n            child.extra[LC_CHILD] = newConfig;\n        }\n        // propagate child_execution_order upwards\n        const visited = new Set();\n        let current = this;\n        while(current != null && !visited.has(current.id)){\n            visited.add(current.id);\n            current.child_execution_order = Math.max(current.child_execution_order, child_execution_order);\n            current = current.parent_run;\n        }\n        this.child_runs.push(child);\n        return child;\n    }\n    async end(outputs, error, endTime = Date.now(), metadata) {\n        this.outputs = this.outputs ?? outputs;\n        this.error = this.error ?? error;\n        this.end_time = this.end_time ?? endTime;\n        if (metadata && Object.keys(metadata).length > 0) {\n            this.extra = this.extra ? {\n                ...this.extra,\n                metadata: {\n                    ...this.extra.metadata,\n                    ...metadata\n                }\n            } : {\n                metadata\n            };\n        }\n    }\n    _convertToCreate(run, runtimeEnv, excludeChildRuns = true) {\n        const runExtra = run.extra ?? {};\n        if (!runExtra.runtime) {\n            runExtra.runtime = {};\n        }\n        if (runtimeEnv) {\n            for (const [k, v] of Object.entries(runtimeEnv)){\n                if (!runExtra.runtime[k]) {\n                    runExtra.runtime[k] = v;\n                }\n            }\n        }\n        let child_runs;\n        let parent_run_id;\n        if (!excludeChildRuns) {\n            child_runs = run.child_runs.map((child_run)=>this._convertToCreate(child_run, runtimeEnv, excludeChildRuns));\n            parent_run_id = undefined;\n        } else {\n            parent_run_id = run.parent_run?.id;\n            child_runs = [];\n        }\n        const persistedRun = {\n            id: run.id,\n            name: run.name,\n            start_time: run.start_time,\n            end_time: run.end_time,\n            run_type: run.run_type,\n            reference_example_id: run.reference_example_id,\n            extra: runExtra,\n            serialized: run.serialized,\n            error: run.error,\n            inputs: run.inputs,\n            outputs: run.outputs,\n            session_name: run.project_name,\n            child_runs: child_runs,\n            parent_run_id: parent_run_id,\n            trace_id: run.trace_id,\n            dotted_order: run.dotted_order,\n            tags: run.tags\n        };\n        return persistedRun;\n    }\n    async postRun(excludeChildRuns = true) {\n        try {\n            const runtimeEnv = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getRuntimeEnvironment)();\n            const runCreate = await this._convertToCreate(this, runtimeEnv, true);\n            await this.client.createRun(runCreate);\n            if (!excludeChildRuns) {\n                (0,_utils_warn_js__WEBPACK_IMPORTED_MODULE_3__.warnOnce)(\"Posting with excludeChildRuns=false is deprecated and will be removed in a future version.\");\n                for (const childRun of this.child_runs){\n                    await childRun.postRun(false);\n                }\n            }\n        } catch (error) {\n            console.error(`Error in postRun for run ${this.id}:`, error);\n        }\n    }\n    async patchRun() {\n        try {\n            const runUpdate = {\n                end_time: this.end_time,\n                error: this.error,\n                inputs: this.inputs,\n                outputs: this.outputs,\n                parent_run_id: this.parent_run?.id,\n                reference_example_id: this.reference_example_id,\n                extra: this.extra,\n                events: this.events,\n                dotted_order: this.dotted_order,\n                trace_id: this.trace_id,\n                tags: this.tags\n            };\n            await this.client.updateRun(this.id, runUpdate);\n        } catch (error) {\n            console.error(`Error in patchRun for run ${this.id}`, error);\n        }\n    }\n    toJSON() {\n        return this._convertToCreate(this, undefined, false);\n    }\n    static fromRunnableConfig(parentConfig, props) {\n        // We only handle the callback manager case for now\n        const callbackManager = parentConfig?.callbacks;\n        let parentRun;\n        let projectName;\n        let client;\n        let tracingEnabled = (0,_env_js__WEBPACK_IMPORTED_MODULE_2__.isTracingEnabled)();\n        if (callbackManager) {\n            const parentRunId = callbackManager?.getParentRunId?.() ?? \"\";\n            const langChainTracer = callbackManager?.handlers?.find((handler)=>handler?.name == \"langchain_tracer\");\n            parentRun = langChainTracer?.getRun?.(parentRunId);\n            projectName = langChainTracer?.projectName;\n            client = langChainTracer?.client;\n            tracingEnabled = tracingEnabled || !!langChainTracer;\n        }\n        if (!parentRun) {\n            return new RunTree({\n                ...props,\n                client,\n                tracingEnabled,\n                project_name: projectName\n            });\n        }\n        const parentRunTree = new RunTree({\n            name: parentRun.name,\n            id: parentRun.id,\n            trace_id: parentRun.trace_id,\n            dotted_order: parentRun.dotted_order,\n            client,\n            tracingEnabled,\n            project_name: projectName,\n            tags: [\n                ...new Set((parentRun?.tags ?? []).concat(parentConfig?.tags ?? []))\n            ],\n            extra: {\n                metadata: {\n                    ...parentRun?.extra?.metadata,\n                    ...parentConfig?.metadata\n                }\n            }\n        });\n        return parentRunTree.createChild(props);\n    }\n    static fromDottedOrder(dottedOrder) {\n        return this.fromHeaders({\n            \"langsmith-trace\": dottedOrder\n        });\n    }\n    static fromHeaders(headers, inheritArgs) {\n        const rawHeaders = \"get\" in headers && typeof headers.get === \"function\" ? {\n            \"langsmith-trace\": headers.get(\"langsmith-trace\"),\n            baggage: headers.get(\"baggage\")\n        } : headers;\n        const headerTrace = rawHeaders[\"langsmith-trace\"];\n        if (!headerTrace || typeof headerTrace !== \"string\") return undefined;\n        const parentDottedOrder = headerTrace.trim();\n        const parsedDottedOrder = parentDottedOrder.split(\".\").map((part)=>{\n            const [strTime, uuid] = part.split(\"Z\");\n            return {\n                strTime,\n                time: Date.parse(strTime + \"Z\"),\n                uuid\n            };\n        });\n        const traceId = parsedDottedOrder[0].uuid;\n        const config = {\n            ...inheritArgs,\n            name: inheritArgs?.[\"name\"] ?? \"parent\",\n            run_type: inheritArgs?.[\"run_type\"] ?? \"chain\",\n            start_time: inheritArgs?.[\"start_time\"] ?? Date.now(),\n            id: parsedDottedOrder.at(-1)?.uuid,\n            trace_id: traceId,\n            dotted_order: parentDottedOrder\n        };\n        if (rawHeaders[\"baggage\"] && typeof rawHeaders[\"baggage\"] === \"string\") {\n            const baggage = Baggage.fromHeader(rawHeaders[\"baggage\"]);\n            config.metadata = baggage.metadata;\n            config.tags = baggage.tags;\n        }\n        return new RunTree(config);\n    }\n    toHeaders(headers) {\n        const result = {\n            \"langsmith-trace\": this.dotted_order,\n            baggage: new Baggage(this.extra?.metadata, this.tags).toHeader()\n        };\n        if (headers) {\n            for (const [key, value] of Object.entries(result)){\n                headers.set(key, value);\n            }\n        }\n        return result;\n    }\n}\nObject.defineProperty(RunTree, \"sharedClient\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: null\n});\nfunction isRunTree(x) {\n    return x !== undefined && typeof x.createChild === \"function\" && typeof x.postRun === \"function\";\n}\nfunction isLangChainTracerLike(x) {\n    return typeof x === \"object\" && x != null && typeof x.name === \"string\" && x.name === \"langchain_tracer\";\n}\nfunction containsLangChainTracerLike(x) {\n    return Array.isArray(x) && x.some((callback)=>isLangChainTracerLike(callback));\n}\nfunction isCallbackManagerLike(x) {\n    return typeof x === \"object\" && x != null && Array.isArray(x.handlers);\n}\nfunction isRunnableConfigLike(x) {\n    // Check that it's an object with a callbacks arg\n    // that has either a CallbackManagerLike object with a langchain tracer within it\n    // or an array with a LangChainTracerLike object within it\n    return x !== undefined && typeof x.callbacks === \"object\" && // Callback manager with a langchain tracer\n    (containsLangChainTracerLike(x.callbacks?.handlers) || // Or it's an array with a LangChainTracerLike object within it\n    containsLangChainTracerLike(x.callbacks));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvcnVuX3RyZWVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBNkI7QUFDbUQ7QUFDM0M7QUFDTztBQUNEO0FBQzJCO0FBQ3RFLFNBQVNPLHFCQUFxQkMsS0FBSztJQUMvQixPQUFPQSxNQUFNQyxPQUFPLENBQUMsVUFBVTtBQUNuQztBQUNPLFNBQVNDLDJCQUEyQkMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLGlCQUFpQixDQUFDO0lBQ3ZFLDJFQUEyRTtJQUMzRSw4Q0FBOEM7SUFDOUMsTUFBTUMsY0FBY0QsZUFBZUUsT0FBTyxDQUFDLEdBQUdDLEtBQUssQ0FBQyxHQUFHLEdBQUdDLFFBQVEsQ0FBQyxHQUFHO0lBQ3RFLE9BQVFWLHFCQUFxQixDQUFDLEVBQUUsSUFBSVcsS0FBS1AsT0FBT1EsV0FBVyxHQUFHSCxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRUYsWUFBWSxDQUFDLENBQUMsSUFBSUY7QUFDbkc7QUFDQTs7Q0FFQyxHQUNELE1BQU1RO0lBQ0ZDLFlBQVlDLFFBQVEsRUFBRUMsSUFBSSxDQUFFO1FBQ3hCQyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFlBQVk7WUFDcENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVE7WUFDaENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBLElBQUksQ0FBQ1AsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNDLElBQUksR0FBR0E7SUFDaEI7SUFDQSxPQUFPTyxXQUFXRCxLQUFLLEVBQUU7UUFDckIsTUFBTUUsUUFBUUYsTUFBTUcsS0FBSyxDQUFDO1FBQzFCLElBQUlWLFdBQVcsQ0FBQztRQUNoQixJQUFJQyxPQUFPLEVBQUU7UUFDYixLQUFLLE1BQU1VLFFBQVFGLE1BQU87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QUFBLDRCQUE0QkQsRUFBRWhGLFNBQVMsRUFBRUssYUFDdEMsK0RBQStEO0lBQy9ENEUsNEJBQTRCRCxFQUFFaEYsU0FBUztBQUNuRCIsInNvdXJjZXMiOlsid2VicGFjazovL2hhcmR3YXJlLWRvYy1jaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3J1bl90cmVlcy5qcz81MTJkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHV1aWQgZnJvbSBcInV1aWRcIjtcbmltcG9ydCB7IGdldEVudmlyb25tZW50VmFyaWFibGUsIGdldFJ1bnRpbWVFbnZpcm9ubWVudCwgfSBmcm9tIFwiLi91dGlscy9lbnYuanNcIjtcbmltcG9ydCB7IENsaWVudCB9IGZyb20gXCIuL2NsaWVudC5qc1wiO1xuaW1wb3J0IHsgaXNUcmFjaW5nRW5hYmxlZCB9IGZyb20gXCIuL2Vudi5qc1wiO1xuaW1wb3J0IHsgd2Fybk9uY2UgfSBmcm9tIFwiLi91dGlscy93YXJuLmpzXCI7XG5pbXBvcnQgeyBfTENfQ09OVEVYVF9WQVJJQUJMRVNfS0VZIH0gZnJvbSBcIi4vc2luZ2xldG9ucy9jb25zdGFudHMuanNcIjtcbmZ1bmN0aW9uIHN0cmlwTm9uQWxwaGFudW1lcmljKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1stOi5dL2csIFwiXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb0RvdHRlZE9yZGVyRm9ybWF0KGVwb2NoLCBydW5JZCwgZXhlY3V0aW9uT3JkZXIgPSAxKSB7XG4gICAgLy8gRGF0ZSBvbmx5IGhhcyBtaWxsaXNlY29uZCBwcmVjaXNpb24sIHNvIHdlIHVzZSB0aGUgbWljcm9zZWNvbmRzIHRvIGJyZWFrXG4gICAgLy8gcG9zc2libGUgdGllcywgYXZvaWRpbmcgaW5jb3JyZWN0IHJ1biBvcmRlclxuICAgIGNvbnN0IHBhZGRlZE9yZGVyID0gZXhlY3V0aW9uT3JkZXIudG9GaXhlZCgwKS5zbGljZSgwLCAzKS5wYWRTdGFydCgzLCBcIjBcIik7XG4gICAgcmV0dXJuIChzdHJpcE5vbkFscGhhbnVtZXJpYyhgJHtuZXcgRGF0ZShlcG9jaCkudG9JU09TdHJpbmcoKS5zbGljZSgwLCAtMSl9JHtwYWRkZWRPcmRlcn1aYCkgKyBydW5JZCk7XG59XG4vKipcbiAqIEJhZ2dhZ2UgaGVhZGVyIGluZm9ybWF0aW9uXG4gKi9cbmNsYXNzIEJhZ2dhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKG1ldGFkYXRhLCB0YWdzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1ldGFkYXRhXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB0aGlzLnRhZ3MgPSB0YWdzO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUhlYWRlcih2YWx1ZSkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IHZhbHVlLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgbGV0IG1ldGFkYXRhID0ge307XG4gICAgICAgIGxldCB0YWdzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgY29uc3QgW2tleSwgdXJpVmFsdWVdID0gaXRlbS5zcGxpdChcIj1cIik7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudCh1cmlWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcImxhbmdzbWl0aC1tZXRhZGF0YVwiKSB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEgPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJsYW5nc21pdGgtdGFnc1wiKSB7XG4gICAgICAgICAgICAgICAgdGFncyA9IHZhbHVlLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJhZ2dhZ2UobWV0YWRhdGEsIHRhZ3MpO1xuICAgIH1cbiAgICB0b0hlYWRlcigpIHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMubWV0YWRhdGEgJiYgT2JqZWN0LmtleXModGhpcy5tZXRhZGF0YSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaXRlbXMucHVzaChgbGFuZ3NtaXRoLW1ldGFkYXRhPSR7ZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHRoaXMubWV0YWRhdGEpKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50YWdzICYmIHRoaXMudGFncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKGBsYW5nc21pdGgtdGFncz0ke2VuY29kZVVSSUNvbXBvbmVudCh0aGlzLnRhZ3Muam9pbihcIixcIikpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtcy5qb2luKFwiLFwiKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUnVuVHJlZSB7XG4gICAgY29uc3RydWN0b3Iob3JpZ2luYWxDb25maWcpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJydW5fdHlwZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwcm9qZWN0X25hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicGFyZW50X3J1blwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaGlsZF9ydW5zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXJ0X3RpbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZW5kX3RpbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXh0cmFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJlcnJvclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXJpYWxpemVkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlucHV0c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvdXRwdXRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlZmVyZW5jZV9leGFtcGxlX2lkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNsaWVudFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJldmVudHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhY2VfaWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZG90dGVkX29yZGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYWNpbmdFbmFibGVkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV4ZWN1dGlvbl9vcmRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjaGlsZF9leGVjdXRpb25fb3JkZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gSWYgeW91IHBhc3MgaW4gYSBydW4gdHJlZSBkaXJlY3RseSwgcmV0dXJuIGEgc2hhbGxvdyBjbG9uZVxuICAgICAgICBpZiAoaXNSdW5UcmVlKG9yaWdpbmFsQ29uZmlnKSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7IC4uLm9yaWdpbmFsQ29uZmlnIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZmF1bHRDb25maWcgPSBSdW5UcmVlLmdldERlZmF1bHRDb25maWcoKTtcbiAgICAgICAgY29uc3QgeyBtZXRhZGF0YSwgLi4uY29uZmlnIH0gPSBvcmlnaW5hbENvbmZpZztcbiAgICAgICAgY29uc3QgY2xpZW50ID0gY29uZmlnLmNsaWVudCA/PyBSdW5UcmVlLmdldFNoYXJlZENsaWVudCgpO1xuICAgICAgICBjb25zdCBkZWR1cGVkTWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAuLi5tZXRhZGF0YSxcbiAgICAgICAgICAgIC4uLmNvbmZpZz8uZXh0cmE/Lm1ldGFkYXRhLFxuICAgICAgICB9O1xuICAgICAgICBjb25maWcuZXh0cmEgPSB7IC4uLmNvbmZpZy5leHRyYSwgbWV0YWRhdGE6IGRlZHVwZWRNZXRhZGF0YSB9O1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHsgLi4uZGVmYXVsdENvbmZpZywgLi4uY29uZmlnLCBjbGllbnQgfSk7XG4gICAgICAgIGlmICghdGhpcy50cmFjZV9pZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50X3J1bikge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2VfaWQgPSB0aGlzLnBhcmVudF9ydW4udHJhY2VfaWQgPz8gdGhpcy5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2VfaWQgPSB0aGlzLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXhlY3V0aW9uX29yZGVyID8/PSAxO1xuICAgICAgICB0aGlzLmNoaWxkX2V4ZWN1dGlvbl9vcmRlciA/Pz0gMTtcbiAgICAgICAgaWYgKCF0aGlzLmRvdHRlZF9vcmRlcikge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudERvdHRlZE9yZGVyID0gY29udmVydFRvRG90dGVkT3JkZXJGb3JtYXQodGhpcy5zdGFydF90aW1lLCB0aGlzLmlkLCB0aGlzLmV4ZWN1dGlvbl9vcmRlcik7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnRfcnVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb3R0ZWRfb3JkZXIgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudF9ydW4uZG90dGVkX29yZGVyICsgXCIuXCIgKyBjdXJyZW50RG90dGVkT3JkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvdHRlZF9vcmRlciA9IGN1cnJlbnREb3R0ZWRPcmRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZ2V0RGVmYXVsdENvbmZpZygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiB1dWlkLnY0KCksXG4gICAgICAgICAgICBydW5fdHlwZTogXCJjaGFpblwiLFxuICAgICAgICAgICAgcHJvamVjdF9uYW1lOiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX1BST0pFQ1RcIikgPz9cbiAgICAgICAgICAgICAgICBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR0NIQUlOX1NFU1NJT05cIikgPz8gLy8gVE9ETzogRGVwcmVjYXRlXG4gICAgICAgICAgICAgICAgXCJkZWZhdWx0XCIsXG4gICAgICAgICAgICBjaGlsZF9ydW5zOiBbXSxcbiAgICAgICAgICAgIGFwaV91cmw6IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fRU5EUE9JTlRcIikgPz8gXCJodHRwOi8vbG9jYWxob3N0OjE5ODRcIixcbiAgICAgICAgICAgIGFwaV9rZXk6IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fQVBJX0tFWVwiKSxcbiAgICAgICAgICAgIGNhbGxlcl9vcHRpb25zOiB7fSxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICBzZXJpYWxpemVkOiB7fSxcbiAgICAgICAgICAgIGlucHV0czoge30sXG4gICAgICAgICAgICBleHRyYToge30sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBnZXRTaGFyZWRDbGllbnQoKSB7XG4gICAgICAgIGlmICghUnVuVHJlZS5zaGFyZWRDbGllbnQpIHtcbiAgICAgICAgICAgIFJ1blRyZWUuc2hhcmVkQ2xpZW50ID0gbmV3IENsaWVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSdW5UcmVlLnNoYXJlZENsaWVudDtcbiAgICB9XG4gICAgY3JlYXRlQ2hpbGQoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkX2V4ZWN1dGlvbl9vcmRlciA9IHRoaXMuY2hpbGRfZXhlY3V0aW9uX29yZGVyICsgMTtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBuZXcgUnVuVHJlZSh7XG4gICAgICAgICAgICAuLi5jb25maWcsXG4gICAgICAgICAgICBwYXJlbnRfcnVuOiB0aGlzLFxuICAgICAgICAgICAgcHJvamVjdF9uYW1lOiB0aGlzLnByb2plY3RfbmFtZSxcbiAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICB0cmFjaW5nRW5hYmxlZDogdGhpcy50cmFjaW5nRW5hYmxlZCxcbiAgICAgICAgICAgIGV4ZWN1dGlvbl9vcmRlcjogY2hpbGRfZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICAgICAgY2hpbGRfZXhlY3V0aW9uX29yZGVyOiBjaGlsZF9leGVjdXRpb25fb3JkZXIsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDb3B5IGNvbnRleHQgdmFycyBvdmVyIGludG8gdGhlIG5ldyBydW4gdHJlZS5cbiAgICAgICAgaWYgKF9MQ19DT05URVhUX1ZBUklBQkxFU19LRVkgaW4gdGhpcykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGNoaWxkW19MQ19DT05URVhUX1ZBUklBQkxFU19LRVldID1cbiAgICAgICAgICAgICAgICB0aGlzW19MQ19DT05URVhUX1ZBUklBQkxFU19LRVldO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IExDX0NISUxEID0gU3ltYm9sLmZvcihcImxjOmNoaWxkX2NvbmZpZ1wiKTtcbiAgICAgICAgY29uc3QgcHJlc2VudENvbmZpZyA9IGNvbmZpZy5leHRyYT8uW0xDX0NISUxEXSA/P1xuICAgICAgICAgICAgdGhpcy5leHRyYVtMQ19DSElMRF07XG4gICAgICAgIC8vIHRyYWNpbmcgZm9yIExhbmdDaGFpbiBpcyBkZWZpbmVkIGJ5IHRoZSBfcGFyZW50UnVuSWQgYW5kIHJ1bk1hcCBvZiB0aGUgdHJhY2VyXG4gICAgICAgIGlmIChpc1J1bm5hYmxlQ29uZmlnTGlrZShwcmVzZW50Q29uZmlnKSkge1xuICAgICAgICAgICAgY29uc3QgbmV3Q29uZmlnID0geyAuLi5wcmVzZW50Q29uZmlnIH07XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBpc0NhbGxiYWNrTWFuYWdlckxpa2UobmV3Q29uZmlnLmNhbGxiYWNrcylcbiAgICAgICAgICAgICAgICA/IG5ld0NvbmZpZy5jYWxsYmFja3MuY29weT8uKClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHBhcmVudCBydW4gaWRcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGNhbGxiYWNrcywgeyBfcGFyZW50UnVuSWQ6IGNoaWxkLmlkIH0pO1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgcG9wdWxhdGUgaWYgd2UncmUgaW4gYSBuZXdlciBMQy5KUyB2ZXJzaW9uXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzLmhhbmRsZXJzXG4gICAgICAgICAgICAgICAgICAgID8uZmluZChpc0xhbmdDaGFpblRyYWNlckxpa2UpXG4gICAgICAgICAgICAgICAgICAgID8udXBkYXRlRnJvbVJ1blRyZWU/LihjaGlsZCk7XG4gICAgICAgICAgICAgICAgbmV3Q29uZmlnLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkLmV4dHJhW0xDX0NISUxEXSA9IG5ld0NvbmZpZztcbiAgICAgICAgfVxuICAgICAgICAvLyBwcm9wYWdhdGUgY2hpbGRfZXhlY3V0aW9uX29yZGVyIHVwd2FyZHNcbiAgICAgICAgY29uc3QgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzO1xuICAgICAgICB3aGlsZSAoY3VycmVudCAhPSBudWxsICYmICF2aXNpdGVkLmhhcyhjdXJyZW50LmlkKSkge1xuICAgICAgICAgICAgdmlzaXRlZC5hZGQoY3VycmVudC5pZCk7XG4gICAgICAgICAgICBjdXJyZW50LmNoaWxkX2V4ZWN1dGlvbl9vcmRlciA9IE1hdGgubWF4KGN1cnJlbnQuY2hpbGRfZXhlY3V0aW9uX29yZGVyLCBjaGlsZF9leGVjdXRpb25fb3JkZXIpO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50X3J1bjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoaWxkX3J1bnMucHVzaChjaGlsZCk7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9XG4gICAgYXN5bmMgZW5kKG91dHB1dHMsIGVycm9yLCBlbmRUaW1lID0gRGF0ZS5ub3coKSwgbWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gdGhpcy5vdXRwdXRzID8/IG91dHB1dHM7XG4gICAgICAgIHRoaXMuZXJyb3IgPSB0aGlzLmVycm9yID8/IGVycm9yO1xuICAgICAgICB0aGlzLmVuZF90aW1lID0gdGhpcy5lbmRfdGltZSA/PyBlbmRUaW1lO1xuICAgICAgICBpZiAobWV0YWRhdGEgJiYgT2JqZWN0LmtleXMobWV0YWRhdGEpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZXh0cmEgPSB0aGlzLmV4dHJhXG4gICAgICAgICAgICAgICAgPyB7IC4uLnRoaXMuZXh0cmEsIG1ldGFkYXRhOiB7IC4uLnRoaXMuZXh0cmEubWV0YWRhdGEsIC4uLm1ldGFkYXRhIH0gfVxuICAgICAgICAgICAgICAgIDogeyBtZXRhZGF0YSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jb252ZXJ0VG9DcmVhdGUocnVuLCBydW50aW1lRW52LCBleGNsdWRlQ2hpbGRSdW5zID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBydW5FeHRyYSA9IHJ1bi5leHRyYSA/PyB7fTtcbiAgICAgICAgaWYgKCFydW5FeHRyYS5ydW50aW1lKSB7XG4gICAgICAgICAgICBydW5FeHRyYS5ydW50aW1lID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bnRpbWVFbnYpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHJ1bnRpbWVFbnYpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFydW5FeHRyYS5ydW50aW1lW2tdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bkV4dHJhLnJ1bnRpbWVba10gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hpbGRfcnVucztcbiAgICAgICAgbGV0IHBhcmVudF9ydW5faWQ7XG4gICAgICAgIGlmICghZXhjbHVkZUNoaWxkUnVucykge1xuICAgICAgICAgICAgY2hpbGRfcnVucyA9IHJ1bi5jaGlsZF9ydW5zLm1hcCgoY2hpbGRfcnVuKSA9PiB0aGlzLl9jb252ZXJ0VG9DcmVhdGUoY2hpbGRfcnVuLCBydW50aW1lRW52LCBleGNsdWRlQ2hpbGRSdW5zKSk7XG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50X3J1bl9pZCA9IHJ1bi5wYXJlbnRfcnVuPy5pZDtcbiAgICAgICAgICAgIGNoaWxkX3J1bnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwZXJzaXN0ZWRSdW4gPSB7XG4gICAgICAgICAgICBpZDogcnVuLmlkLFxuICAgICAgICAgICAgbmFtZTogcnVuLm5hbWUsXG4gICAgICAgICAgICBzdGFydF90aW1lOiBydW4uc3RhcnRfdGltZSxcbiAgICAgICAgICAgIGVuZF90aW1lOiBydW4uZW5kX3RpbWUsXG4gICAgICAgICAgICBydW5fdHlwZTogcnVuLnJ1bl90eXBlLFxuICAgICAgICAgICAgcmVmZXJlbmNlX2V4YW1wbGVfaWQ6IHJ1bi5yZWZlcmVuY2VfZXhhbXBsZV9pZCxcbiAgICAgICAgICAgIGV4dHJhOiBydW5FeHRyYSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQ6IHJ1bi5zZXJpYWxpemVkLFxuICAgICAgICAgICAgZXJyb3I6IHJ1bi5lcnJvcixcbiAgICAgICAgICAgIGlucHV0czogcnVuLmlucHV0cyxcbiAgICAgICAgICAgIG91dHB1dHM6IHJ1bi5vdXRwdXRzLFxuICAgICAgICAgICAgc2Vzc2lvbl9uYW1lOiBydW4ucHJvamVjdF9uYW1lLFxuICAgICAgICAgICAgY2hpbGRfcnVuczogY2hpbGRfcnVucyxcbiAgICAgICAgICAgIHBhcmVudF9ydW5faWQ6IHBhcmVudF9ydW5faWQsXG4gICAgICAgICAgICB0cmFjZV9pZDogcnVuLnRyYWNlX2lkLFxuICAgICAgICAgICAgZG90dGVkX29yZGVyOiBydW4uZG90dGVkX29yZGVyLFxuICAgICAgICAgICAgdGFnczogcnVuLnRhZ3MsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwZXJzaXN0ZWRSdW47XG4gICAgfVxuICAgIGFzeW5jIHBvc3RSdW4oZXhjbHVkZUNoaWxkUnVucyA9IHRydWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bnRpbWVFbnYgPSBnZXRSdW50aW1lRW52aXJvbm1lbnQoKTtcbiAgICAgICAgICAgIGNvbnN0IHJ1bkNyZWF0ZSA9IGF3YWl0IHRoaXMuX2NvbnZlcnRUb0NyZWF0ZSh0aGlzLCBydW50aW1lRW52LCB0cnVlKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LmNyZWF0ZVJ1bihydW5DcmVhdGUpO1xuICAgICAgICAgICAgaWYgKCFleGNsdWRlQ2hpbGRSdW5zKSB7XG4gICAgICAgICAgICAgICAgd2Fybk9uY2UoXCJQb3N0aW5nIHdpdGggZXhjbHVkZUNoaWxkUnVucz1mYWxzZSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi5cIik7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZFJ1biBvZiB0aGlzLmNoaWxkX3J1bnMpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2hpbGRSdW4ucG9zdFJ1bihmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gcG9zdFJ1biBmb3IgcnVuICR7dGhpcy5pZH06YCwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHBhdGNoUnVuKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcnVuVXBkYXRlID0ge1xuICAgICAgICAgICAgICAgIGVuZF90aW1lOiB0aGlzLmVuZF90aW1lLFxuICAgICAgICAgICAgICAgIGVycm9yOiB0aGlzLmVycm9yLFxuICAgICAgICAgICAgICAgIGlucHV0czogdGhpcy5pbnB1dHMsXG4gICAgICAgICAgICAgICAgb3V0cHV0czogdGhpcy5vdXRwdXRzLFxuICAgICAgICAgICAgICAgIHBhcmVudF9ydW5faWQ6IHRoaXMucGFyZW50X3J1bj8uaWQsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlX2V4YW1wbGVfaWQ6IHRoaXMucmVmZXJlbmNlX2V4YW1wbGVfaWQsXG4gICAgICAgICAgICAgICAgZXh0cmE6IHRoaXMuZXh0cmEsXG4gICAgICAgICAgICAgICAgZXZlbnRzOiB0aGlzLmV2ZW50cyxcbiAgICAgICAgICAgICAgICBkb3R0ZWRfb3JkZXI6IHRoaXMuZG90dGVkX29yZGVyLFxuICAgICAgICAgICAgICAgIHRyYWNlX2lkOiB0aGlzLnRyYWNlX2lkLFxuICAgICAgICAgICAgICAgIHRhZ3M6IHRoaXMudGFncyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC51cGRhdGVSdW4odGhpcy5pZCwgcnVuVXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIHBhdGNoUnVuIGZvciBydW4gJHt0aGlzLmlkfWAsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJ0VG9DcmVhdGUodGhpcywgdW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUnVubmFibGVDb25maWcocGFyZW50Q29uZmlnLCBwcm9wcykge1xuICAgICAgICAvLyBXZSBvbmx5IGhhbmRsZSB0aGUgY2FsbGJhY2sgbWFuYWdlciBjYXNlIGZvciBub3dcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNYW5hZ2VyID0gcGFyZW50Q29uZmlnPy5jYWxsYmFja3M7XG4gICAgICAgIGxldCBwYXJlbnRSdW47XG4gICAgICAgIGxldCBwcm9qZWN0TmFtZTtcbiAgICAgICAgbGV0IGNsaWVudDtcbiAgICAgICAgbGV0IHRyYWNpbmdFbmFibGVkID0gaXNUcmFjaW5nRW5hYmxlZCgpO1xuICAgICAgICBpZiAoY2FsbGJhY2tNYW5hZ2VyKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRSdW5JZCA9IGNhbGxiYWNrTWFuYWdlcj8uZ2V0UGFyZW50UnVuSWQ/LigpID8/IFwiXCI7XG4gICAgICAgICAgICBjb25zdCBsYW5nQ2hhaW5UcmFjZXIgPSBjYWxsYmFja01hbmFnZXI/LmhhbmRsZXJzPy5maW5kKChoYW5kbGVyKSA9PiBoYW5kbGVyPy5uYW1lID09IFwibGFuZ2NoYWluX3RyYWNlclwiKTtcbiAgICAgICAgICAgIHBhcmVudFJ1biA9IGxhbmdDaGFpblRyYWNlcj8uZ2V0UnVuPy4ocGFyZW50UnVuSWQpO1xuICAgICAgICAgICAgcHJvamVjdE5hbWUgPSBsYW5nQ2hhaW5UcmFjZXI/LnByb2plY3ROYW1lO1xuICAgICAgICAgICAgY2xpZW50ID0gbGFuZ0NoYWluVHJhY2VyPy5jbGllbnQ7XG4gICAgICAgICAgICB0cmFjaW5nRW5hYmxlZCA9IHRyYWNpbmdFbmFibGVkIHx8ICEhbGFuZ0NoYWluVHJhY2VyO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50UnVuKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJ1blRyZWUoe1xuICAgICAgICAgICAgICAgIC4uLnByb3BzLFxuICAgICAgICAgICAgICAgIGNsaWVudCxcbiAgICAgICAgICAgICAgICB0cmFjaW5nRW5hYmxlZCxcbiAgICAgICAgICAgICAgICBwcm9qZWN0X25hbWU6IHByb2plY3ROYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50UnVuVHJlZSA9IG5ldyBSdW5UcmVlKHtcbiAgICAgICAgICAgIG5hbWU6IHBhcmVudFJ1bi5uYW1lLFxuICAgICAgICAgICAgaWQ6IHBhcmVudFJ1bi5pZCxcbiAgICAgICAgICAgIHRyYWNlX2lkOiBwYXJlbnRSdW4udHJhY2VfaWQsXG4gICAgICAgICAgICBkb3R0ZWRfb3JkZXI6IHBhcmVudFJ1bi5kb3R0ZWRfb3JkZXIsXG4gICAgICAgICAgICBjbGllbnQsXG4gICAgICAgICAgICB0cmFjaW5nRW5hYmxlZCxcbiAgICAgICAgICAgIHByb2plY3RfbmFtZTogcHJvamVjdE5hbWUsXG4gICAgICAgICAgICB0YWdzOiBbXG4gICAgICAgICAgICAgICAgLi4ubmV3IFNldCgocGFyZW50UnVuPy50YWdzID8/IFtdKS5jb25jYXQocGFyZW50Q29uZmlnPy50YWdzID8/IFtdKSksXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZXh0cmE6IHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAuLi5wYXJlbnRSdW4/LmV4dHJhPy5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgLi4ucGFyZW50Q29uZmlnPy5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXJlbnRSdW5UcmVlLmNyZWF0ZUNoaWxkKHByb3BzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Eb3R0ZWRPcmRlcihkb3R0ZWRPcmRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tSGVhZGVycyh7IFwibGFuZ3NtaXRoLXRyYWNlXCI6IGRvdHRlZE9yZGVyIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUhlYWRlcnMoaGVhZGVycywgaW5oZXJpdEFyZ3MpIHtcbiAgICAgICAgY29uc3QgcmF3SGVhZGVycyA9IFwiZ2V0XCIgaW4gaGVhZGVycyAmJiB0eXBlb2YgaGVhZGVycy5nZXQgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgXCJsYW5nc21pdGgtdHJhY2VcIjogaGVhZGVycy5nZXQoXCJsYW5nc21pdGgtdHJhY2VcIiksXG4gICAgICAgICAgICAgICAgYmFnZ2FnZTogaGVhZGVycy5nZXQoXCJiYWdnYWdlXCIpLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBoZWFkZXJzO1xuICAgICAgICBjb25zdCBoZWFkZXJUcmFjZSA9IHJhd0hlYWRlcnNbXCJsYW5nc21pdGgtdHJhY2VcIl07XG4gICAgICAgIGlmICghaGVhZGVyVHJhY2UgfHwgdHlwZW9mIGhlYWRlclRyYWNlICE9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgcGFyZW50RG90dGVkT3JkZXIgPSBoZWFkZXJUcmFjZS50cmltKCk7XG4gICAgICAgIGNvbnN0IHBhcnNlZERvdHRlZE9yZGVyID0gcGFyZW50RG90dGVkT3JkZXIuc3BsaXQoXCIuXCIpLm1hcCgocGFydCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW3N0clRpbWUsIHV1aWRdID0gcGFydC5zcGxpdChcIlpcIik7XG4gICAgICAgICAgICByZXR1cm4geyBzdHJUaW1lLCB0aW1lOiBEYXRlLnBhcnNlKHN0clRpbWUgKyBcIlpcIiksIHV1aWQgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRyYWNlSWQgPSBwYXJzZWREb3R0ZWRPcmRlclswXS51dWlkO1xuICAgICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgICAgICAuLi5pbmhlcml0QXJncyxcbiAgICAgICAgICAgIG5hbWU6IGluaGVyaXRBcmdzPy5bXCJuYW1lXCJdID8/IFwicGFyZW50XCIsXG4gICAgICAgICAgICBydW5fdHlwZTogaW5oZXJpdEFyZ3M/LltcInJ1bl90eXBlXCJdID8/IFwiY2hhaW5cIixcbiAgICAgICAgICAgIHN0YXJ0X3RpbWU6IGluaGVyaXRBcmdzPy5bXCJzdGFydF90aW1lXCJdID8/IERhdGUubm93KCksXG4gICAgICAgICAgICBpZDogcGFyc2VkRG90dGVkT3JkZXIuYXQoLTEpPy51dWlkLFxuICAgICAgICAgICAgdHJhY2VfaWQ6IHRyYWNlSWQsXG4gICAgICAgICAgICBkb3R0ZWRfb3JkZXI6IHBhcmVudERvdHRlZE9yZGVyLFxuICAgICAgICB9O1xuICAgICAgICBpZiAocmF3SGVhZGVyc1tcImJhZ2dhZ2VcIl0gJiYgdHlwZW9mIHJhd0hlYWRlcnNbXCJiYWdnYWdlXCJdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBiYWdnYWdlID0gQmFnZ2FnZS5mcm9tSGVhZGVyKHJhd0hlYWRlcnNbXCJiYWdnYWdlXCJdKTtcbiAgICAgICAgICAgIGNvbmZpZy5tZXRhZGF0YSA9IGJhZ2dhZ2UubWV0YWRhdGE7XG4gICAgICAgICAgICBjb25maWcudGFncyA9IGJhZ2dhZ2UudGFncztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJ1blRyZWUoY29uZmlnKTtcbiAgICB9XG4gICAgdG9IZWFkZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgXCJsYW5nc21pdGgtdHJhY2VcIjogdGhpcy5kb3R0ZWRfb3JkZXIsXG4gICAgICAgICAgICBiYWdnYWdlOiBuZXcgQmFnZ2FnZSh0aGlzLmV4dHJhPy5tZXRhZGF0YSwgdGhpcy50YWdzKS50b0hlYWRlcigpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaGVhZGVycykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1blRyZWUsIFwic2hhcmVkQ2xpZW50XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogbnVsbFxufSk7XG5leHBvcnQgZnVuY3Rpb24gaXNSdW5UcmVlKHgpIHtcbiAgICByZXR1cm4gKHggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0eXBlb2YgeC5jcmVhdGVDaGlsZCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIHR5cGVvZiB4LnBvc3RSdW4gPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBpc0xhbmdDaGFpblRyYWNlckxpa2UoeCkge1xuICAgIHJldHVybiAodHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgeCAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiB4Lm5hbWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgeC5uYW1lID09PSBcImxhbmdjaGFpbl90cmFjZXJcIik7XG59XG5mdW5jdGlvbiBjb250YWluc0xhbmdDaGFpblRyYWNlckxpa2UoeCkge1xuICAgIHJldHVybiAoQXJyYXkuaXNBcnJheSh4KSAmJiB4LnNvbWUoKGNhbGxiYWNrKSA9PiBpc0xhbmdDaGFpblRyYWNlckxpa2UoY2FsbGJhY2spKSk7XG59XG5mdW5jdGlvbiBpc0NhbGxiYWNrTWFuYWdlckxpa2UoeCkge1xuICAgIHJldHVybiAodHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgeCAhPSBudWxsICYmXG4gICAgICAgIEFycmF5LmlzQXJyYXkoeC5oYW5kbGVycykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzUnVubmFibGVDb25maWdMaWtlKHgpIHtcbiAgICAvLyBDaGVjayB0aGF0IGl0J3MgYW4gb2JqZWN0IHdpdGggYSBjYWxsYmFja3MgYXJnXG4gICAgLy8gdGhhdCBoYXMgZWl0aGVyIGEgQ2FsbGJhY2tNYW5hZ2VyTGlrZSBvYmplY3Qgd2l0aCBhIGxhbmdjaGFpbiB0cmFjZXIgd2l0aGluIGl0XG4gICAgLy8gb3IgYW4gYXJyYXkgd2l0aCBhIExhbmdDaGFpblRyYWNlckxpa2Ugb2JqZWN0IHdpdGhpbiBpdFxuICAgIHJldHVybiAoeCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHR5cGVvZiB4LmNhbGxiYWNrcyA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAvLyBDYWxsYmFjayBtYW5hZ2VyIHdpdGggYSBsYW5nY2hhaW4gdHJhY2VyXG4gICAgICAgIChjb250YWluc0xhbmdDaGFpblRyYWNlckxpa2UoeC5jYWxsYmFja3M/LmhhbmRsZXJzKSB8fFxuICAgICAgICAgICAgLy8gT3IgaXQncyBhbiBhcnJheSB3aXRoIGEgTGFuZ0NoYWluVHJhY2VyTGlrZSBvYmplY3Qgd2l0aGluIGl0XG4gICAgICAgICAgICBjb250YWluc0xhbmdDaGFpblRyYWNlckxpa2UoeC5jYWxsYmFja3MpKSk7XG59XG4iXSwibmFtZXMiOlsidXVpZCIsImdldEVudmlyb25tZW50VmFyaWFibGUiLCJnZXRSdW50aW1lRW52aXJvbm1lbnQiLCJDbGllbnQiLCJpc1RyYWNpbmdFbmFibGVkIiwid2Fybk9uY2UiLCJfTENfQ09OVEVYVF9WQVJJQUJMRVNfS0VZIiwic3RyaXBOb25BbHBoYW51bWVyaWMiLCJpbnB1dCIsInJlcGxhY2UiLCJjb252ZXJ0VG9Eb3R0ZWRPcmRlckZvcm1hdCIsImVwb2NoIiwicnVuSWQiLCJleGVjdXRpb25PcmRlciIsInBhZGRlZE9yZGVyIiwidG9GaXhlZCIsInNsaWNlIiwicGFkU3RhcnQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJCYWdnYWdlIiwiY29uc3RydWN0b3IiLCJtZXRhZGF0YSIsInRhZ3MiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInZhbHVlIiwiZnJvbUhlYWRlciIsIml0ZW1zIiwic3BsaXQiLCJpdGVtIiwia2V5IiwidXJpVmFsdWUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJKU09OIiwicGFyc2UiLCJ0b0hlYWRlciIsImtleXMiLCJsZW5ndGgiLCJwdXNoIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwic3RyaW5naWZ5Iiwiam9pbiIsIlJ1blRyZWUiLCJvcmlnaW5hbENvbmZpZyIsImlzUnVuVHJlZSIsImFzc2lnbiIsImRlZmF1bHRDb25maWciLCJnZXREZWZhdWx0Q29uZmlnIiwiY29uZmlnIiwiY2xpZW50IiwiZ2V0U2hhcmVkQ2xpZW50IiwiZGVkdXBlZE1ldGFkYXRhIiwiZXh0cmEiLCJ0cmFjZV9pZCIsInBhcmVudF9ydW4iLCJpZCIsImV4ZWN1dGlvbl9vcmRlciIsImNoaWxkX2V4ZWN1dGlvbl9vcmRlciIsImRvdHRlZF9vcmRlciIsImN1cnJlbnREb3R0ZWRPcmRlciIsInN0YXJ0X3RpbWUiLCJ2NCIsInJ1bl90eXBlIiwicHJvamVjdF9uYW1lIiwiY2hpbGRfcnVucyIsImFwaV91cmwiLCJhcGlfa2V5IiwiY2FsbGVyX29wdGlvbnMiLCJub3ciLCJzZXJpYWxpemVkIiwiaW5wdXRzIiwic2hhcmVkQ2xpZW50IiwiY3JlYXRlQ2hpbGQiLCJjaGlsZCIsInRyYWNpbmdFbmFibGVkIiwiTENfQ0hJTEQiLCJTeW1ib2wiLCJmb3IiLCJwcmVzZW50Q29uZmlnIiwiaXNSdW5uYWJsZUNvbmZpZ0xpa2UiLCJuZXdDb25maWciLCJjYWxsYmFja3MiLCJpc0NhbGxiYWNrTWFuYWdlckxpa2UiLCJjb3B5IiwidW5kZWZpbmVkIiwiX3BhcmVudFJ1bklkIiwiaGFuZGxlcnMiLCJmaW5kIiwiaXNMYW5nQ2hhaW5UcmFjZXJMaWtlIiwidXBkYXRlRnJvbVJ1blRyZWUiLCJ2aXNpdGVkIiwiU2V0IiwiY3VycmVudCIsImhhcyIsImFkZCIsIk1hdGgiLCJtYXgiLCJlbmQiLCJvdXRwdXRzIiwiZXJyb3IiLCJlbmRUaW1lIiwiZW5kX3RpbWUiLCJfY29udmVydFRvQ3JlYXRlIiwicnVuIiwicnVudGltZUVudiIsImV4Y2x1ZGVDaGlsZFJ1bnMiLCJydW5FeHRyYSIsInJ1bnRpbWUiLCJrIiwidiIsImVudHJpZXMiLCJwYXJlbnRfcnVuX2lkIiwibWFwIiwiY2hpbGRfcnVuIiwicGVyc2lzdGVkUnVuIiwibmFtZSIsInJlZmVyZW5jZV9leGFtcGxlX2lkIiwic2Vzc2lvbl9uYW1lIiwicG9zdFJ1biIsInJ1bkNyZWF0ZSIsImNyZWF0ZVJ1biIsImNoaWxkUnVuIiwiY29uc29sZSIsInBhdGNoUnVuIiwicnVuVXBkYXRlIiwiZXZlbnRzIiwidXBkYXRlUnVuIiwidG9KU09OIiwiZnJvbVJ1bm5hYmxlQ29uZmlnIiwicGFyZW50Q29uZmlnIiwicHJvcHMiLCJjYWxsYmFja01hbmFnZXIiLCJwYXJlbnRSdW4iLCJwcm9qZWN0TmFtZSIsInBhcmVudFJ1bklkIiwiZ2V0UGFyZW50UnVuSWQiLCJsYW5nQ2hhaW5UcmFjZXIiLCJoYW5kbGVyIiwiZ2V0UnVuIiwicGFyZW50UnVuVHJlZSIsImNvbmNhdCIsImZyb21Eb3R0ZWRPcmRlciIsImRvdHRlZE9yZGVyIiwiZnJvbUhlYWRlcnMiLCJoZWFkZXJzIiwiaW5oZXJpdEFyZ3MiLCJyYXdIZWFkZXJzIiwiZ2V0IiwiYmFnZ2FnZSIsImhlYWRlclRyYWNlIiwicGFyZW50RG90dGVkT3JkZXIiLCJ0cmltIiwicGFyc2VkRG90dGVkT3JkZXIiLCJwYXJ0Iiwic3RyVGltZSIsInRpbWUiLCJ0cmFjZUlkIiwiYXQiLCJ0b0hlYWRlcnMiLCJyZXN1bHQiLCJzZXQiLCJ4IiwiY29udGFpbnNMYW5nQ2hhaW5UcmFjZXJMaWtlIiwiQXJyYXkiLCJpc0FycmF5Iiwic29tZSIsImNhbGxiYWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/run_trees.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/singletons/constants.js":
/*!*************************************************************!*\
  !*** ./node_modules/langsmith/dist/singletons/constants.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _LC_CONTEXT_VARIABLES_KEY: () => (/* binding */ _LC_CONTEXT_VARIABLES_KEY)\n/* harmony export */ });\nconst _LC_CONTEXT_VARIABLES_KEY = Symbol.for(\"lc:context_variables\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLDRCQUE0QkMsT0FBT0MsR0FBRyxDQUFDLHdCQUF3QiIsInNvdXJjZXMiOlsid2VicGFjazovL2hhcmR3YXJlLWRvYy1jaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3NpbmdsZXRvbnMvY29uc3RhbnRzLmpzPzFkYTQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IF9MQ19DT05URVhUX1ZBUklBQkxFU19LRVkgPSBTeW1ib2wuZm9yKFwibGM6Y29udGV4dF92YXJpYWJsZXNcIik7XG4iXSwibmFtZXMiOlsiX0xDX0NPTlRFWFRfVkFSSUFCTEVTX0tFWSIsIlN5bWJvbCIsImZvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/singletons/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/singletons/fetch.js":
/*!*********************************************************!*\
  !*** ./node_modules/langsmith/dist/singletons/fetch.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _getFetchImplementation: () => (/* binding */ _getFetchImplementation),\n/* harmony export */   overrideFetchImplementation: () => (/* binding */ overrideFetchImplementation)\n/* harmony export */ });\n// Wrap the default fetch call due to issues with illegal invocations\n// in some environments:\n// https://stackoverflow.com/questions/69876859/why-does-bind-fix-failed-to-execute-fetch-on-window-illegal-invocation-err\n// @ts-expect-error Broad typing to support a range of fetch implementations\nconst DEFAULT_FETCH_IMPLEMENTATION = (...args)=>fetch(...args);\nconst LANGSMITH_FETCH_IMPLEMENTATION_KEY = Symbol.for(\"ls:fetch_implementation\");\n/**\n * Overrides the fetch implementation used for LangSmith calls.\n * You should use this if you need to use an implementation of fetch\n * other than the default global (e.g. for dealing with proxies).\n * @param fetch The new fetch functino to use.\n */ const overrideFetchImplementation = (fetch1)=>{\n    globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] = fetch1;\n};\n/**\n * @internal\n */ const _getFetchImplementation = ()=>{\n    return globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] ?? DEFAULT_FETCH_IMPLEMENTATION;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy9mZXRjaC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLHFFQUFxRTtBQUNyRSx3QkFBd0I7QUFDeEIsMEhBQTBIO0FBQzFILDRFQUE0RTtBQUM1RSxNQUFNQSwrQkFBK0IsQ0FBQyxHQUFHQyxPQUFTQyxTQUFTRDtBQUMzRCxNQUFNRSxxQ0FBcUNDLE9BQU9DLEdBQUcsQ0FBQztBQUN0RDs7Ozs7Q0FLQyxHQUNNLE1BQU1DLDhCQUE4QixDQUFDSjtJQUN4Q0ssVUFBVSxDQUFDSixtQ0FBbUMsR0FBR0Q7QUFDckQsRUFBRTtBQUNGOztDQUVDLEdBQ00sTUFBTU0sMEJBQTBCO0lBQ25DLE9BQVFELFVBQVUsQ0FBQ0osbUNBQW1DLElBQ2xESDtBQUNSLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYXJkd2FyZS1kb2MtY2hhdGJvdC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9zaW5nbGV0b25zL2ZldGNoLmpzPzc2MmMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gV3JhcCB0aGUgZGVmYXVsdCBmZXRjaCBjYWxsIGR1ZSB0byBpc3N1ZXMgd2l0aCBpbGxlZ2FsIGludm9jYXRpb25zXG4vLyBpbiBzb21lIGVudmlyb25tZW50czpcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzY5ODc2ODU5L3doeS1kb2VzLWJpbmQtZml4LWZhaWxlZC10by1leGVjdXRlLWZldGNoLW9uLXdpbmRvdy1pbGxlZ2FsLWludm9jYXRpb24tZXJyXG4vLyBAdHMtZXhwZWN0LWVycm9yIEJyb2FkIHR5cGluZyB0byBzdXBwb3J0IGEgcmFuZ2Ugb2YgZmV0Y2ggaW1wbGVtZW50YXRpb25zXG5jb25zdCBERUZBVUxUX0ZFVENIX0lNUExFTUVOVEFUSU9OID0gKC4uLmFyZ3MpID0+IGZldGNoKC4uLmFyZ3MpO1xuY29uc3QgTEFOR1NNSVRIX0ZFVENIX0lNUExFTUVOVEFUSU9OX0tFWSA9IFN5bWJvbC5mb3IoXCJsczpmZXRjaF9pbXBsZW1lbnRhdGlvblwiKTtcbi8qKlxuICogT3ZlcnJpZGVzIHRoZSBmZXRjaCBpbXBsZW1lbnRhdGlvbiB1c2VkIGZvciBMYW5nU21pdGggY2FsbHMuXG4gKiBZb3Ugc2hvdWxkIHVzZSB0aGlzIGlmIHlvdSBuZWVkIHRvIHVzZSBhbiBpbXBsZW1lbnRhdGlvbiBvZiBmZXRjaFxuICogb3RoZXIgdGhhbiB0aGUgZGVmYXVsdCBnbG9iYWwgKGUuZy4gZm9yIGRlYWxpbmcgd2l0aCBwcm94aWVzKS5cbiAqIEBwYXJhbSBmZXRjaCBUaGUgbmV3IGZldGNoIGZ1bmN0aW5vIHRvIHVzZS5cbiAqL1xuZXhwb3J0IGNvbnN0IG92ZXJyaWRlRmV0Y2hJbXBsZW1lbnRhdGlvbiA9IChmZXRjaCkgPT4ge1xuICAgIGdsb2JhbFRoaXNbTEFOR1NNSVRIX0ZFVENIX0lNUExFTUVOVEFUSU9OX0tFWV0gPSBmZXRjaDtcbn07XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY29uc3QgX2dldEZldGNoSW1wbGVtZW50YXRpb24gPSAoKSA9PiB7XG4gICAgcmV0dXJuIChnbG9iYWxUaGlzW0xBTkdTTUlUSF9GRVRDSF9JTVBMRU1FTlRBVElPTl9LRVldID8/XG4gICAgICAgIERFRkFVTFRfRkVUQ0hfSU1QTEVNRU5UQVRJT04pO1xufTtcbiJdLCJuYW1lcyI6WyJERUZBVUxUX0ZFVENIX0lNUExFTUVOVEFUSU9OIiwiYXJncyIsImZldGNoIiwiTEFOR1NNSVRIX0ZFVENIX0lNUExFTUVOVEFUSU9OX0tFWSIsIlN5bWJvbCIsImZvciIsIm92ZXJyaWRlRmV0Y2hJbXBsZW1lbnRhdGlvbiIsImdsb2JhbFRoaXMiLCJfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/singletons/fetch.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/singletons/traceable.js":
/*!*************************************************************!*\
  !*** ./node_modules/langsmith/dist/singletons/traceable.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncLocalStorageProviderSingleton: () => (/* binding */ AsyncLocalStorageProviderSingleton),\n/* harmony export */   ROOT: () => (/* binding */ ROOT),\n/* harmony export */   getCurrentRunTree: () => (/* binding */ getCurrentRunTree),\n/* harmony export */   isTraceableFunction: () => (/* binding */ isTraceableFunction),\n/* harmony export */   withRunTree: () => (/* binding */ withRunTree)\n/* harmony export */ });\n/* harmony import */ var _run_trees_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../run_trees.js */ \"(rsc)/./node_modules/langsmith/dist/run_trees.js\");\n\nclass MockAsyncLocalStorage {\n    getStore() {\n        return undefined;\n    }\n    run(_, callback) {\n        return callback();\n    }\n}\nconst TRACING_ALS_KEY = Symbol.for(\"ls:tracing_async_local_storage\");\nconst mockAsyncLocalStorage = new MockAsyncLocalStorage();\nclass AsyncLocalStorageProvider {\n    getInstance() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return globalThis[TRACING_ALS_KEY] ?? mockAsyncLocalStorage;\n    }\n    initializeGlobalInstance(instance) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (globalThis[TRACING_ALS_KEY] === undefined) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            globalThis[TRACING_ALS_KEY] = instance;\n        }\n    }\n}\nconst AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();\n/**\n * Return the current run tree from within a traceable-wrapped function.\n * Will throw an error if called outside of a traceable function.\n *\n * @returns The run tree for the given context.\n */ const getCurrentRunTree = ()=>{\n    const runTree = AsyncLocalStorageProviderSingleton.getInstance().getStore();\n    if (!(0,_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.isRunTree)(runTree)) {\n        throw new Error([\n            \"Could not get the current run tree.\",\n            \"\",\n            \"Please make sure you are calling this method within a traceable function or the tracing is enabled.\"\n        ].join(\"\\n\"));\n    }\n    return runTree;\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction withRunTree(runTree, fn) {\n    const storage = AsyncLocalStorageProviderSingleton.getInstance();\n    return new Promise((resolve, reject)=>{\n        storage.run(runTree, ()=>void Promise.resolve(fn()).then(resolve).catch(reject));\n    });\n}\nconst ROOT = Symbol.for(\"langsmith:traceable:root\");\nfunction isTraceableFunction(x) {\n    return typeof x === \"function\" && \"langsmith:traceable\" in x;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy90cmFjZWFibGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTRDO0FBQzVDLE1BQU1DO0lBQ0ZDLFdBQVc7UUFDUCxPQUFPQztJQUNYO0lBQ0FDLElBQUlDLENBQUMsRUFBRUMsUUFBUSxFQUFFO1FBQ2IsT0FBT0E7SUFDWDtBQUNKO0FBQ0EsTUFBTUMsa0JBQWtCQyxPQUFPQyxHQUFHLENBQUM7QUFDbkMsTUFBTUMsd0JBQXdCLElBQUlUO0FBQ2xDLE1BQU1VO0lBQ0ZDLGNBQWM7UUFDViw4REFBOEQ7UUFDOUQsT0FBT0MsVUFBVSxDQUFDTixnQkFBZ0IsSUFBSUc7SUFDMUM7SUFDQUkseUJBQXlCQyxRQUFRLEVBQUU7UUFDL0IsOERBQThEO1FBQzlELElBQUlGLFVBQVUsQ0FBQ04sZ0JBQWdCLEtBQUtKLFdBQVc7WUFDM0MsOERBQThEO1lBQzlEVSxVQUFVLENBQUNOLGdCQUFnQixHQUFHUTtRQUNsQztJQUNKO0FBQ0o7QUFDTyxNQUFNQyxxQ0FBcUMsSUFBSUwsNEJBQTRCO0FBQ2xGOzs7OztDQUtDLEdBQ00sTUFBTU0sb0JBQW9CO0lBQzdCLE1BQU1DLFVBQVVGLG1DQUFtQ0osV0FBVyxHQUFHVixRQUFRO0lBQ3pFLElBQUksQ0FBQ0Ysd0RBQVNBLENBQUNrQixVQUFVO1FBQ3JCLE1BQU0sSUFBSUMsTUFBTTtZQUNaO1lBQ0E7WUFDQTtTQUNILENBQUNDLElBQUksQ0FBQztJQUNYO0lBQ0EsT0FBT0Y7QUFDWCxFQUFFO0FBQ0YsOERBQThEO0FBQ3ZELFNBQVNHLFlBQVlILE9BQU8sRUFBRUksRUFBRTtJQUNuQyxNQUFNQyxVQUFVUCxtQ0FBbUNKLFdBQVc7SUFDOUQsT0FBTyxJQUFJWSxRQUFRLENBQUNDLFNBQVNDO1FBQ3pCSCxRQUFRbkIsR0FBRyxDQUFDYyxTQUFTLElBQU0sS0FBS00sUUFBUUMsT0FBTyxDQUFDSCxNQUFNSyxJQUFJLENBQUNGLFNBQVNHLEtBQUssQ0FBQ0Y7SUFDOUU7QUFDSjtBQUNPLE1BQU1HLE9BQU9yQixPQUFPQyxHQUFHLENBQUMsNEJBQTRCO0FBQ3BELFNBQVNxQixvQkFBb0JDLENBQUM7SUFHakMsT0FBTyxPQUFPQSxNQUFNLGNBQWMseUJBQXlCQTtBQUMvRCIsInNvdXJjZXMiOlsid2VicGFjazovL2hhcmR3YXJlLWRvYy1jaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3NpbmdsZXRvbnMvdHJhY2VhYmxlLmpzPzcyMjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNSdW5UcmVlIH0gZnJvbSBcIi4uL3J1bl90cmVlcy5qc1wiO1xuY2xhc3MgTW9ja0FzeW5jTG9jYWxTdG9yYWdlIHtcbiAgICBnZXRTdG9yZSgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcnVuKF8sIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cbn1cbmNvbnN0IFRSQUNJTkdfQUxTX0tFWSA9IFN5bWJvbC5mb3IoXCJsczp0cmFjaW5nX2FzeW5jX2xvY2FsX3N0b3JhZ2VcIik7XG5jb25zdCBtb2NrQXN5bmNMb2NhbFN0b3JhZ2UgPSBuZXcgTW9ja0FzeW5jTG9jYWxTdG9yYWdlKCk7XG5jbGFzcyBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyIHtcbiAgICBnZXRJbnN0YW5jZSgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXNbVFJBQ0lOR19BTFNfS0VZXSA/PyBtb2NrQXN5bmNMb2NhbFN0b3JhZ2U7XG4gICAgfVxuICAgIGluaXRpYWxpemVHbG9iYWxJbnN0YW5jZShpbnN0YW5jZSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBpZiAoZ2xvYmFsVGhpc1tUUkFDSU5HX0FMU19LRVldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBnbG9iYWxUaGlzW1RSQUNJTkdfQUxTX0tFWV0gPSBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uID0gbmV3IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXIoKTtcbi8qKlxuICogUmV0dXJuIHRoZSBjdXJyZW50IHJ1biB0cmVlIGZyb20gd2l0aGluIGEgdHJhY2VhYmxlLXdyYXBwZWQgZnVuY3Rpb24uXG4gKiBXaWxsIHRocm93IGFuIGVycm9yIGlmIGNhbGxlZCBvdXRzaWRlIG9mIGEgdHJhY2VhYmxlIGZ1bmN0aW9uLlxuICpcbiAqIEByZXR1cm5zIFRoZSBydW4gdHJlZSBmb3IgdGhlIGdpdmVuIGNvbnRleHQuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRDdXJyZW50UnVuVHJlZSA9ICgpID0+IHtcbiAgICBjb25zdCBydW5UcmVlID0gQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5nZXRJbnN0YW5jZSgpLmdldFN0b3JlKCk7XG4gICAgaWYgKCFpc1J1blRyZWUocnVuVHJlZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFtcbiAgICAgICAgICAgIFwiQ291bGQgbm90IGdldCB0aGUgY3VycmVudCBydW4gdHJlZS5cIixcbiAgICAgICAgICAgIFwiXCIsXG4gICAgICAgICAgICBcIlBsZWFzZSBtYWtlIHN1cmUgeW91IGFyZSBjYWxsaW5nIHRoaXMgbWV0aG9kIHdpdGhpbiBhIHRyYWNlYWJsZSBmdW5jdGlvbiBvciB0aGUgdHJhY2luZyBpcyBlbmFibGVkLlwiLFxuICAgICAgICBdLmpvaW4oXCJcXG5cIikpO1xuICAgIH1cbiAgICByZXR1cm4gcnVuVHJlZTtcbn07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0IGZ1bmN0aW9uIHdpdGhSdW5UcmVlKHJ1blRyZWUsIGZuKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24uZ2V0SW5zdGFuY2UoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBzdG9yYWdlLnJ1bihydW5UcmVlLCAoKSA9PiB2b2lkIFByb21pc2UucmVzb2x2ZShmbigpKS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCkpO1xuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFJPT1QgPSBTeW1ib2wuZm9yKFwibGFuZ3NtaXRoOnRyYWNlYWJsZTpyb290XCIpO1xuZXhwb3J0IGZ1bmN0aW9uIGlzVHJhY2VhYmxlRnVuY3Rpb24oeFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbikge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiICYmIFwibGFuZ3NtaXRoOnRyYWNlYWJsZVwiIGluIHg7XG59XG4iXSwibmFtZXMiOlsiaXNSdW5UcmVlIiwiTW9ja0FzeW5jTG9jYWxTdG9yYWdlIiwiZ2V0U3RvcmUiLCJ1bmRlZmluZWQiLCJydW4iLCJfIiwiY2FsbGJhY2siLCJUUkFDSU5HX0FMU19LRVkiLCJTeW1ib2wiLCJmb3IiLCJtb2NrQXN5bmNMb2NhbFN0b3JhZ2UiLCJBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyIiwiZ2V0SW5zdGFuY2UiLCJnbG9iYWxUaGlzIiwiaW5pdGlhbGl6ZUdsb2JhbEluc3RhbmNlIiwiaW5zdGFuY2UiLCJBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uIiwiZ2V0Q3VycmVudFJ1blRyZWUiLCJydW5UcmVlIiwiRXJyb3IiLCJqb2luIiwid2l0aFJ1blRyZWUiLCJmbiIsInN0b3JhZ2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInRoZW4iLCJjYXRjaCIsIlJPT1QiLCJpc1RyYWNlYWJsZUZ1bmN0aW9uIiwieCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/singletons/traceable.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/_uuid.js":
/*!****************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/_uuid.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertUuid: () => (/* binding */ assertUuid)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/langsmith/node_modules/uuid/dist/esm-node/validate.js\");\n\nfunction assertUuid(str, which) {\n    if (!uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"](str)) {\n        const msg = which !== undefined ? `Invalid UUID for ${which}: ${str}` : `Invalid UUID: ${str}`;\n        throw new Error(msg);\n    }\n    return str;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvX3V1aWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNkI7QUFDdEIsU0FBU0MsV0FBV0MsR0FBRyxFQUFFQyxLQUFLO0lBQ2pDLElBQUksQ0FBQ0gsNENBQWEsQ0FBQ0UsTUFBTTtRQUNyQixNQUFNRyxNQUFNRixVQUFVRyxZQUNoQixDQUFDLGlCQUFpQixFQUFFSCxNQUFNLEVBQUUsRUFBRUQsSUFBSSxDQUFDLEdBQ25DLENBQUMsY0FBYyxFQUFFQSxJQUFJLENBQUM7UUFDNUIsTUFBTSxJQUFJSyxNQUFNRjtJQUNwQjtJQUNBLE9BQU9IO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYXJkd2FyZS1kb2MtY2hhdGJvdC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9fdXVpZC5qcz9jNmI5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHV1aWQgZnJvbSBcInV1aWRcIjtcbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRVdWlkKHN0ciwgd2hpY2gpIHtcbiAgICBpZiAoIXV1aWQudmFsaWRhdGUoc3RyKSkge1xuICAgICAgICBjb25zdCBtc2cgPSB3aGljaCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGBJbnZhbGlkIFVVSUQgZm9yICR7d2hpY2h9OiAke3N0cn1gXG4gICAgICAgICAgICA6IGBJbnZhbGlkIFVVSUQ6ICR7c3RyfWA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuIl0sIm5hbWVzIjpbInV1aWQiLCJhc3NlcnRVdWlkIiwic3RyIiwid2hpY2giLCJ2YWxpZGF0ZSIsIm1zZyIsInVuZGVmaW5lZCIsIkVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/_uuid.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/async_caller.js":
/*!***********************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/async_caller.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncCaller: () => (/* binding */ AsyncCaller)\n/* harmony export */ });\n/* harmony import */ var p_retry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-retry */ \"(rsc)/./node_modules/p-retry/index.js\");\n/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! p-queue */ \"(rsc)/./node_modules/p-queue/dist/index.js\");\n/* harmony import */ var _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../singletons/fetch.js */ \"(rsc)/./node_modules/langsmith/dist/singletons/fetch.js\");\n\n\n\nconst STATUS_NO_RETRY = [\n    400,\n    401,\n    403,\n    404,\n    405,\n    406,\n    407,\n    408\n];\nconst STATUS_IGNORE = [\n    409\n];\n/**\n * A class that can be used to make async calls with concurrency and retry logic.\n *\n * This is useful for making calls to any kind of \"expensive\" external resource,\n * be it because it's rate-limited, subject to network issues, etc.\n *\n * Concurrent calls are limited by the `maxConcurrency` parameter, which defaults\n * to `Infinity`. This means that by default, all calls will be made in parallel.\n *\n * Retries are limited by the `maxRetries` parameter, which defaults to 6. This\n * means that by default, each call will be retried up to 6 times, with an\n * exponential backoff between each attempt.\n */ class AsyncCaller {\n    constructor(params){\n        Object.defineProperty(this, \"maxConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxRetries\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"queue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"onFailedResponseHook\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxConcurrency = params.maxConcurrency ?? Infinity;\n        this.maxRetries = params.maxRetries ?? 6;\n        if ( true) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.queue = new p_queue__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n                concurrency: this.maxConcurrency\n            });\n        } else {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.queue = new p_queue__WEBPACK_IMPORTED_MODULE_1__({\n                concurrency: this.maxConcurrency\n            });\n        }\n        this.onFailedResponseHook = params?.onFailedResponseHook;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    call(callable, ...args) {\n        const onFailedResponseHook = this.onFailedResponseHook;\n        return this.queue.add(()=>p_retry__WEBPACK_IMPORTED_MODULE_0__(()=>callable(...args).catch((error)=>{\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                    if (error instanceof Error) {\n                        throw error;\n                    } else {\n                        throw new Error(error);\n                    }\n                }), {\n                async onFailedAttempt (error) {\n                    if (error.message.startsWith(\"Cancel\") || error.message.startsWith(\"TimeoutError\") || error.message.startsWith(\"AbortError\")) {\n                        throw error;\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    if (error?.code === \"ECONNABORTED\") {\n                        throw error;\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    const response = error?.response;\n                    const status = response?.status;\n                    if (status) {\n                        if (STATUS_NO_RETRY.includes(+status)) {\n                            throw error;\n                        } else if (STATUS_IGNORE.includes(+status)) {\n                            return;\n                        }\n                        if (onFailedResponseHook) {\n                            await onFailedResponseHook(response);\n                        }\n                    }\n                },\n                // If needed we can change some of the defaults here,\n                // but they're quite sensible.\n                retries: this.maxRetries,\n                randomize: true\n            }), {\n            throwOnTimeout: true\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callWithOptions(options, callable, ...args) {\n        // Note this doesn't cancel the underlying request,\n        // when available prefer to use the signal option of the underlying call\n        if (options.signal) {\n            return Promise.race([\n                this.call(callable, ...args),\n                new Promise((_, reject)=>{\n                    options.signal?.addEventListener(\"abort\", ()=>{\n                        reject(new Error(\"AbortError\"));\n                    });\n                })\n            ]);\n        }\n        return this.call(callable, ...args);\n    }\n    fetch(...args) {\n        return this.call(()=>(0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_2__._getFetchImplementation)()(...args).then((res)=>res.ok ? res : Promise.reject(res)));\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvYXN5bmNfY2FsbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNkI7QUFDRztBQUNpQztBQUNqRSxNQUFNRyxrQkFBa0I7SUFDcEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNIO0FBQ0QsTUFBTUMsZ0JBQWdCO0lBQ2xCO0NBQ0g7QUFDRDs7Ozs7Ozs7Ozs7O0NBWUMsR0FDTSxNQUFNQztJQUNUQyxZQUFZQyxNQUFNLENBQUU7UUFDaEJDLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsa0JBQWtCO1lBQzFDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxjQUFjO1lBQ3RDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxTQUFTO1lBQ2pDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSx3QkFBd0I7WUFDaERDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBLElBQUksQ0FBQ0MsY0FBYyxHQUFHUCxPQUFPTyxjQUFjLElBQUlDO1FBQy9DLElBQUksQ0FBQ0MsVUFBVSxHQUFHVCxPQUFPUyxVQUFVLElBQUk7UUFDdkMsSUFBSSxLQUFzQmYsRUFBRTtZQUN4Qiw4REFBOEQ7WUFDOUQsSUFBSSxDQUFDZ0IsS0FBSyxHQUFHLElBQUloQiwrQ0FBaUIsQ0FBQztnQkFDL0JrQixhQUFhLElBQUksQ0FBQ0wsY0FBYztZQUNwQztRQUNKLE9BQ0s7WUFDRCw4REFBOEQ7WUFDOUQsSUFBSSxDQUFDRyxLQUFLLEdBQUcsSUFBSWhCLG9DQUFTQSxDQUFDO2dCQUFFa0IsYUFBYSxJQUFJLENBQUNMLGNBQWM7WUFBQztRQUNsRTtRQUNBLElBQUksQ0FBQ00sb0JBQW9CLEdBQUdiLFFBQVFhO0lBQ3hDO0lBQ0EsOERBQThEO0lBQzlEQyxLQUFLQyxRQUFRLEVBQUUsR0FBR0MsSUFBSSxFQUFFO1FBQ3BCLE1BQU1ILHVCQUF1QixJQUFJLENBQUNBLG9CQUFvQjtRQUN0RCxPQUFPLElBQUksQ0FBQ0gsS0FBSyxDQUFDTyxHQUFHLENBQUMsSUFBTXhCLG9DQUFNQSxDQUFDLElBQU1zQixZQUFZQyxNQUFNRSxLQUFLLENBQUMsQ0FBQ0M7b0JBQzlELHVEQUF1RDtvQkFDdkQsSUFBSUEsaUJBQWlCQyxPQUFPO3dCQUN4QixNQUFNRDtvQkFDVixPQUNLO3dCQUNELE1BQU0sSUFBSUMsTUFBTUQ7b0JBQ3BCO2dCQUNKLElBQUk7Z0JBQ0EsTUFBTUUsaUJBQWdCRixLQUFLO29CQUN2QixJQUFJQSxNQUFNRyxPQUFPLENBQUNDLFVBQVUsQ0FBQyxhQUN6QkosTUFBTUcsT0FBTyxDQUFDQyxVQUFVLENBQUMsbUJBQ3pCSixNQUFNRyxPQUFPLENBQUNDLFVBQVUsQ0FBQyxlQUFlO3dCQUN4QyxNQUFNSjtvQkFDVjtvQkFDQSw4REFBOEQ7b0JBQzlELElBQUlBLE9BQU9LLFNBQVMsZ0JBQWdCO3dCQUNoQyxNQUFNTDtvQkFDVjtvQkFDQSw4REFBOEQ7b0JBQzlELE1BQU1NLFdBQVdOLE9BQU9NO29CQUN4QixNQUFNQyxTQUFTRCxVQUFVQztvQkFDekIsSUFBSUEsUUFBUTt3QkFDUixJQUFJOUIsZ0JBQWdCK0IsUUFBUSxDQUFDLENBQUNELFNBQVM7NEJBQ25DLE1BQU1QO3dCQUNWLE9BQ0ssSUFBSXRCLGNBQWM4QixRQUFRLENBQUMsQ0FBQ0QsU0FBUzs0QkFDdEM7d0JBQ0o7d0JBQ0EsSUFBSWIsc0JBQXNCOzRCQUN0QixNQUFNQSxxQkFBcUJZO3dCQUMvQjtvQkFDSjtnQkFDSjtnQkFDQSxxREFBcUQ7Z0JBQ3JELDhCQUE4QjtnQkFDOUJHLFNBQVMsSUFBSSxDQUFDbkIsVUFBVTtnQkFDeEJvQixXQUFXO1lBQ2YsSUFBSTtZQUFFQyxnQkFBZ0I7UUFBSztJQUMvQjtJQUNBLDhEQUE4RDtJQUM5REMsZ0JBQWdCQyxPQUFPLEVBQUVqQixRQUFRLEVBQUUsR0FBR0MsSUFBSSxFQUFFO1FBQ3hDLG1EQUFtRDtRQUNuRCx3RUFBd0U7UUFDeEUsSUFBSWdCLFFBQVFDLE1BQU0sRUFBRTtZQUNoQixPQUFPQyxRQUFRQyxJQUFJLENBQUM7Z0JBQ2hCLElBQUksQ0FBQ3JCLElBQUksQ0FBQ0MsYUFBYUM7Z0JBQ3ZCLElBQUlrQixRQUFRLENBQUNFLEdBQUdDO29CQUNaTCxRQUFRQyxNQUFNLEVBQUVLLGlCQUFpQixTQUFTO3dCQUN0Q0QsT0FBTyxJQUFJakIsTUFBTTtvQkFDckI7Z0JBQ0o7YUFDSDtRQUNMO1FBQ0EsT0FBTyxJQUFJLENBQUNOLElBQUksQ0FBQ0MsYUFBYUM7SUFDbEM7SUFDQXVCLE1BQU0sR0FBR3ZCLElBQUksRUFBRTtRQUNYLE9BQU8sSUFBSSxDQUFDRixJQUFJLENBQUMsSUFBTW5CLDZFQUF1QkEsTUFBTXFCLE1BQU13QixJQUFJLENBQUMsQ0FBQ0MsTUFBUUEsSUFBSUMsRUFBRSxHQUFHRCxNQUFNUCxRQUFRRyxNQUFNLENBQUNJO0lBQzFHO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYXJkd2FyZS1kb2MtY2hhdGJvdC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9hc3luY19jYWxsZXIuanM/YThkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcFJldHJ5IGZyb20gXCJwLXJldHJ5XCI7XG5pbXBvcnQgUFF1ZXVlTW9kIGZyb20gXCJwLXF1ZXVlXCI7XG5pbXBvcnQgeyBfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbiB9IGZyb20gXCIuLi9zaW5nbGV0b25zL2ZldGNoLmpzXCI7XG5jb25zdCBTVEFUVVNfTk9fUkVUUlkgPSBbXG4gICAgNDAwLCAvLyBCYWQgUmVxdWVzdFxuICAgIDQwMSwgLy8gVW5hdXRob3JpemVkXG4gICAgNDAzLCAvLyBGb3JiaWRkZW5cbiAgICA0MDQsIC8vIE5vdCBGb3VuZFxuICAgIDQwNSwgLy8gTWV0aG9kIE5vdCBBbGxvd2VkXG4gICAgNDA2LCAvLyBOb3QgQWNjZXB0YWJsZVxuICAgIDQwNywgLy8gUHJveHkgQXV0aGVudGljYXRpb24gUmVxdWlyZWRcbiAgICA0MDgsIC8vIFJlcXVlc3QgVGltZW91dFxuXTtcbmNvbnN0IFNUQVRVU19JR05PUkUgPSBbXG4gICAgNDA5LCAvLyBDb25mbGljdFxuXTtcbi8qKlxuICogQSBjbGFzcyB0aGF0IGNhbiBiZSB1c2VkIHRvIG1ha2UgYXN5bmMgY2FsbHMgd2l0aCBjb25jdXJyZW5jeSBhbmQgcmV0cnkgbG9naWMuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIG1ha2luZyBjYWxscyB0byBhbnkga2luZCBvZiBcImV4cGVuc2l2ZVwiIGV4dGVybmFsIHJlc291cmNlLFxuICogYmUgaXQgYmVjYXVzZSBpdCdzIHJhdGUtbGltaXRlZCwgc3ViamVjdCB0byBuZXR3b3JrIGlzc3VlcywgZXRjLlxuICpcbiAqIENvbmN1cnJlbnQgY2FsbHMgYXJlIGxpbWl0ZWQgYnkgdGhlIGBtYXhDb25jdXJyZW5jeWAgcGFyYW1ldGVyLCB3aGljaCBkZWZhdWx0c1xuICogdG8gYEluZmluaXR5YC4gVGhpcyBtZWFucyB0aGF0IGJ5IGRlZmF1bHQsIGFsbCBjYWxscyB3aWxsIGJlIG1hZGUgaW4gcGFyYWxsZWwuXG4gKlxuICogUmV0cmllcyBhcmUgbGltaXRlZCBieSB0aGUgYG1heFJldHJpZXNgIHBhcmFtZXRlciwgd2hpY2ggZGVmYXVsdHMgdG8gNi4gVGhpc1xuICogbWVhbnMgdGhhdCBieSBkZWZhdWx0LCBlYWNoIGNhbGwgd2lsbCBiZSByZXRyaWVkIHVwIHRvIDYgdGltZXMsIHdpdGggYW5cbiAqIGV4cG9uZW50aWFsIGJhY2tvZmYgYmV0d2VlbiBlYWNoIGF0dGVtcHQuXG4gKi9cbmV4cG9ydCBjbGFzcyBBc3luY0NhbGxlciB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heENvbmN1cnJlbmN5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heFJldHJpZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicXVldWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib25GYWlsZWRSZXNwb25zZUhvb2tcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXhDb25jdXJyZW5jeSA9IHBhcmFtcy5tYXhDb25jdXJyZW5jeSA/PyBJbmZpbml0eTtcbiAgICAgICAgdGhpcy5tYXhSZXRyaWVzID0gcGFyYW1zLm1heFJldHJpZXMgPz8gNjtcbiAgICAgICAgaWYgKFwiZGVmYXVsdFwiIGluIFBRdWV1ZU1vZCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIHRoaXMucXVldWUgPSBuZXcgUFF1ZXVlTW9kLmRlZmF1bHQoe1xuICAgICAgICAgICAgICAgIGNvbmN1cnJlbmN5OiB0aGlzLm1heENvbmN1cnJlbmN5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IG5ldyBQUXVldWVNb2QoeyBjb25jdXJyZW5jeTogdGhpcy5tYXhDb25jdXJyZW5jeSB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uRmFpbGVkUmVzcG9uc2VIb29rID0gcGFyYW1zPy5vbkZhaWxlZFJlc3BvbnNlSG9vaztcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjYWxsKGNhbGxhYmxlLCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IG9uRmFpbGVkUmVzcG9uc2VIb29rID0gdGhpcy5vbkZhaWxlZFJlc3BvbnNlSG9vaztcbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWUuYWRkKCgpID0+IHBSZXRyeSgoKSA9PiBjYWxsYWJsZSguLi5hcmdzKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnN0YW5jZW9mL25vLWluc3RhbmNlb2ZcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwge1xuICAgICAgICAgICAgYXN5bmMgb25GYWlsZWRBdHRlbXB0KGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2Uuc3RhcnRzV2l0aChcIkNhbmNlbFwiKSB8fFxuICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJUaW1lb3V0RXJyb3JcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKFwiQWJvcnRFcnJvclwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3I/LmNvZGUgPT09IFwiRUNPTk5BQk9SVEVEXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBlcnJvcj8ucmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gcmVzcG9uc2U/LnN0YXR1cztcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChTVEFUVVNfTk9fUkVUUlkuaW5jbHVkZXMoK3N0YXR1cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFNUQVRVU19JR05PUkUuaW5jbHVkZXMoK3N0YXR1cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob25GYWlsZWRSZXNwb25zZUhvb2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IG9uRmFpbGVkUmVzcG9uc2VIb29rKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBJZiBuZWVkZWQgd2UgY2FuIGNoYW5nZSBzb21lIG9mIHRoZSBkZWZhdWx0cyBoZXJlLFxuICAgICAgICAgICAgLy8gYnV0IHRoZXkncmUgcXVpdGUgc2Vuc2libGUuXG4gICAgICAgICAgICByZXRyaWVzOiB0aGlzLm1heFJldHJpZXMsXG4gICAgICAgICAgICByYW5kb21pemU6IHRydWUsXG4gICAgICAgIH0pLCB7IHRocm93T25UaW1lb3V0OiB0cnVlIH0pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNhbGxXaXRoT3B0aW9ucyhvcHRpb25zLCBjYWxsYWJsZSwgLi4uYXJncykge1xuICAgICAgICAvLyBOb3RlIHRoaXMgZG9lc24ndCBjYW5jZWwgdGhlIHVuZGVybHlpbmcgcmVxdWVzdCxcbiAgICAgICAgLy8gd2hlbiBhdmFpbGFibGUgcHJlZmVyIHRvIHVzZSB0aGUgc2lnbmFsIG9wdGlvbiBvZiB0aGUgdW5kZXJseWluZyBjYWxsXG4gICAgICAgIGlmIChvcHRpb25zLnNpZ25hbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsKGNhbGxhYmxlLCAuLi5hcmdzKSxcbiAgICAgICAgICAgICAgICBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2lnbmFsPy5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkFib3J0RXJyb3JcIikpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwoY2FsbGFibGUsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICBmZXRjaCguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwoKCkgPT4gX2dldEZldGNoSW1wbGVtZW50YXRpb24oKSguLi5hcmdzKS50aGVuKChyZXMpID0+IHJlcy5vayA/IHJlcyA6IFByb21pc2UucmVqZWN0KHJlcykpKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsicFJldHJ5IiwiUFF1ZXVlTW9kIiwiX2dldEZldGNoSW1wbGVtZW50YXRpb24iLCJTVEFUVVNfTk9fUkVUUlkiLCJTVEFUVVNfSUdOT1JFIiwiQXN5bmNDYWxsZXIiLCJjb25zdHJ1Y3RvciIsInBhcmFtcyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwidmFsdWUiLCJtYXhDb25jdXJyZW5jeSIsIkluZmluaXR5IiwibWF4UmV0cmllcyIsInF1ZXVlIiwiZGVmYXVsdCIsImNvbmN1cnJlbmN5Iiwib25GYWlsZWRSZXNwb25zZUhvb2siLCJjYWxsIiwiY2FsbGFibGUiLCJhcmdzIiwiYWRkIiwiY2F0Y2giLCJlcnJvciIsIkVycm9yIiwib25GYWlsZWRBdHRlbXB0IiwibWVzc2FnZSIsInN0YXJ0c1dpdGgiLCJjb2RlIiwicmVzcG9uc2UiLCJzdGF0dXMiLCJpbmNsdWRlcyIsInJldHJpZXMiLCJyYW5kb21pemUiLCJ0aHJvd09uVGltZW91dCIsImNhbGxXaXRoT3B0aW9ucyIsIm9wdGlvbnMiLCJzaWduYWwiLCJQcm9taXNlIiwicmFjZSIsIl8iLCJyZWplY3QiLCJhZGRFdmVudExpc3RlbmVyIiwiZmV0Y2giLCJ0aGVuIiwicmVzIiwib2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/async_caller.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/env.js":
/*!**************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/env.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getEnv: () => (/* binding */ getEnv),\n/* harmony export */   getEnvironmentVariable: () => (/* binding */ getEnvironmentVariable),\n/* harmony export */   getEnvironmentVariables: () => (/* binding */ getEnvironmentVariables),\n/* harmony export */   getLangChainEnvVars: () => (/* binding */ getLangChainEnvVars),\n/* harmony export */   getLangChainEnvVarsMetadata: () => (/* binding */ getLangChainEnvVarsMetadata),\n/* harmony export */   getLangSmithEnvironmentVariable: () => (/* binding */ getLangSmithEnvironmentVariable),\n/* harmony export */   getRuntimeEnvironment: () => (/* binding */ getRuntimeEnvironment),\n/* harmony export */   getShas: () => (/* binding */ getShas),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isDeno: () => (/* binding */ isDeno),\n/* harmony export */   isJsDom: () => (/* binding */ isJsDom),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isWebWorker: () => (/* binding */ isWebWorker),\n/* harmony export */   setEnvironmentVariable: () => (/* binding */ setEnvironmentVariable)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ \"(rsc)/./node_modules/langsmith/dist/index.js\");\n// Inlined from https://github.com/flexdinesh/browser-or-node\n\nlet globalEnv;\nconst isBrowser = ()=> false && 0;\nconst isWebWorker = ()=>typeof globalThis === \"object\" && globalThis.constructor && globalThis.constructor.name === \"DedicatedWorkerGlobalScope\";\nconst isJsDom = ()=> false || typeof navigator !== \"undefined\" && (navigator.userAgent.includes(\"Node.js\") || navigator.userAgent.includes(\"jsdom\"));\n// Supabase Edge Function provides a `Deno` global object\n// without `version` property\nconst isDeno = ()=>typeof Deno !== \"undefined\";\n// Mark not-as-node if in Supabase Edge Function\nconst isNode = ()=>typeof process !== \"undefined\" && typeof process.versions !== \"undefined\" && typeof process.versions.node !== \"undefined\" && !isDeno();\nconst getEnv = ()=>{\n    if (globalEnv) {\n        return globalEnv;\n    }\n    if (isBrowser()) {\n        globalEnv = \"browser\";\n    } else if (isNode()) {\n        globalEnv = \"node\";\n    } else if (isWebWorker()) {\n        globalEnv = \"webworker\";\n    } else if (isJsDom()) {\n        globalEnv = \"jsdom\";\n    } else if (isDeno()) {\n        globalEnv = \"deno\";\n    } else {\n        globalEnv = \"other\";\n    }\n    return globalEnv;\n};\nlet runtimeEnvironment;\nfunction getRuntimeEnvironment() {\n    if (runtimeEnvironment === undefined) {\n        const env = getEnv();\n        const releaseEnv = getShas();\n        runtimeEnvironment = {\n            library: \"langsmith\",\n            runtime: env,\n            sdk: \"langsmith-js\",\n            sdk_version: _index_js__WEBPACK_IMPORTED_MODULE_0__.__version__,\n            ...releaseEnv\n        };\n    }\n    return runtimeEnvironment;\n}\n/**\n * Retrieves the LangChain-specific environment variables from the current runtime environment.\n * Sensitive keys (containing the word \"key\", \"token\", or \"secret\") have their values redacted for security.\n *\n * @returns {Record<string, string>}\n *  - A record of LangChain-specific environment variables.\n */ function getLangChainEnvVars() {\n    const allEnvVars = getEnvironmentVariables() || {};\n    const envVars = {};\n    for (const [key, value] of Object.entries(allEnvVars)){\n        if (key.startsWith(\"LANGCHAIN_\") && typeof value === \"string\") {\n            envVars[key] = value;\n        }\n    }\n    for(const key in envVars){\n        if ((key.toLowerCase().includes(\"key\") || key.toLowerCase().includes(\"secret\") || key.toLowerCase().includes(\"token\")) && typeof envVars[key] === \"string\") {\n            const value = envVars[key];\n            envVars[key] = value.slice(0, 2) + \"*\".repeat(value.length - 4) + value.slice(-2);\n        }\n    }\n    return envVars;\n}\n/**\n * Retrieves the LangChain-specific metadata from the current runtime environment.\n *\n * @returns {Record<string, string>}\n *  - A record of LangChain-specific metadata environment variables.\n */ function getLangChainEnvVarsMetadata() {\n    const allEnvVars = getEnvironmentVariables() || {};\n    const envVars = {};\n    const excluded = [\n        \"LANGCHAIN_API_KEY\",\n        \"LANGCHAIN_ENDPOINT\",\n        \"LANGCHAIN_TRACING_V2\",\n        \"LANGCHAIN_PROJECT\",\n        \"LANGCHAIN_SESSION\"\n    ];\n    for (const [key, value] of Object.entries(allEnvVars)){\n        if (key.startsWith(\"LANGCHAIN_\") && typeof value === \"string\" && !excluded.includes(key) && !key.toLowerCase().includes(\"key\") && !key.toLowerCase().includes(\"secret\") && !key.toLowerCase().includes(\"token\")) {\n            if (key === \"LANGCHAIN_REVISION_ID\") {\n                envVars[\"revision_id\"] = value;\n            } else {\n                envVars[key] = value;\n            }\n        }\n    }\n    return envVars;\n}\n/**\n * Retrieves the environment variables from the current runtime environment.\n *\n * This function is designed to operate in a variety of JS environments,\n * including Node.js, Deno, browsers, etc.\n *\n * @returns {Record<string, string> | undefined}\n *  - A record of environment variables if available.\n *  - `undefined` if the environment does not support or allows access to environment variables.\n */ function getEnvironmentVariables() {\n    try {\n        // Check for Node.js environment\n        // eslint-disable-next-line no-process-env\n        if (typeof process !== \"undefined\" && process.env) {\n            // eslint-disable-next-line no-process-env\n            return Object.entries(process.env).reduce((acc, [key, value])=>{\n                acc[key] = String(value);\n                return acc;\n            }, {});\n        }\n        // For browsers and other environments, we may not have direct access to env variables\n        // Return undefined or any other fallback as required.\n        return undefined;\n    } catch (e) {\n        // Catch any errors that might occur while trying to access environment variables\n        return undefined;\n    }\n}\nfunction getEnvironmentVariable(name) {\n    // Certain Deno setups will throw an error if you try to access environment variables\n    // https://github.com/hwchase17/langchainjs/issues/1412\n    try {\n        return typeof process !== \"undefined\" ? process.env?.[name] : undefined;\n    } catch (e) {\n        return undefined;\n    }\n}\nfunction getLangSmithEnvironmentVariable(name) {\n    return getEnvironmentVariable(`LANGSMITH_${name}`) || getEnvironmentVariable(`LANGCHAIN_${name}`);\n}\nfunction setEnvironmentVariable(name, value) {\n    if (typeof process !== \"undefined\") {\n        // eslint-disable-next-line no-process-env\n        process.env[name] = value;\n    }\n}\nlet cachedCommitSHAs;\n/**\n * Get the Git commit SHA from common environment variables\n * used by different CI/CD platforms.\n * @returns {string | undefined} The Git commit SHA or undefined if not found.\n */ function getShas() {\n    if (cachedCommitSHAs !== undefined) {\n        return cachedCommitSHAs;\n    }\n    const common_release_envs = [\n        \"VERCEL_GIT_COMMIT_SHA\",\n        \"NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA\",\n        \"COMMIT_REF\",\n        \"RENDER_GIT_COMMIT\",\n        \"CI_COMMIT_SHA\",\n        \"CIRCLE_SHA1\",\n        \"CF_PAGES_COMMIT_SHA\",\n        \"REACT_APP_GIT_SHA\",\n        \"SOURCE_VERSION\",\n        \"GITHUB_SHA\",\n        \"TRAVIS_COMMIT\",\n        \"GIT_COMMIT\",\n        \"BUILD_VCS_NUMBER\",\n        \"bamboo_planRepository_revision\",\n        \"Build.SourceVersion\",\n        \"BITBUCKET_COMMIT\",\n        \"DRONE_COMMIT_SHA\",\n        \"SEMAPHORE_GIT_SHA\",\n        \"BUILDKITE_COMMIT\"\n    ];\n    const shas = {};\n    for (const env of common_release_envs){\n        const envVar = getEnvironmentVariable(env);\n        if (envVar !== undefined) {\n            shas[env] = envVar;\n        }\n    }\n    cachedCommitSHAs = shas;\n    return shas;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDZEQUE2RDtBQUNuQjtBQUMxQyxJQUFJQztBQUNHLE1BQU1DLFlBQVksSUFBTSxNQUE2QixJQUFJLENBQXNDLENBQUM7QUFDaEcsTUFBTUcsY0FBYyxJQUFNLE9BQU9DLGVBQWUsWUFDbkRBLFdBQVdDLFdBQVcsSUFDdEJELFdBQVdDLFdBQVcsQ0FBQ0MsSUFBSSxLQUFLLDZCQUE2QjtBQUMxRCxNQUFNQyxVQUFVLElBQU0sTUFBMEQsSUFDbEYsT0FBT0MsY0FBYyxlQUNqQkEsQ0FBQUEsVUFBVUMsU0FBUyxDQUFDQyxRQUFRLENBQUMsY0FDMUJGLFVBQVVDLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDLFFBQU8sRUFBSTtBQUNwRCx5REFBeUQ7QUFDekQsNkJBQTZCO0FBQ3RCLE1BQU1DLFNBQVMsSUFBTSxPQUFPQyxTQUFTLFlBQVk7QUFDeEQsZ0RBQWdEO0FBQ3pDLE1BQU1DLFNBQVMsSUFBTSxPQUFPQyxZQUFZLGVBQzNDLE9BQU9BLFFBQVFDLFFBQVEsS0FBSyxlQUM1QixPQUFPRCxRQUFRQyxRQUFRLENBQUNDLElBQUksS0FBSyxlQUNqQyxDQUFDTCxTQUFTO0FBQ1AsTUFBTU0sU0FBUztJQUNsQixJQUFJbEIsV0FBVztRQUNYLE9BQU9BO0lBQ1g7SUFDQSxJQUFJQyxhQUFhO1FBQ2JELFlBQVk7SUFDaEIsT0FDSyxJQUFJYyxVQUFVO1FBQ2ZkLFlBQVk7SUFDaEIsT0FDSyxJQUFJSSxlQUFlO1FBQ3BCSixZQUFZO0lBQ2hCLE9BQ0ssSUFBSVEsV0FBVztRQUNoQlIsWUFBWTtJQUNoQixPQUNLLElBQUlZLFVBQVU7UUFDZlosWUFBWTtJQUNoQixPQUNLO1FBQ0RBLFlBQVk7SUFDaEI7SUFDQSxPQUFPQTtBQUNYLEVBQUU7QUFDRixJQUFJbUI7QUFDRyxTQUFTQztJQUNaLElBQUlELHVCQUF1QkUsV0FBVztRQUNs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NEIsZ0NBQWdDMUMsSUFBSTtJQUNoRCxPQUFReUMsdUJBQXVCLENBQUMsVUFBVSxFQUFFekMsS0FBSyxDQUFDLEtBQzlDeUMsdUJBQXVCLENBQUMsVUFBVSxFQUFFekMsS0FBSyxDQUFDO0FBQ2xEO0FBQ08sU0FBUzJDLHVCQUF1QjNDLElBQUksRUFBRTJCLEtBQUs7SUFDOUMsSUFBSSxPQUFPbkIsWUFBWSxhQUFhO1FBQ2hDLDBDQUEwQztRQUMxQ0EsUUFBUU8sR0FBRyxDQUFDZixLQUFLLEdBQUcyQjtJQUN4QjtBQUNKO0FBQ0EsSUFBSWlCO0FBQ0o7Ozs7Q0FJQyxHQUNNLFNBQVMzQjtJQUNaLElBQUkyQixxQkFBcUI5QixXQUFXO1FBQ2hDLE9BQU84QjtJQUNYO0lBQ0EsTUFBTUMsc0JBQXNCO1FBQ3hCO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDRCxNQUFNQyxPQUFPLENBQUM7SUFDZCxLQUFLLE1BQU0vQixPQUFPOEIsb0JBQXFCO1FBQ25DLE1BQU1FLFNBQVNOLHVCQUF1QjFCO1FBQ3RDLElBQUlnQyxXQUFXakMsV0FBVztZQUN0QmdDLElBQUksQ0FBQy9CLElBQUksR0FBR2dDO1FBQ2hCO0lBQ0o7SUFDQUgsbUJBQW1CRTtJQUNuQixPQUFPQTtBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGFyZHdhcmUtZG9jLWNoYXRib3QvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZW52LmpzP2E3NDAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW5saW5lZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9mbGV4ZGluZXNoL2Jyb3dzZXItb3Itbm9kZVxuaW1wb3J0IHsgX192ZXJzaW9uX18gfSBmcm9tIFwiLi4vaW5kZXguanNcIjtcbmxldCBnbG9iYWxFbnY7XG5leHBvcnQgY29uc3QgaXNCcm93c2VyID0gKCkgPT4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuZXhwb3J0IGNvbnN0IGlzV2ViV29ya2VyID0gKCkgPT4gdHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIgJiZcbiAgICBnbG9iYWxUaGlzLmNvbnN0cnVjdG9yICYmXG4gICAgZ2xvYmFsVGhpcy5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIkRlZGljYXRlZFdvcmtlckdsb2JhbFNjb3BlXCI7XG5leHBvcnQgY29uc3QgaXNKc0RvbSA9ICgpID0+ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5uYW1lID09PSBcIm5vZGVqc1wiKSB8fFxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIChuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwiTm9kZS5qc1wiKSB8fFxuICAgICAgICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcyhcImpzZG9tXCIpKSk7XG4vLyBTdXBhYmFzZSBFZGdlIEZ1bmN0aW9uIHByb3ZpZGVzIGEgYERlbm9gIGdsb2JhbCBvYmplY3Rcbi8vIHdpdGhvdXQgYHZlcnNpb25gIHByb3BlcnR5XG5leHBvcnQgY29uc3QgaXNEZW5vID0gKCkgPT4gdHlwZW9mIERlbm8gIT09IFwidW5kZWZpbmVkXCI7XG4vLyBNYXJrIG5vdC1hcy1ub2RlIGlmIGluIFN1cGFiYXNlIEVkZ2UgRnVuY3Rpb25cbmV4cG9ydCBjb25zdCBpc05vZGUgPSAoKSA9PiB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICFpc0Rlbm8oKTtcbmV4cG9ydCBjb25zdCBnZXRFbnYgPSAoKSA9PiB7XG4gICAgaWYgKGdsb2JhbEVudikge1xuICAgICAgICByZXR1cm4gZ2xvYmFsRW52O1xuICAgIH1cbiAgICBpZiAoaXNCcm93c2VyKCkpIHtcbiAgICAgICAgZ2xvYmFsRW52ID0gXCJicm93c2VyXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzTm9kZSgpKSB7XG4gICAgICAgIGdsb2JhbEVudiA9IFwibm9kZVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1dlYldvcmtlcigpKSB7XG4gICAgICAgIGdsb2JhbEVudiA9IFwid2Vid29ya2VyXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzSnNEb20oKSkge1xuICAgICAgICBnbG9iYWxFbnYgPSBcImpzZG9tXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRGVubygpKSB7XG4gICAgICAgIGdsb2JhbEVudiA9IFwiZGVub1wiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2xvYmFsRW52ID0gXCJvdGhlclwiO1xuICAgIH1cbiAgICByZXR1cm4gZ2xvYmFsRW52O1xufTtcbmxldCBydW50aW1lRW52aXJvbm1lbnQ7XG5leHBvcnQgZnVuY3Rpb24gZ2V0UnVudGltZUVudmlyb25tZW50KCkge1xuICAgIGlmIChydW50aW1lRW52aXJvbm1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBlbnYgPSBnZXRFbnYoKTtcbiAgICAgICAgY29uc3QgcmVsZWFzZUVudiA9IGdldFNoYXMoKTtcbiAgICAgICAgcnVudGltZUVudmlyb25tZW50ID0ge1xuICAgICAgICAgICAgbGlicmFyeTogXCJsYW5nc21pdGhcIixcbiAgICAgICAgICAgIHJ1bnRpbWU6IGVudixcbiAgICAgICAgICAgIHNkazogXCJsYW5nc21pdGgtanNcIixcbiAgICAgICAgICAgIHNka192ZXJzaW9uOiBfX3ZlcnNpb25fXyxcbiAgICAgICAgICAgIC4uLnJlbGVhc2VFbnYsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBydW50aW1lRW52aXJvbm1lbnQ7XG59XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgTGFuZ0NoYWluLXNwZWNpZmljIGVudmlyb25tZW50IHZhcmlhYmxlcyBmcm9tIHRoZSBjdXJyZW50IHJ1bnRpbWUgZW52aXJvbm1lbnQuXG4gKiBTZW5zaXRpdmUga2V5cyAoY29udGFpbmluZyB0aGUgd29yZCBcImtleVwiLCBcInRva2VuXCIsIG9yIFwic2VjcmV0XCIpIGhhdmUgdGhlaXIgdmFsdWVzIHJlZGFjdGVkIGZvciBzZWN1cml0eS5cbiAqXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn1cbiAqICAtIEEgcmVjb3JkIG9mIExhbmdDaGFpbi1zcGVjaWZpYyBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMYW5nQ2hhaW5FbnZWYXJzKCkge1xuICAgIGNvbnN0IGFsbEVudlZhcnMgPSBnZXRFbnZpcm9ubWVudFZhcmlhYmxlcygpIHx8IHt9O1xuICAgIGNvbnN0IGVudlZhcnMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhbGxFbnZWYXJzKSkge1xuICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoXCJMQU5HQ0hBSU5fXCIpICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZW52VmFyc1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZW52VmFycykge1xuICAgICAgICBpZiAoKGtleS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwia2V5XCIpIHx8XG4gICAgICAgICAgICBrZXkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInNlY3JldFwiKSB8fFxuICAgICAgICAgICAga2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJ0b2tlblwiKSkgJiZcbiAgICAgICAgICAgIHR5cGVvZiBlbnZWYXJzW2tleV0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZW52VmFyc1trZXldO1xuICAgICAgICAgICAgZW52VmFyc1trZXldID1cbiAgICAgICAgICAgICAgICB2YWx1ZS5zbGljZSgwLCAyKSArIFwiKlwiLnJlcGVhdCh2YWx1ZS5sZW5ndGggLSA0KSArIHZhbHVlLnNsaWNlKC0yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW52VmFycztcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBMYW5nQ2hhaW4tc3BlY2lmaWMgbWV0YWRhdGEgZnJvbSB0aGUgY3VycmVudCBydW50aW1lIGVudmlyb25tZW50LlxuICpcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fVxuICogIC0gQSByZWNvcmQgb2YgTGFuZ0NoYWluLXNwZWNpZmljIG1ldGFkYXRhIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExhbmdDaGFpbkVudlZhcnNNZXRhZGF0YSgpIHtcbiAgICBjb25zdCBhbGxFbnZWYXJzID0gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZXMoKSB8fCB7fTtcbiAgICBjb25zdCBlbnZWYXJzID0ge307XG4gICAgY29uc3QgZXhjbHVkZWQgPSBbXG4gICAgICAgIFwiTEFOR0NIQUlOX0FQSV9LRVlcIixcbiAgICAgICAgXCJMQU5HQ0hBSU5fRU5EUE9JTlRcIixcbiAgICAgICAgXCJMQU5HQ0hBSU5fVFJBQ0lOR19WMlwiLFxuICAgICAgICBcIkxBTkdDSEFJTl9QUk9KRUNUXCIsXG4gICAgICAgIFwiTEFOR0NIQUlOX1NFU1NJT05cIixcbiAgICBdO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGFsbEVudlZhcnMpKSB7XG4gICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChcIkxBTkdDSEFJTl9cIikgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgIWV4Y2x1ZGVkLmluY2x1ZGVzKGtleSkgJiZcbiAgICAgICAgICAgICFrZXkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImtleVwiKSAmJlxuICAgICAgICAgICAgIWtleS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwic2VjcmV0XCIpICYmXG4gICAgICAgICAgICAha2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJ0b2tlblwiKSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJMQU5HQ0hBSU5fUkVWSVNJT05fSURcIikge1xuICAgICAgICAgICAgICAgIGVudlZhcnNbXCJyZXZpc2lvbl9pZFwiXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZW52VmFyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVudlZhcnM7XG59XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzIGZyb20gdGhlIGN1cnJlbnQgcnVudGltZSBlbnZpcm9ubWVudC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIG9wZXJhdGUgaW4gYSB2YXJpZXR5IG9mIEpTIGVudmlyb25tZW50cyxcbiAqIGluY2x1ZGluZyBOb2RlLmpzLCBEZW5vLCBicm93c2VycywgZXRjLlxuICpcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgdW5kZWZpbmVkfVxuICogIC0gQSByZWNvcmQgb2YgZW52aXJvbm1lbnQgdmFyaWFibGVzIGlmIGF2YWlsYWJsZS5cbiAqICAtIGB1bmRlZmluZWRgIGlmIHRoZSBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IG9yIGFsbG93cyBhY2Nlc3MgdG8gZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZXMoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIE5vZGUuanMgZW52aXJvbm1lbnRcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb2Nlc3MtZW52XG4gICAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb2Nlc3MtZW52XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMocHJvY2Vzcy5lbnYpLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBhY2Nba2V5XSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3IgYnJvd3NlcnMgYW5kIG90aGVyIGVudmlyb25tZW50cywgd2UgbWF5IG5vdCBoYXZlIGRpcmVjdCBhY2Nlc3MgdG8gZW52IHZhcmlhYmxlc1xuICAgICAgICAvLyBSZXR1cm4gdW5kZWZpbmVkIG9yIGFueSBvdGhlciBmYWxsYmFjayBhcyByZXF1aXJlZC5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gQ2F0Y2ggYW55IGVycm9ycyB0aGF0IG1pZ2h0IG9jY3VyIHdoaWxlIHRyeWluZyB0byBhY2Nlc3MgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEVudmlyb25tZW50VmFyaWFibGUobmFtZSkge1xuICAgIC8vIENlcnRhaW4gRGVubyBzZXR1cHMgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB5b3UgdHJ5IHRvIGFjY2VzcyBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaHdjaGFzZTE3L2xhbmdjaGFpbmpzL2lzc3Vlcy8xNDEyXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm9jZXNzLWVudlxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Py5bbmFtZV1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKG5hbWUpIHtcbiAgICByZXR1cm4gKGdldEVudmlyb25tZW50VmFyaWFibGUoYExBTkdTTUlUSF8ke25hbWV9YCkgfHxcbiAgICAgICAgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShgTEFOR0NIQUlOXyR7bmFtZX1gKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2V0RW52aXJvbm1lbnRWYXJpYWJsZShuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvY2Vzcy1lbnZcbiAgICAgICAgcHJvY2Vzcy5lbnZbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG59XG5sZXQgY2FjaGVkQ29tbWl0U0hBcztcbi8qKlxuICogR2V0IHRoZSBHaXQgY29tbWl0IFNIQSBmcm9tIGNvbW1vbiBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAqIHVzZWQgYnkgZGlmZmVyZW50IENJL0NEIHBsYXRmb3Jtcy5cbiAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9IFRoZSBHaXQgY29tbWl0IFNIQSBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2hhcygpIHtcbiAgICBpZiAoY2FjaGVkQ29tbWl0U0hBcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRDb21taXRTSEFzO1xuICAgIH1cbiAgICBjb25zdCBjb21tb25fcmVsZWFzZV9lbnZzID0gW1xuICAgICAgICBcIlZFUkNFTF9HSVRfQ09NTUlUX1NIQVwiLFxuICAgICAgICBcIk5FWFRfUFVCTElDX1ZFUkNFTF9HSVRfQ09NTUlUX1NIQVwiLFxuICAgICAgICBcIkNPTU1JVF9SRUZcIixcbiAgICAgICAgXCJSRU5ERVJfR0lUX0NPTU1JVFwiLFxuICAgICAgICBcIkNJX0NPTU1JVF9TSEFcIixcbiAgICAgICAgXCJDSVJDTEVfU0hBMVwiLFxuICAgICAgICBcIkNGX1BBR0VTX0NPTU1JVF9TSEFcIixcbiAgICAgICAgXCJSRUFDVF9BUFBfR0lUX1NIQVwiLFxuICAgICAgICBcIlNPVVJDRV9WRVJTSU9OXCIsXG4gICAgICAgIFwiR0lUSFVCX1NIQVwiLFxuICAgICAgICBcIlRSQVZJU19DT01NSVRcIixcbiAgICAgICAgXCJHSVRfQ09NTUlUXCIsXG4gICAgICAgIFwiQlVJTERfVkNTX05VTUJFUlwiLFxuICAgICAgICBcImJhbWJvb19wbGFuUmVwb3NpdG9yeV9yZXZpc2lvblwiLFxuICAgICAgICBcIkJ1aWxkLlNvdXJjZVZlcnNpb25cIixcbiAgICAgICAgXCJCSVRCVUNLRVRfQ09NTUlUXCIsXG4gICAgICAgIFwiRFJPTkVfQ09NTUlUX1NIQVwiLFxuICAgICAgICBcIlNFTUFQSE9SRV9HSVRfU0hBXCIsXG4gICAgICAgIFwiQlVJTERLSVRFX0NPTU1JVFwiLFxuICAgIF07XG4gICAgY29uc3Qgc2hhcyA9IHt9O1xuICAgIGZvciAoY29uc3QgZW52IG9mIGNvbW1vbl9yZWxlYXNlX2VudnMpIHtcbiAgICAgICAgY29uc3QgZW52VmFyID0gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShlbnYpO1xuICAgICAgICBpZiAoZW52VmFyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNoYXNbZW52XSA9IGVudlZhcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWNoZWRDb21taXRTSEFzID0gc2hhcztcbiAgICByZXR1cm4gc2hhcztcbn1cbiJdLCJuYW1lcyI6WyJfX3ZlcnNpb25fXyIsImdsb2JhbEVudiIsImlzQnJvd3NlciIsIndpbmRvdyIsImRvY3VtZW50IiwiaXNXZWJXb3JrZXIiLCJnbG9iYWxUaGlzIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiaXNKc0RvbSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImluY2x1ZGVzIiwiaXNEZW5vIiwiRGVubyIsImlzTm9kZSIsInByb2Nlc3MiLCJ2ZXJzaW9ucyIsIm5vZGUiLCJnZXRFbnYiLCJydW50aW1lRW52aXJvbm1lbnQiLCJnZXRSdW50aW1lRW52aXJvbm1lbnQiLCJ1bmRlZmluZWQiLCJlbnYiLCJyZWxlYXNlRW52IiwiZ2V0U2hhcyIsImxpYnJhcnkiLCJydW50aW1lIiwic2RrIiwic2RrX3ZlcnNpb24iLCJnZXRMYW5nQ2hhaW5FbnZWYXJzIiwiYWxsRW52VmFycyIsImdldEVudmlyb25tZW50VmFyaWFibGVzIiwiZW52VmFycyIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsInN0YXJ0c1dpdGgiLCJ0b0xvd2VyQ2FzZSIsInNsaWNlIiwicmVwZWF0IiwibGVuZ3RoIiwiZ2V0TGFuZ0NoYWluRW52VmFyc01ldGFkYXRhIiwiZXhjbHVkZWQiLCJyZWR1Y2UiLCJhY2MiLCJTdHJpbmciLCJlIiwiZ2V0RW52aXJvbm1lbnRWYXJpYWJsZSIsImdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUiLCJzZXRFbnZpcm9ubWVudFZhcmlhYmxlIiwiY2FjaGVkQ29tbWl0U0hBcyIsImNvbW1vbl9yZWxlYXNlX2VudnMiLCJzaGFzIiwiZW52VmFyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/env.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/error.js":
/*!****************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/error.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LangSmithConflictError: () => (/* binding */ LangSmithConflictError),\n/* harmony export */   printErrorStackTrace: () => (/* binding */ printErrorStackTrace),\n/* harmony export */   raiseForStatus: () => (/* binding */ raiseForStatus)\n/* harmony export */ });\nfunction getErrorStackTrace(e) {\n    if (typeof e !== \"object\" || e == null) return undefined;\n    if (!(\"stack\" in e) || typeof e.stack !== \"string\") return undefined;\n    let stack = e.stack;\n    const prevLine = `${e}`;\n    if (stack.startsWith(prevLine)) {\n        stack = stack.slice(prevLine.length);\n    }\n    if (stack.startsWith(\"\\n\")) {\n        stack = stack.slice(1);\n    }\n    return stack;\n}\nfunction printErrorStackTrace(e) {\n    const stack = getErrorStackTrace(e);\n    if (stack == null) return;\n    console.error(stack);\n}\n/**\n * LangSmithConflictError\n *\n * Represents an error that occurs when there's a conflict during an operation,\n * typically corresponding to HTTP 409 status code responses.\n *\n * This error is thrown when an attempt to create or modify a resource conflicts\n * with the current state of the resource on the server. Common scenarios include:\n * - Attempting to create a resource that already exists\n * - Trying to update a resource that has been modified by another process\n * - Violating a uniqueness constraint in the data\n *\n * @extends Error\n *\n * @example\n * try {\n *   await createProject(\"existingProject\");\n * } catch (error) {\n *   if (error instanceof ConflictError) {\n *     console.log(\"A conflict occurred:\", error.message);\n *     // Handle the conflict, e.g., by suggesting a different project name\n *   } else {\n *     // Handle other types of errors\n *   }\n * }\n *\n * @property {string} name - Always set to 'ConflictError' for easy identification\n * @property {string} message - Detailed error message including server response\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/409\n */ class LangSmithConflictError extends Error {\n    constructor(message){\n        super(message);\n        this.name = \"LangSmithConflictError\";\n    }\n}\n/**\n * Throws an appropriate error based on the response status and body.\n *\n * @param response - The fetch Response object\n * @param context - Additional context to include in the error message (e.g., operation being performed)\n * @throws {LangSmithConflictError} When the response status is 409\n * @throws {Error} For all other non-ok responses\n */ async function raiseForStatus(response, context, consume) {\n    // consume the response body to release the connection\n    // https://undici.nodejs.org/#/?id=garbage-collection\n    let errorBody;\n    if (response.ok) {\n        if (consume) {\n            errorBody = await response.text();\n        }\n        return;\n    }\n    errorBody = await response.text();\n    const fullMessage = `Failed to ${context}. Received status [${response.status}]: ${response.statusText}. Server response: ${errorBody}`;\n    if (response.status === 409) {\n        throw new LangSmithConflictError(fullMessage);\n    }\n    throw new Error(fullMessage);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZXJyb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsU0FBU0EsbUJBQW1CQyxDQUFDO0lBQ3pCLElBQUksT0FBT0EsTUFBTSxZQUFZQSxLQUFLLE1BQzlCLE9BQU9DO0lBQ1gsSUFBSSxDQUFFLFlBQVdELENBQUFBLEtBQU0sT0FBT0EsRUFBRUUsS0FBSyxLQUFLLFVBQ3RDLE9BQU9EO0lBQ1gsSUFBSUMsUUFBUUYsRUFBRUUsS0FBSztJQUNuQixNQUFNQyxXQUFXLENBQUMsRUFBRUgsRUFBRSxDQUFDO0lBQ3ZCLElBQUlFLE1BQU1FLFVBQVUsQ0FBQ0QsV0FBVztRQUM1QkQsUUFBUUEsTUFBTUcsS0FBSyxDQUFDRixTQUFTRyxNQUFNO0lBQ3ZDO0lBQ0EsSUFBSUosTUFBTUUsVUFBVSxDQUFDLE9BQU87UUFDeEJGLFFBQVFBLE1BQU1HLEtBQUssQ0FBQztJQUN4QjtJQUNBLE9BQU9IO0FBQ1g7QUFDTyxTQUFTSyxxQkFBcUJQLENBQUM7SUFDbEMsTUFBTUUsUUFBUUgsbUJBQW1CQztJQUNqQyxJQUFJRSxTQUFTLE1BQ1Q7SUFDSk0sUUFBUUMsS0FBSyxDQUFDUDtBQUNsQjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E4QkMsR0FDTSxNQUFNUSwrQkFBK0JDO0lBQ3hDQyxZQUFZQyxPQUFPLENBQUU7UUFDakIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2hCO0FBQ0o7QUFDQTs7Ozs7OztDQU9DLEdBQ00sZUFBZUMsZUFBZUMsUUFBUSxFQUFFQyxPQUFPLEVBQUVDLE9BQU87SUFDM0Qsc0RBQXNEO0lBQ3RELHFEQUFxRDtJQUNyRCxJQUFJQztJQUNKLElBQUlILFNBQVNJLEVBQUUsRUFBRTtRQUNiLElBQUlGLFNBQVM7WUFDVEMsWUFBWSxNQUFNSCxTQUFTSyxJQUFJO1FBQ25DO1FBQ0E7SUFDSjtJQUNBRixZQUFZLE1BQU1ILFNBQVNLLElBQUk7SUFDL0IsTUFBTUMsY0FBYyxDQUFDLFVBQVUsRUFBRUwsUUFBUSxtQkFBbUIsRUFBRUQsU0FBU08sTUFBTSxDQUFDLEdBQUcsRUFBRVAsU0FBU1EsVUFBVSxDQUFDLG1CQUFtQixFQUFFTCxVQUFVLENBQUM7SUFDdkksSUFBSUgsU0FBU08sTUFBTSxLQUFLLEtBQUs7UUFDekIsTUFBTSxJQUFJYix1QkFBdUJZO0lBQ3JDO0lBQ0EsTUFBTSxJQUFJWCxNQUFNVztBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL2hhcmR3YXJlLWRvYy1jaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3V0aWxzL2Vycm9yLmpzPzY3ODYiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZ2V0RXJyb3JTdGFja1RyYWNlKGUpIHtcbiAgICBpZiAodHlwZW9mIGUgIT09IFwib2JqZWN0XCIgfHwgZSA9PSBudWxsKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmICghKFwic3RhY2tcIiBpbiBlKSB8fCB0eXBlb2YgZS5zdGFjayAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBsZXQgc3RhY2sgPSBlLnN0YWNrO1xuICAgIGNvbnN0IHByZXZMaW5lID0gYCR7ZX1gO1xuICAgIGlmIChzdGFjay5zdGFydHNXaXRoKHByZXZMaW5lKSkge1xuICAgICAgICBzdGFjayA9IHN0YWNrLnNsaWNlKHByZXZMaW5lLmxlbmd0aCk7XG4gICAgfVxuICAgIGlmIChzdGFjay5zdGFydHNXaXRoKFwiXFxuXCIpKSB7XG4gICAgICAgIHN0YWNrID0gc3RhY2suc2xpY2UoMSk7XG4gICAgfVxuICAgIHJldHVybiBzdGFjaztcbn1cbmV4cG9ydCBmdW5jdGlvbiBwcmludEVycm9yU3RhY2tUcmFjZShlKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBnZXRFcnJvclN0YWNrVHJhY2UoZSk7XG4gICAgaWYgKHN0YWNrID09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zb2xlLmVycm9yKHN0YWNrKTtcbn1cbi8qKlxuICogTGFuZ1NtaXRoQ29uZmxpY3RFcnJvclxuICpcbiAqIFJlcHJlc2VudHMgYW4gZXJyb3IgdGhhdCBvY2N1cnMgd2hlbiB0aGVyZSdzIGEgY29uZmxpY3QgZHVyaW5nIGFuIG9wZXJhdGlvbixcbiAqIHR5cGljYWxseSBjb3JyZXNwb25kaW5nIHRvIEhUVFAgNDA5IHN0YXR1cyBjb2RlIHJlc3BvbnNlcy5cbiAqXG4gKiBUaGlzIGVycm9yIGlzIHRocm93biB3aGVuIGFuIGF0dGVtcHQgdG8gY3JlYXRlIG9yIG1vZGlmeSBhIHJlc291cmNlIGNvbmZsaWN0c1xuICogd2l0aCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgcmVzb3VyY2Ugb24gdGhlIHNlcnZlci4gQ29tbW9uIHNjZW5hcmlvcyBpbmNsdWRlOlxuICogLSBBdHRlbXB0aW5nIHRvIGNyZWF0ZSBhIHJlc291cmNlIHRoYXQgYWxyZWFkeSBleGlzdHNcbiAqIC0gVHJ5aW5nIHRvIHVwZGF0ZSBhIHJlc291cmNlIHRoYXQgaGFzIGJlZW4gbW9kaWZpZWQgYnkgYW5vdGhlciBwcm9jZXNzXG4gKiAtIFZpb2xhdGluZyBhIHVuaXF1ZW5lc3MgY29uc3RyYWludCBpbiB0aGUgZGF0YVxuICpcbiAqIEBleHRlbmRzIEVycm9yXG4gKlxuICogQGV4YW1wbGVcbiAqIHRyeSB7XG4gKiAgIGF3YWl0IGNyZWF0ZVByb2plY3QoXCJleGlzdGluZ1Byb2plY3RcIik7XG4gKiB9IGNhdGNoIChlcnJvcikge1xuICogICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBDb25mbGljdEVycm9yKSB7XG4gKiAgICAgY29uc29sZS5sb2coXCJBIGNvbmZsaWN0IG9jY3VycmVkOlwiLCBlcnJvci5tZXNzYWdlKTtcbiAqICAgICAvLyBIYW5kbGUgdGhlIGNvbmZsaWN0LCBlLmcuLCBieSBzdWdnZXN0aW5nIGEgZGlmZmVyZW50IHByb2plY3QgbmFtZVxuICogICB9IGVsc2Uge1xuICogICAgIC8vIEhhbmRsZSBvdGhlciB0eXBlcyBvZiBlcnJvcnNcbiAqICAgfVxuICogfVxuICpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gQWx3YXlzIHNldCB0byAnQ29uZmxpY3RFcnJvcicgZm9yIGVhc3kgaWRlbnRpZmljYXRpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gRGV0YWlsZWQgZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgc2VydmVyIHJlc3BvbnNlXG4gKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL1N0YXR1cy80MDlcbiAqL1xuZXhwb3J0IGNsYXNzIExhbmdTbWl0aENvbmZsaWN0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJMYW5nU21pdGhDb25mbGljdEVycm9yXCI7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd3MgYW4gYXBwcm9wcmlhdGUgZXJyb3IgYmFzZWQgb24gdGhlIHJlc3BvbnNlIHN0YXR1cyBhbmQgYm9keS5cbiAqXG4gKiBAcGFyYW0gcmVzcG9uc2UgLSBUaGUgZmV0Y2ggUmVzcG9uc2Ugb2JqZWN0XG4gKiBAcGFyYW0gY29udGV4dCAtIEFkZGl0aW9uYWwgY29udGV4dCB0byBpbmNsdWRlIGluIHRoZSBlcnJvciBtZXNzYWdlIChlLmcuLCBvcGVyYXRpb24gYmVpbmcgcGVyZm9ybWVkKVxuICogQHRocm93cyB7TGFuZ1NtaXRoQ29uZmxpY3RFcnJvcn0gV2hlbiB0aGUgcmVzcG9uc2Ugc3RhdHVzIGlzIDQwOVxuICogQHRocm93cyB7RXJyb3J9IEZvciBhbGwgb3RoZXIgbm9uLW9rIHJlc3BvbnNlc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIGNvbnRleHQsIGNvbnN1bWUpIHtcbiAgICAvLyBjb25zdW1lIHRoZSByZXNwb25zZSBib2R5IHRvIHJlbGVhc2UgdGhlIGNvbm5lY3Rpb25cbiAgICAvLyBodHRwczovL3VuZGljaS5ub2RlanMub3JnLyMvP2lkPWdhcmJhZ2UtY29sbGVjdGlvblxuICAgIGxldCBlcnJvckJvZHk7XG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGlmIChjb25zdW1lKSB7XG4gICAgICAgICAgICBlcnJvckJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlcnJvckJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgY29uc3QgZnVsbE1lc3NhZ2UgPSBgRmFpbGVkIHRvICR7Y29udGV4dH0uIFJlY2VpdmVkIHN0YXR1cyBbJHtyZXNwb25zZS5zdGF0dXN9XTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fS4gU2VydmVyIHJlc3BvbnNlOiAke2Vycm9yQm9keX1gO1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwOSkge1xuICAgICAgICB0aHJvdyBuZXcgTGFuZ1NtaXRoQ29uZmxpY3RFcnJvcihmdWxsTWVzc2FnZSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihmdWxsTWVzc2FnZSk7XG59XG4iXSwibmFtZXMiOlsiZ2V0RXJyb3JTdGFja1RyYWNlIiwiZSIsInVuZGVmaW5lZCIsInN0YWNrIiwicHJldkxpbmUiLCJzdGFydHNXaXRoIiwic2xpY2UiLCJsZW5ndGgiLCJwcmludEVycm9yU3RhY2tUcmFjZSIsImNvbnNvbGUiLCJlcnJvciIsIkxhbmdTbWl0aENvbmZsaWN0RXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsIm5hbWUiLCJyYWlzZUZvclN0YXR1cyIsInJlc3BvbnNlIiwiY29udGV4dCIsImNvbnN1bWUiLCJlcnJvckJvZHkiLCJvayIsInRleHQiLCJmdWxsTWVzc2FnZSIsInN0YXR1cyIsInN0YXR1c1RleHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/fast-safe-stringify/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/fast-safe-stringify/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   stringify: () => (/* binding */ stringify)\n/* harmony export */ });\n/* eslint-disable */ // @ts-nocheck\nvar LIMIT_REPLACE_NODE = \"[...]\";\nvar CIRCULAR_REPLACE_NODE = {\n    result: \"[Circular]\"\n};\nvar arr = [];\nvar replacerStack = [];\nfunction defaultOptions() {\n    return {\n        depthLimit: Number.MAX_SAFE_INTEGER,\n        edgesLimit: Number.MAX_SAFE_INTEGER\n    };\n}\n// Regular stringify\nfunction stringify(obj, replacer, spacer, options) {\n    try {\n        return JSON.stringify(obj, replacer, spacer);\n    } catch (e) {\n        // Fall back to more complex stringify if circular reference\n        if (!e.message?.includes(\"Converting circular structure to JSON\")) {\n            console.warn(\"[WARNING]: LangSmith received unserializable value.\");\n            return \"[Unserializable]\";\n        }\n        console.warn(\"[WARNING]: LangSmith received circular JSON. This will decrease tracer performance.\");\n        if (typeof options === \"undefined\") {\n            options = defaultOptions();\n        }\n        decirc(obj, \"\", 0, [], undefined, 0, options);\n        var res;\n        try {\n            if (replacerStack.length === 0) {\n                res = JSON.stringify(obj, replacer, spacer);\n            } else {\n                res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);\n            }\n        } catch (_) {\n            return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n        } finally{\n            while(arr.length !== 0){\n                var part = arr.pop();\n                if (part.length === 4) {\n                    Object.defineProperty(part[0], part[1], part[3]);\n                } else {\n                    part[0][part[1]] = part[2];\n                }\n            }\n        }\n        return res;\n    }\n}\nfunction setReplace(replace, val, k, parent) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);\n    if (propertyDescriptor.get !== undefined) {\n        if (propertyDescriptor.configurable) {\n            Object.defineProperty(parent, k, {\n                value: replace\n            });\n            arr.push([\n                parent,\n                k,\n                val,\n                propertyDescriptor\n            ]);\n        } else {\n            replacerStack.push([\n                val,\n                k,\n                replace\n            ]);\n        }\n    } else {\n        parent[k] = replace;\n        arr.push([\n            parent,\n            k,\n            val\n        ]);\n    }\n}\nfunction decirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (typeof val === \"object\" && val !== null) {\n        for(i = 0; i < stack.length; i++){\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        if (typeof options.depthLimit !== \"undefined\" && depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" && edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for(i = 0; i < val.length; i++){\n                decirc(val[i], i, i, stack, val, depth, options);\n            }\n        } else {\n            var keys = Object.keys(val);\n            for(i = 0; i < keys.length; i++){\n                var key = keys[i];\n                decirc(val[key], key, i, stack, val, depth, options);\n            }\n        }\n        stack.pop();\n    }\n}\n// Stable-stringify\nfunction compareFunction(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nfunction deterministicStringify(obj, replacer, spacer, options) {\n    if (typeof options === \"undefined\") {\n        options = defaultOptions();\n    }\n    var tmp = deterministicDecirc(obj, \"\", 0, [], undefined, 0, options) || obj;\n    var res;\n    try {\n        if (replacerStack.length === 0) {\n            res = JSON.stringify(tmp, replacer, spacer);\n        } else {\n            res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);\n        }\n    } catch (_) {\n        return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n    } finally{\n        // Ensure that we restore the object as it was.\n        while(arr.length !== 0){\n            var part = arr.pop();\n            if (part.length === 4) {\n                Object.defineProperty(part[0], part[1], part[3]);\n            } else {\n                part[0][part[1]] = part[2];\n            }\n        }\n    }\n    return res;\n}\nfunction deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (typeof val === \"object\" && val !== null) {\n        for(i = 0; i < stack.length; i++){\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        try {\n            if (typeof val.toJSON === \"function\") {\n                return;\n            }\n        } catch (_) {\n            return;\n        }\n        if (typeof options.depthLimit !== \"undefined\" && depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" && edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for(i = 0; i < val.length; i++){\n                deterministicDecirc(val[i], i, i, stack, val, depth, options);\n            }\n        } else {\n            // Create a temporary object in the required way\n            var tmp = {};\n            var keys = Object.keys(val).sort(compareFunction);\n            for(i = 0; i < keys.length; i++){\n                var key = keys[i];\n                deterministicDecirc(val[key], key, i, stack, val, depth, options);\n                tmp[key] = val[key];\n            }\n            if (typeof parent !== \"undefined\") {\n                arr.push([\n                    parent,\n                    k,\n                    val\n                ]);\n                parent[k] = tmp;\n            } else {\n                return tmp;\n            }\n        }\n        stack.pop();\n    }\n}\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues(replacer) {\n    replacer = typeof replacer !== \"undefined\" ? replacer : function(k, v) {\n        return v;\n    };\n    return function(key, val) {\n        if (replacerStack.length > 0) {\n            for(var i = 0; i < replacerStack.length; i++){\n                var part = replacerStack[i];\n                if (part[1] === key && part[0] === val) {\n                    val = part[2];\n                    replacerStack.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        return replacer.call(this, key, val);\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZmFzdC1zYWZlLXN0cmluZ2lmeS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsa0JBQWtCLEdBQ2xCLGNBQWM7QUFDZCxJQUFJQSxxQkFBcUI7QUFDekIsSUFBSUMsd0JBQXdCO0lBQUVDLFFBQVE7QUFBYTtBQUNuRCxJQUFJQyxNQUFNLEVBQUU7QUFDWixJQUFJQyxnQkFBZ0IsRUFBRTtBQUN0QixTQUFTQztJQUNMLE9BQU87UUFDSEMsWUFBWUMsT0FBT0MsZ0JBQWdCO1FBQ25DQyxZQUFZRixPQUFPQyxnQkFBZ0I7SUFDdkM7QUFDSjtBQUNBLG9CQUFvQjtBQUNiLFNBQVNFLFVBQVVDLEdBQUcsRUFBRUMsUUFBUSxFQUFFQyxNQUFNLEVBQUVDLE9BQU87SUFDcEQsSUFBSTtRQUNBLE9BQU9DLEtBQUtMLFNBQVMsQ0FBQ0MsS0FBS0MsVUFBVUM7SUFDekMsRUFDQSxPQUFPRyxHQUFHO1FBQ04sNERBQTREO1FBQzVELElBQUksQ0FBQ0EsRUFBRUMsT0FBTyxFQUFFQyxTQUFTLDBDQUEwQztZQUMvREMsUUFBUUMsSUFBSSxDQUFDO1lBQ2IsT0FBTztRQUNYO1FBQ0FELFFBQVFDLElBQUksQ0FBQztRQUNiLElBQUksT0FBT04sWUFBWSxhQUFhO1lBQ2hDQSxVQUFVVDtRQUNkO1FBQ0FnQixPQUFPVixLQUFLLElBQUksR0FBRyxFQUFFLEVBQUVXLFdBQVcsR0FBR1I7UUFDckMsSUFBSVM7UUFDSixJQUFJO1lBQ0EsSUFBSW5CLGNBQWNvQixNQUFNLEtBQUssR0FBRztnQkFDNUJELE1BQU1SLEtBQUtMLFNBQVMsQ0FBQ0MsS0FBS0MsVUFBVUM7WUFDeEMsT0FDSztnQkFDRFUsTUFBTVIsS0FBS0wsU0FBUyxDQUFDQyxLQUFLYyxvQkFBb0JiLFdBQVdDO1lBQzdEO1FBQ0osRUFDQSxPQUFPYSxHQUFHO1lBQ04sT0FBT1gsS0FBS0wsU0FBUyxDQUFDO1FBQzFCLFNBQ1E7WUFDSixNQUFP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S0FBS1csT0FBTzlCO2dCQUN6RHdDLEdBQUcsQ0FBQ0wsSUFBSSxHQUFHaEIsR0FBRyxDQUFDZ0IsSUFBSTtZQUN2QjtZQUNBLElBQUksT0FBT2QsV0FBVyxhQUFhO2dCQUMvQmhDLElBQUlzQyxJQUFJLENBQUM7b0JBQUNOO29CQUFRRDtvQkFBR0Q7aUJBQUk7Z0JBQ3pCRSxNQUFNLENBQUNELEVBQUUsR0FBR29CO1lBQ2hCLE9BQ0s7Z0JBQ0QsT0FBT0E7WUFDWDtRQUNKO1FBQ0FYLE1BQU1mLEdBQUc7SUFDYjtBQUNKO0FBQ0EsK0RBQStEO0FBQy9ELGtDQUFrQztBQUNsQyxTQUFTSCxvQkFBb0JiLFFBQVE7SUFDakNBLFdBQ0ksT0FBT0EsYUFBYSxjQUNkQSxXQUNBLFNBQVVzQixDQUFDLEVBQUV3QixDQUFDO1FBQ1osT0FBT0E7SUFDWDtJQUNSLE9BQU8sU0FBVVQsR0FBRyxFQUFFaEIsR0FBRztRQUNyQixJQUFJN0IsY0FBY29CLE1BQU0sR0FBRyxHQUFHO1lBQzFCLElBQUssSUFBSXFCLElBQUksR0FBR0EsSUFBSXpDLGNBQWNvQixNQUFNLEVBQUVxQixJQUFLO2dCQUMzQyxJQUFJbEIsT0FBT3ZCLGFBQWEsQ0FBQ3lDLEVBQUU7Z0JBQzNCLElBQUlsQixJQUFJLENBQUMsRUFBRSxLQUFLc0IsT0FBT3RCLElBQUksQ0FBQyxFQUFFLEtBQUtNLEtBQUs7b0JBQ3BDQSxNQUFNTixJQUFJLENBQUMsRUFBRTtvQkFDYnZCLGNBQWN1RCxNQUFNLENBQUNkLEdBQUc7b0JBQ3hCO2dCQUNKO1lBQ0o7UUFDSjtRQUNBLE9BQU9qQyxTQUFTZ0QsSUFBSSxDQUFDLElBQUksRUFBRVgsS0FBS2hCO0lBQ3BDO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYXJkd2FyZS1kb2MtY2hhdGJvdC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9mYXN0LXNhZmUtc3RyaW5naWZ5L2luZGV4LmpzPzgxZTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIEB0cy1ub2NoZWNrXG52YXIgTElNSVRfUkVQTEFDRV9OT0RFID0gXCJbLi4uXVwiO1xudmFyIENJUkNVTEFSX1JFUExBQ0VfTk9ERSA9IHsgcmVzdWx0OiBcIltDaXJjdWxhcl1cIiB9O1xudmFyIGFyciA9IFtdO1xudmFyIHJlcGxhY2VyU3RhY2sgPSBbXTtcbmZ1bmN0aW9uIGRlZmF1bHRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlcHRoTGltaXQ6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgICBlZGdlc0xpbWl0OiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICB9O1xufVxuLy8gUmVndWxhciBzdHJpbmdpZnlcbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnkob2JqLCByZXBsYWNlciwgc3BhY2VyLCBvcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIsIHNwYWNlcik7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIEZhbGwgYmFjayB0byBtb3JlIGNvbXBsZXggc3RyaW5naWZ5IGlmIGNpcmN1bGFyIHJlZmVyZW5jZVxuICAgICAgICBpZiAoIWUubWVzc2FnZT8uaW5jbHVkZXMoXCJDb252ZXJ0aW5nIGNpcmN1bGFyIHN0cnVjdHVyZSB0byBKU09OXCIpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbV0FSTklOR106IExhbmdTbWl0aCByZWNlaXZlZCB1bnNlcmlhbGl6YWJsZSB2YWx1ZS5cIik7XG4gICAgICAgICAgICByZXR1cm4gXCJbVW5zZXJpYWxpemFibGVdXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS53YXJuKFwiW1dBUk5JTkddOiBMYW5nU21pdGggcmVjZWl2ZWQgY2lyY3VsYXIgSlNPTi4gVGhpcyB3aWxsIGRlY3JlYXNlIHRyYWNlciBwZXJmb3JtYW5jZS5cIik7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zKCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVjaXJjKG9iaiwgXCJcIiwgMCwgW10sIHVuZGVmaW5lZCwgMCwgb3B0aW9ucyk7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAocmVwbGFjZXJTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXMgPSBKU09OLnN0cmluZ2lmeShvYmosIHJlcGxhY2VyLCBzcGFjZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkob2JqLCByZXBsYWNlR2V0dGVyVmFsdWVzKHJlcGxhY2VyKSwgc3BhY2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFwiW3VuYWJsZSB0byBzZXJpYWxpemUsIGNpcmN1bGFyIHJlZmVyZW5jZSBpcyB0b28gY29tcGxleCB0byBhbmFseXplXVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdoaWxlIChhcnIubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBhcnIucG9wKCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJ0WzBdLCBwYXJ0WzFdLCBwYXJ0WzNdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRbMF1bcGFydFsxXV0gPSBwYXJ0WzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldFJlcGxhY2UocmVwbGFjZSwgdmFsLCBrLCBwYXJlbnQpIHtcbiAgICB2YXIgcHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwYXJlbnQsIGspO1xuICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IuZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHByb3BlcnR5RGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJlbnQsIGssIHsgdmFsdWU6IHJlcGxhY2UgfSk7XG4gICAgICAgICAgICBhcnIucHVzaChbcGFyZW50LCBrLCB2YWwsIHByb3BlcnR5RGVzY3JpcHRvcl0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVwbGFjZXJTdGFjay5wdXNoKFt2YWwsIGssIHJlcGxhY2VdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGFyZW50W2tdID0gcmVwbGFjZTtcbiAgICAgICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVjaXJjKHZhbCwgaywgZWRnZUluZGV4LCBzdGFjaywgcGFyZW50LCBkZXB0aCwgb3B0aW9ucykge1xuICAgIGRlcHRoICs9IDE7XG4gICAgdmFyIGk7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHN0YWNrW2ldID09PSB2YWwpIHtcbiAgICAgICAgICAgICAgICBzZXRSZXBsYWNlKENJUkNVTEFSX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVwdGhMaW1pdCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgZGVwdGggPiBvcHRpb25zLmRlcHRoTGltaXQpIHtcbiAgICAgICAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmVkZ2VzTGltaXQgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIGVkZ2VJbmRleCArIDEgPiBvcHRpb25zLmVkZ2VzTGltaXQpIHtcbiAgICAgICAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucHVzaCh2YWwpO1xuICAgICAgICAvLyBPcHRpbWl6ZSBmb3IgQXJyYXlzLiBCaWcgYXJyYXlzIGNvdWxkIGtpbGwgdGhlIHBlcmZvcm1hbmNlIG90aGVyd2lzZSFcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRlY2lyYyh2YWxbaV0sIGksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgZGVjaXJjKHZhbFtrZXldLCBrZXksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICB9XG59XG4vLyBTdGFibGUtc3RyaW5naWZ5XG5mdW5jdGlvbiBjb21wYXJlRnVuY3Rpb24oYSwgYikge1xuICAgIGlmIChhIDwgYikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChhID4gYikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBkZXRlcm1pbmlzdGljU3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIsIHNwYWNlciwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnMoKTtcbiAgICB9XG4gICAgdmFyIHRtcCA9IGRldGVybWluaXN0aWNEZWNpcmMob2JqLCBcIlwiLCAwLCBbXSwgdW5kZWZpbmVkLCAwLCBvcHRpb25zKSB8fCBvYmo7XG4gICAgdmFyIHJlcztcbiAgICB0cnkge1xuICAgICAgICBpZiAocmVwbGFjZXJTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KHRtcCwgcmVwbGFjZXIsIHNwYWNlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBKU09OLnN0cmluZ2lmeSh0bXAsIHJlcGxhY2VHZXR0ZXJWYWx1ZXMocmVwbGFjZXIpLCBzcGFjZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShcIlt1bmFibGUgdG8gc2VyaWFsaXplLCBjaXJjdWxhciByZWZlcmVuY2UgaXMgdG9vIGNvbXBsZXggdG8gYW5hbHl6ZV1cIik7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICAvLyBFbnN1cmUgdGhhdCB3ZSByZXN0b3JlIHRoZSBvYmplY3QgYXMgaXQgd2FzLlxuICAgICAgICB3aGlsZSAoYXJyLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgdmFyIHBhcnQgPSBhcnIucG9wKCk7XG4gICAgICAgICAgICBpZiAocGFydC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFydFswXSwgcGFydFsxXSwgcGFydFszXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJ0WzBdW3BhcnRbMV1dID0gcGFydFsyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWwsIGssIGVkZ2VJbmRleCwgc3RhY2ssIHBhcmVudCwgZGVwdGgsIG9wdGlvbnMpIHtcbiAgICBkZXB0aCArPSAxO1xuICAgIHZhciBpO1xuICAgIGlmICh0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzdGFja1tpXSA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVwbGFjZShDSVJDVUxBUl9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlcHRoTGltaXQgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIGRlcHRoID4gb3B0aW9ucy5kZXB0aExpbWl0KSB7XG4gICAgICAgICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5lZGdlc0xpbWl0ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICBlZGdlSW5kZXggKyAxID4gb3B0aW9ucy5lZGdlc0xpbWl0KSB7XG4gICAgICAgICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnB1c2godmFsKTtcbiAgICAgICAgLy8gT3B0aW1pemUgZm9yIEFycmF5cy4gQmlnIGFycmF5cyBjb3VsZCBraWxsIHRoZSBwZXJmb3JtYW5jZSBvdGhlcndpc2UhXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZXRlcm1pbmlzdGljRGVjaXJjKHZhbFtpXSwgaSwgaSwgc3RhY2ssIHZhbCwgZGVwdGgsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IG9iamVjdCBpbiB0aGUgcmVxdWlyZWQgd2F5XG4gICAgICAgICAgICB2YXIgdG1wID0ge307XG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbCkuc29ydChjb21wYXJlRnVuY3Rpb24pO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICBkZXRlcm1pbmlzdGljRGVjaXJjKHZhbFtrZXldLCBrZXksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB0bXBba2V5XSA9IHZhbFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJlbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChbcGFyZW50LCBrLCB2YWxdKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRba10gPSB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgIH1cbn1cbi8vIHdyYXBzIHJlcGxhY2VyIGZ1bmN0aW9uIHRvIGhhbmRsZSB2YWx1ZXMgd2UgY291bGRuJ3QgcmVwbGFjZVxuLy8gYW5kIG1hcmsgdGhlbSBhcyByZXBsYWNlZCB2YWx1ZVxuZnVuY3Rpb24gcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlcikge1xuICAgIHJlcGxhY2VyID1cbiAgICAgICAgdHlwZW9mIHJlcGxhY2VyICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICA/IHJlcGxhY2VyXG4gICAgICAgICAgICA6IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBsYWNlclN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnQgPSByZXBsYWNlclN0YWNrW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0WzFdID09PSBrZXkgJiYgcGFydFswXSA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcnRbMl07XG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VyU3RhY2suc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWwpO1xuICAgIH07XG59XG4iXSwibmFtZXMiOlsiTElNSVRfUkVQTEFDRV9OT0RFIiwiQ0lSQ1VMQVJfUkVQTEFDRV9OT0RFIiwicmVzdWx0IiwiYXJyIiwicmVwbGFjZXJTdGFjayIsImRlZmF1bHRPcHRpb25zIiwiZGVwdGhMaW1pdCIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJlZGdlc0xpbWl0Iiwic3RyaW5naWZ5Iiwib2JqIiwicmVwbGFjZXIiLCJzcGFjZXIiLCJvcHRpb25zIiwiSlNPTiIsImUiLCJtZXNzYWdlIiwiaW5jbHVkZXMiLCJjb25zb2xlIiwid2FybiIsImRlY2lyYyIsInVuZGVmaW5lZCIsInJlcyIsImxlbmd0aCIsInJlcGxhY2VHZXR0ZXJWYWx1ZXMiLCJfIiwicGFydCIsInBvcCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5Iiwic2V0UmVwbGFjZSIsInJlcGxhY2UiLCJ2YWwiLCJrIiwicGFyZW50IiwicHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0IiwiY29uZmlndXJhYmxlIiwidmFsdWUiLCJwdXNoIiwiZWRnZUluZGV4Iiwic3RhY2siLCJkZXB0aCIsImkiLCJBcnJheSIsImlzQXJyYXkiLCJrZXlzIiwia2V5IiwiY29tcGFyZUZ1bmN0aW9uIiwiYSIsImIiLCJkZXRlcm1pbmlzdGljU3RyaW5naWZ5IiwidG1wIiwiZGV0ZXJtaW5pc3RpY0RlY2lyYyIsInRvSlNPTiIsInNvcnQiLCJ2Iiwic3BsaWNlIiwiY2FsbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/fast-safe-stringify/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/messages.js":
/*!*******************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/messages.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertLangChainMessageToExample: () => (/* binding */ convertLangChainMessageToExample),\n/* harmony export */   isLangChainMessage: () => (/* binding */ isLangChainMessage)\n/* harmony export */ });\nfunction isLangChainMessage(// eslint-disable-next-line @typescript-eslint/no-explicit-any\nmessage) {\n    return typeof message?._getType === \"function\";\n}\nfunction convertLangChainMessageToExample(message) {\n    const converted = {\n        type: message._getType(),\n        data: {\n            content: message.content\n        }\n    };\n    // Check for presence of keys in additional_kwargs\n    if (message?.additional_kwargs && Object.keys(message.additional_kwargs).length > 0) {\n        converted.data.additional_kwargs = {\n            ...message.additional_kwargs\n        };\n    }\n    return converted;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvbWVzc2FnZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxTQUFTQSxtQkFDaEIsOERBQThEO0FBQzlEQyxPQUFPO0lBQ0gsT0FBTyxPQUFPQSxTQUFTQyxhQUFhO0FBQ3hDO0FBQ08sU0FBU0MsaUNBQWlDRixPQUFPO0lBQ3BELE1BQU1HLFlBQVk7UUFDZEMsTUFBTUosUUFBUUMsUUFBUTtRQUN0QkksTUFBTTtZQUFFQyxTQUFTTixRQUFRTSxPQUFPO1FBQUM7SUFDckM7SUFDQSxrREFBa0Q7SUFDbEQsSUFBSU4sU0FBU08scUJBQ1RDLE9BQU9DLElBQUksQ0FBQ1QsUUFBUU8saUJBQWlCLEVBQUVHLE1BQU0sR0FBRyxHQUFHO1FBQ25EUCxVQUFVRSxJQUFJLENBQUNFLGlCQUFpQixHQUFHO1lBQUUsR0FBR1AsUUFBUU8saUJBQWlCO1FBQUM7SUFDdEU7SUFDQSxPQUFPSjtBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGFyZHdhcmUtZG9jLWNoYXRib3QvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvbWVzc2FnZXMuanM/NDczYSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gaXNMYW5nQ2hhaW5NZXNzYWdlKFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbm1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdHlwZW9mIG1lc3NhZ2U/Ll9nZXRUeXBlID09PSBcImZ1bmN0aW9uXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gY29udmVydExhbmdDaGFpbk1lc3NhZ2VUb0V4YW1wbGUobWVzc2FnZSkge1xuICAgIGNvbnN0IGNvbnZlcnRlZCA9IHtcbiAgICAgICAgdHlwZTogbWVzc2FnZS5fZ2V0VHlwZSgpLFxuICAgICAgICBkYXRhOiB7IGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudCB9LFxuICAgIH07XG4gICAgLy8gQ2hlY2sgZm9yIHByZXNlbmNlIG9mIGtleXMgaW4gYWRkaXRpb25hbF9rd2FyZ3NcbiAgICBpZiAobWVzc2FnZT8uYWRkaXRpb25hbF9rd2FyZ3MgJiZcbiAgICAgICAgT2JqZWN0LmtleXMobWVzc2FnZS5hZGRpdGlvbmFsX2t3YXJncykubGVuZ3RoID4gMCkge1xuICAgICAgICBjb252ZXJ0ZWQuZGF0YS5hZGRpdGlvbmFsX2t3YXJncyA9IHsgLi4ubWVzc2FnZS5hZGRpdGlvbmFsX2t3YXJncyB9O1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydGVkO1xufVxuIl0sIm5hbWVzIjpbImlzTGFuZ0NoYWluTWVzc2FnZSIsIm1lc3NhZ2UiLCJfZ2V0VHlwZSIsImNvbnZlcnRMYW5nQ2hhaW5NZXNzYWdlVG9FeGFtcGxlIiwiY29udmVydGVkIiwidHlwZSIsImRhdGEiLCJjb250ZW50IiwiYWRkaXRpb25hbF9rd2FyZ3MiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/messages.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/prompts.js":
/*!******************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/prompts.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isVersionGreaterOrEqual: () => (/* binding */ isVersionGreaterOrEqual),\n/* harmony export */   parsePromptIdentifier: () => (/* binding */ parsePromptIdentifier)\n/* harmony export */ });\n/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! semver */ \"(rsc)/./node_modules/semver/index.js\");\n\nfunction isVersionGreaterOrEqual(current_version, target_version) {\n    const current = (0,semver__WEBPACK_IMPORTED_MODULE_0__.parse)(current_version);\n    const target = (0,semver__WEBPACK_IMPORTED_MODULE_0__.parse)(target_version);\n    if (!current || !target) {\n        throw new Error(\"Invalid version format.\");\n    }\n    return current.compare(target) >= 0;\n}\nfunction parsePromptIdentifier(identifier) {\n    if (!identifier || identifier.split(\"/\").length > 2 || identifier.startsWith(\"/\") || identifier.endsWith(\"/\") || identifier.split(\":\").length > 2) {\n        throw new Error(`Invalid identifier format: ${identifier}`);\n    }\n    const [ownerNamePart, commitPart] = identifier.split(\":\");\n    const commit = commitPart || \"latest\";\n    if (ownerNamePart.includes(\"/\")) {\n        const [owner, name] = ownerNamePart.split(\"/\", 2);\n        if (!owner || !name) {\n            throw new Error(`Invalid identifier format: ${identifier}`);\n        }\n        return [\n            owner,\n            name,\n            commit\n        ];\n    } else {\n        if (!ownerNamePart) {\n            throw new Error(`Invalid identifier format: ${identifier}`);\n        }\n        return [\n            \"-\",\n            ownerNamePart,\n            commit\n        ];\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvcHJvbXB0cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0M7QUFDeEMsU0FBU0Usd0JBQXdCQyxlQUFlLEVBQUVDLGNBQWM7SUFDbkUsTUFBTUMsVUFBVUosNkNBQVlBLENBQUNFO0lBQzdCLE1BQU1HLFNBQVNMLDZDQUFZQSxDQUFDRztJQUM1QixJQUFJLENBQUNDLFdBQVcsQ0FBQ0MsUUFBUTtRQUNyQixNQUFNLElBQUlDLE1BQU07SUFDcEI7SUFDQSxPQUFPRixRQUFRRyxPQUFPLENBQUNGLFdBQVc7QUFDdEM7QUFDTyxTQUFTRyxzQkFBc0JDLFVBQVU7SUFDNUMsSUFBSSxDQUFDQSxjQUNEQSxXQUFXQyxLQUFLLENBQUMsS0FBS0MsTUFBTSxHQUFHLEtBQy9CRixXQUFXRyxVQUFVLENBQUMsUUFDdEJILFdBQVdJLFFBQVEsQ0FBQyxRQUNwQkosV0FBV0MsS0FBSyxDQUFDLEtBQUtDLE1BQU0sR0FBRyxHQUFHO1FBQ2xDLE1BQU0sSUFBSUwsTUFBTSxDQUFDLDJCQUEyQixFQUFFRyxXQUFXLENBQUM7SUFDOUQ7SUFDQSxNQUFNLENBQUNLLGVBQWVDLFdBQVcsR0FBR04sV0FBV0MsS0FBSyxDQUFDO0lBQ3JELE1BQU1NLFNBQVNELGNBQWM7SUFDN0IsSUFBSUQsY0FBY0csUUFBUSxDQUFDLE1BQU07UUFDN0IsTUFBTSxDQUFDQyxPQUFPQyxLQUFLLEdBQUdMLGNBQWNKLEtBQUssQ0FBQyxLQUFLO1FBQy9DLElBQUksQ0FBQ1EsU0FBUyxDQUFDQyxNQUFNO1lBQ2pCLE1BQU0sSUFBSWIsTUFBTSxDQUFDLDJCQUEyQixFQUFFRyxXQUFXLENBQUM7UUFDOUQ7UUFDQSxPQUFPO1lBQUNTO1lBQU9DO1lBQU1IO1NBQU87SUFDaEMsT0FDSztRQUNELElBQUksQ0FBQ0YsZUFBZTtZQUNoQixNQUFNLElBQUlSLE1BQU0sQ0FBQywyQkFBMkIsRUFBRUcsV0FBVyxDQUFDO1FBQzlEO1FBQ0EsT0FBTztZQUFDO1lBQUtLO1lBQWVFO1NBQU87SUFDdkM7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL2hhcmR3YXJlLWRvYy1jaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3V0aWxzL3Byb21wdHMuanM/NzliMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJzZSBhcyBwYXJzZVZlcnNpb24gfSBmcm9tIFwic2VtdmVyXCI7XG5leHBvcnQgZnVuY3Rpb24gaXNWZXJzaW9uR3JlYXRlck9yRXF1YWwoY3VycmVudF92ZXJzaW9uLCB0YXJnZXRfdmVyc2lvbikge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBwYXJzZVZlcnNpb24oY3VycmVudF92ZXJzaW9uKTtcbiAgICBjb25zdCB0YXJnZXQgPSBwYXJzZVZlcnNpb24odGFyZ2V0X3ZlcnNpb24pO1xuICAgIGlmICghY3VycmVudCB8fCAhdGFyZ2V0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmVyc2lvbiBmb3JtYXQuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudC5jb21wYXJlKHRhcmdldCkgPj0gMDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVByb21wdElkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICAgIGlmICghaWRlbnRpZmllciB8fFxuICAgICAgICBpZGVudGlmaWVyLnNwbGl0KFwiL1wiKS5sZW5ndGggPiAyIHx8XG4gICAgICAgIGlkZW50aWZpZXIuc3RhcnRzV2l0aChcIi9cIikgfHxcbiAgICAgICAgaWRlbnRpZmllci5lbmRzV2l0aChcIi9cIikgfHxcbiAgICAgICAgaWRlbnRpZmllci5zcGxpdChcIjpcIikubGVuZ3RoID4gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaWRlbnRpZmllciBmb3JtYXQ6ICR7aWRlbnRpZmllcn1gKTtcbiAgICB9XG4gICAgY29uc3QgW293bmVyTmFtZVBhcnQsIGNvbW1pdFBhcnRdID0gaWRlbnRpZmllci5zcGxpdChcIjpcIik7XG4gICAgY29uc3QgY29tbWl0ID0gY29tbWl0UGFydCB8fCBcImxhdGVzdFwiO1xuICAgIGlmIChvd25lck5hbWVQYXJ0LmluY2x1ZGVzKFwiL1wiKSkge1xuICAgICAgICBjb25zdCBbb3duZXIsIG5hbWVdID0gb3duZXJOYW1lUGFydC5zcGxpdChcIi9cIiwgMik7XG4gICAgICAgIGlmICghb3duZXIgfHwgIW5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBpZGVudGlmaWVyIGZvcm1hdDogJHtpZGVudGlmaWVyfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbb3duZXIsIG5hbWUsIGNvbW1pdF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIW93bmVyTmFtZVBhcnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBpZGVudGlmaWVyIGZvcm1hdDogJHtpZGVudGlmaWVyfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXCItXCIsIG93bmVyTmFtZVBhcnQsIGNvbW1pdF07XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbInBhcnNlIiwicGFyc2VWZXJzaW9uIiwiaXNWZXJzaW9uR3JlYXRlck9yRXF1YWwiLCJjdXJyZW50X3ZlcnNpb24iLCJ0YXJnZXRfdmVyc2lvbiIsImN1cnJlbnQiLCJ0YXJnZXQiLCJFcnJvciIsImNvbXBhcmUiLCJwYXJzZVByb21wdElkZW50aWZpZXIiLCJpZGVudGlmaWVyIiwic3BsaXQiLCJsZW5ndGgiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJvd25lck5hbWVQYXJ0IiwiY29tbWl0UGFydCIsImNvbW1pdCIsImluY2x1ZGVzIiwib3duZXIiLCJuYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/prompts.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/warn.js":
/*!***************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/warn.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   warnOnce: () => (/* binding */ warnOnce)\n/* harmony export */ });\nconst warnedMessages = {};\nfunction warnOnce(message) {\n    if (!warnedMessages[message]) {\n        console.warn(message);\n        warnedMessages[message] = true;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvd2Fybi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsaUJBQWlCLENBQUM7QUFDakIsU0FBU0MsU0FBU0MsT0FBTztJQUM1QixJQUFJLENBQUNGLGNBQWMsQ0FBQ0UsUUFBUSxFQUFFO1FBQzFCQyxRQUFRQyxJQUFJLENBQUNGO1FBQ2JGLGNBQWMsQ0FBQ0UsUUFBUSxHQUFHO0lBQzlCO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYXJkd2FyZS1kb2MtY2hhdGJvdC8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy93YXJuLmpzPzAyZDAiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgd2FybmVkTWVzc2FnZXMgPSB7fTtcbmV4cG9ydCBmdW5jdGlvbiB3YXJuT25jZShtZXNzYWdlKSB7XG4gICAgaWYgKCF3YXJuZWRNZXNzYWdlc1ttZXNzYWdlXSkge1xuICAgICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgICAgIHdhcm5lZE1lc3NhZ2VzW21lc3NhZ2VdID0gdHJ1ZTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsid2FybmVkTWVzc2FnZXMiLCJ3YXJuT25jZSIsIm1lc3NhZ2UiLCJjb25zb2xlIiwid2FybiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/warn.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/index.js":
/*!*****************************************!*\
  !*** ./node_modules/langsmith/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Client),\n/* harmony export */   RunTree: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.RunTree),\n/* harmony export */   __version__: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.__version__),\n/* harmony export */   overrideFetchImplementation: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.overrideFetchImplementation)\n/* harmony export */ });\n/* harmony import */ var _dist_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.js */ \"(rsc)/./node_modules/langsmith/dist/index.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGFyZHdhcmUtZG9jLWNoYXRib3QvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2luZGV4LmpzPzE4MWIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9kaXN0L2luZGV4LmpzJyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/run_trees.js":
/*!*********************************************!*\
  !*** ./node_modules/langsmith/run_trees.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RunTree: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.RunTree),\n/* harmony export */   convertToDottedOrderFormat: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.convertToDottedOrderFormat),\n/* harmony export */   isRunTree: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.isRunTree),\n/* harmony export */   isRunnableConfigLike: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.isRunnableConfigLike)\n/* harmony export */ });\n/* harmony import */ var _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/run_trees.js */ \"(rsc)/./node_modules/langsmith/dist/run_trees.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL3J1bl90cmVlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hhcmR3YXJlLWRvYy1jaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9ydW5fdHJlZXMuanM/MDUyYSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuL2Rpc3QvcnVuX3RyZWVzLmpzJyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/run_trees.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/singletons/traceable.js":
/*!********************************************************!*\
  !*** ./node_modules/langsmith/singletons/traceable.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncLocalStorageProviderSingleton: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton),\n/* harmony export */   ROOT: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.ROOT),\n/* harmony export */   getCurrentRunTree: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentRunTree),\n/* harmony export */   isTraceableFunction: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.isTraceableFunction),\n/* harmony export */   withRunTree: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.withRunTree)\n/* harmony export */ });\n/* harmony import */ var _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dist/singletons/traceable.js */ \"(rsc)/./node_modules/langsmith/dist/singletons/traceable.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL3NpbmdsZXRvbnMvdHJhY2VhYmxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUErQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hhcmR3YXJlLWRvYy1jaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9zaW5nbGV0b25zL3RyYWNlYWJsZS5qcz8yNmY2Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4uL2Rpc3Qvc2luZ2xldG9ucy90cmFjZWFibGUuanMnIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/singletons/traceable.js\n");

/***/ })

};
;